<?xml version="1.0"?>
<doc>
    <assembly>
        <name>UIShell.OSGi</name>
    </assembly>
    <members>
        <member name="T:UIShell.OSGi.BundleLazyActivatedEventArgs">
            <summary>
            Bundle 晚激活事件。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.BundleEventArgs">
            <summary>
            Bundle事件参数，用于监听一个插件生命周期变化或者晚激活。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.BundleEventArgs.#ctor(UIShell.OSGi.IBundle)">
            <summary>
            构造一个BundleEventArgs实例。
            </summary>
            <param name="bundle"></param>
        </member>
        <member name="P:UIShell.OSGi.BundleEventArgs.Bundle">
            <summary>
            触发事件的Bundle。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.BundleLazyActivatedEventArgs.#ctor(UIShell.OSGi.IBundle)">
            <summary>
            创建一个BundleLazyActivationEventArgs实例。
            </summary>
            <param name="bundle">发生晚激活事件的Bundle</param>
        </member>
        <member name="T:UIShell.OSGi.BundleStateChangedEventArgs">
            <summary>
            Bundle状态变更事件参数，用于监听一个插件生命周期变化。
            </summary>
            <example>
            <para>一个插件通过在激活器中的参数IBundleContext context来监听事件，以下是事件监听示例。</para>
            <code>
            using System;
            using System.Collections.Generic;
            using System.Text;
            using UIShell.OSGi;
            
            namespace EventListenerBundle
            {
                public class Activator : IBundleActivator
                {
                    public void Start(IBundleContext context)
                    {
                        // 同步监听Bundle状态事件，包括starting和stopping。
                        context.SyncBundleStateChanged += SyncBundleStateChanged;
                    }
            
                    void SyncBundleStateChanged(object sender, BundleStateChangedEventArgs e)
                    {
                        EchoStateChanged("Sync", e);
                    }
            
                    void EchoStateChanged(string type, BundleStateChangedEventArgs e)
                    {
                        Console.WriteLine(string.Format(
                            "'{0}' Event: The bundle '{1}' changed the state from '{2}' to '{3}'.",
                            type, e.Bundle.SymbolicName, e.PreviousStatus, e.CurrentState));
                    }
            
                    public void Stop(IBundleContext context)
                    {
                        // 释放事件监听句柄。
                        context.SyncBundleStateChanged -= SyncBundleStateChanged;
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:UIShell.OSGi.BundleStateChangedEventArgs.#ctor(UIShell.OSGi.BundleState,UIShell.OSGi.BundleState,UIShell.OSGi.IBundle)">
            <summary>
            创建一个BundleStateChangeEventArgs实例
            </summary>
            <param name="previousState"> 前一个状态。</param>
            <param name="currentState">当前状态。</param>
            <param name="bundle">改变状态的Bundle。</param>
        </member>
        <member name="M:UIShell.OSGi.BundleStateChangedEventArgs.ToString">
            <summary>
            返回表示当前 System.Object 的 System.String。
            </summary>
            <returns></returns>
        </member>
        <member name="P:UIShell.OSGi.BundleStateChangedEventArgs.PreviousState">
            <summary>
            前一个状态。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.BundleStateChangedEventArgs.CurrentState">
            <summary>
            当前状态。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.PreBundleStartingEventArgs.CurrentState">
            <summary>
            当前状态。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.PreBundleStartingEventArgs.Cancel">
            <summary>
            是否需要停止启动
            </summary>
        </member>
        <member name="P:UIShell.OSGi.PreBundleStartingEventArgs.CancelReason">
            <summary>
            需要停止启动的原因
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Collection.DisposableLocker">
            <summary>
            Use Monitor.TryEnter to acquire a lock. This would not cause the dead lock.
            </summary>
            <example>
            I will show you how to use DisposableLocker to acquire a lock.
            <code>
            <![CDATA[
            object syncRoot = new object();
            int millisecondsTimeout = 5000;
            List<string> list = new List<string>();
            
            using(new DisposableLocker(syncRoot, millisecondsTimeout))
            {
                if(!list.Contains("some value"))
                {
                    list.Add("some value");
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="P:UIShell.OSGi.Collection.Locker.ContainerLocker`1.Container">
            <summary>
            The real container holding data.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Collection.ThreadSafeCollection`3.CreateLocker">
            <summary>
            Create a proper lock 
            </summary>
            <returns></returns>
        </member>
        <member name="P:UIShell.OSGi.Collection.ThreadSafeCollection`3.Container">
            <summary>
            The items container.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Collection.ThreadSafeDictionary`2">
            <summary>
            线程安全字典包装类。
            </summary>
            <typeparam name="TKey">键的类型。</typeparam>
            <typeparam name="TValue">值的类型。</typeparam>
            <example>
            以下代码用于添加一条字典记录。整个操作是原子操作不允许分割。
            <code>
            <![CDATA[
            var dict = new ThreadSafeDictionary<string, string>();
            
            using(var locker = dict.Lock())
            {
                if(!locker.ContainsKey("some key"))
                {
                    locker.Add("some key", "some value");
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="T:UIShell.OSGi.Collection.ThreadSafeList`1">
            <summary>
            <para>
            线程安全列表。需要注意的是，如果只对List的操作进行加锁的话，这仅是“数据线程安全”。数据线程安全
            在以下的代码中会出现问题。
            </para>
            <code>
            <![CDATA[
            var list = new ThreadSafeList<int>();
            // 获取默认或者第一个元素。
            if(list.Count > 0）
            {
                return list[0];
            }
            ]]>
            </code>
            <para>
            在“return list[0]”这句代码在高并发情况下，有异常产生，因为这是list可能变空了。这是因为在这段
            代码中该语句有一个上下文“list.Count > 0”，虽然对list的数据操作保证了线程安全，但是在这种具有
            上下文的代码，靠“数据线程安全”显然是无法来保证并发程序的正确性。
            </para>
            <para>
            为了解决这个问题，我们需要引入一个全局锁，在执行这种具有上下文的原则操作，必须再次加锁。
            </para>
            <code>
            <![CDATA[
            var list = new ThreadSafeList<int>();
            Monitor.Enter(list.SyncRoot);
            try
            {
                if(list.Count > 0)
                {
                    return list[0];
                }
            }
            finally
            {
                Monitor.Exit(list.SyncRoot);
            }
            ]]>
            </code>
            <para>
            以上这段代码可以简化为如下：
            </para>
            <code>
            <![CDATA[
            var list = new ThreadSafeList<int>();
            using(var locker = list.Lock())
            {
                if(locker.Count > 0)
                {
                    return locker[0];
                }
            }
            //或者如下代码 —— 直接使用list的SyncRoot
            list.Lock(() => 
            {
                if(list.Count > 0)
                {
                    return list[0];
                }
            }
            );
            这段代码又等价于如下代码
            lock(list.SyncRoot)
            {
                if(list.Count > 0)
                {
                    return list[0];
                }
            }
            ]]>
            </code>
            <para>
            不过，并不是对ThreadSafeList都需要采用这样的原子操作锁。比如，你仅仅是添加一个元素，
            则可以直接调用"list.Add(10)"来实现。这是因为这个Add操作不会添加重复元素，不需要做判断。
            </para>
            <para>
            对于ThreadSafeDictionary，添加元素时，则必须使用以下方法。
            </para>
            <code>
            <![CDATA[
            var dict = new ThreadSafeDictionary<string, string>();
            
            using(var locker = dict.Lock())
            {
                if(!dict.ContainsKey("some key"))
                {
                    dict.Add("some key", "some value");
                }
            }
            ]]>
            </code>
            <para>
            需要注意的是，在多线程并发环境下，加锁也意味着可能引起死锁。比如，以下代码将产生死锁。
            这个死锁产生的原因在于：第一个线程获取了list1内部的锁，第二个线程获取了list2内部的锁，
            且在两个线程内部都分别又请求了list2内部的锁和list1内部的锁。因此，编写多线程代码必须
            遵循：（1）尽快释放锁；（2）尽量不在加锁的代码中请求其它锁。
            </para>
            <code>
            <![CDATA[
            
            
            new Thread(
            () =>
            {
                using(var locker = list1.Lock()) // 请求了list1内部的锁
                {
                    list2.Add(10); // 需要请求list2内部的锁
                }
            }
            ).Start();
            
            new Thread(
            () =>
            {
                using (var locker = list2.Lock()) // 请求了list2内部的锁
                {
                    list1.Add(10); // 需要请求list1内部的锁
                }
            }
            ).Start();
            ]]>
            </code>
            </summary>
            <typeparam name="T">列表值的类型。</typeparam>
            <example>
            以下示例展示如何来添加数据、获取数据。
            <code>
            <![CDATA[
            var list = new ThreadSafeList<int>();
            
            // 为了避免2个线程同时执行locker.Add(10)，需要加整个操作的全局锁。
            using(var locker = list.Lock())
            {
                if(!locker.Contains(10))
                {
                    locker.Add(10);
                }
            }
            
            // 获取默认或者第一个元素，此时对集合的这两个操作是一个原子操作，因此需要加全局锁。
            using(var locker = list.Lock())
            {
                if(locker.Count > 0)
                {
                    return locker[0];
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="T:UIShell.OSGi.NDigester.SetPropertiesRule">
            <summary>
            Rule implementation that sets properties on the object at the top of the
            stack, based on attributes with corresponding names.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.NDigester.Rule">
            <summary>
            Concrete implementations of this class implement actions to be taken when
            a corresponding nested pattern of XML elements has been matched.
            </summary>
        </member>
        <member name="F:UIShell.OSGi.NDigester.Rule.digester">
            <summary>The Digester with which this Rule is associated.</summary>
        </member>
        <member name="F:UIShell.OSGi.NDigester.Rule.namespaceURI">
            <summary>The namespace URI for which this Rule is relevant, if any.</summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Rule.#ctor">
            <summary>
            Initialize a new instance of the Rule class.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Rule.#ctor(UIShell.OSGi.NDigester.Digester)">
            <summary>
            Initialize a new instance of the Rule class with the Digester specified.
            </summary>
            <param name="digester">The Digester that is associated with this Rule.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Rule.OnBegin">
            <summary>
            This method is called when the beginning of a matching XML element
            is encountered.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Rule.OnBody">
            <summary>
            This method is called when the body of a matching XML element 
            is encountered.  If the element has no body, this method is
            not called at all.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Rule.OnEnd">
            <summary>
            This method is called when the end of a matching XML element
            is encountered.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Rule.OnFinish">
            <summary>
            This method is called when the parsing process was finished.
            It primary used for disposing resources that was locked by a rule.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.NDigester.Rule.Digester">
            <summary>
            Sets or gets the Digester with which this Rule is associated.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.NDigester.Rule.NamespaceURI">
            <summary>
            Sets and gets the namespace URI for which this Rule is relevant, if any.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.SetPropertiesRule.#ctor">
            <summary>
            Initializes a new instance of the SetPropertiesRule class.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.SetPropertiesRule.OnBegin">
            <summary>
            Process the start of this element.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.SetPropertiesRule.ToString">
            <summary>
            Renders a printable version of this Rule.
            </summary>
            <returns>The string that contains a printable version 
            of this Rule.</returns>
        </member>
        <member name="M:UIShell.OSGi.Configuration.DigesterRule.SetManifestPropertiesRule.ToString">
            <summary>
            Renders a printable version of this Rule.
            </summary>
            <returns>The string that contains a printable version 
            of this Rule.</returns>
        </member>
        <member name="T:UIShell.OSGi.Core.Service.Impl.DefaultBundleSortStrategy">
            <summary>
            在相同的StartLevel集合中按照依赖关系，让被依赖的bundle排序到最前，保证它先启动
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IDefaultBundleSortStrategy.Sort(System.Collections.Generic.List{UIShell.OSGi.Core.Bundle.HostBundle})">
            <summary>
            对已经按照StartLevel排序的bundle进行自定义排序。
            </summary>
            <param name="bundles">已经按照StartLevel从小到大排序的Bundle集合</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.DefaultBundleSortStrategy.Sort(System.Collections.Generic.List{UIShell.OSGi.Core.Bundle.HostBundle})">
            <summary>
            如果bundle有相同的StartLevel，那么在相同的StartLevel集合中按照依赖关系，让被依赖的先启动。
            </summary>
            <param name="bundles">已经按照StartLevel从小到大排序的Bundle集合</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.DefaultBundleSortStrategy.SortBundlesByDependency(System.Collections.Generic.List{UIShell.OSGi.Core.Bundle.HostBundle})">
            <summary>
            按照依赖关系对Bundle进行排序，排序策略如下：
            如果bundle间的关系如下：
            A               D
                -       ->   
                    ->C                 F
            B   -       ->  E
            即：A、B依赖C，C依赖D、E，F不依赖任何Bundle，那么，排序算法如下：
            1，建立一个临时表temp
            2，先把独立的Bundle（不依赖具有相同启动级别的bundle） D、E、F移到temp，此时剩下bundle关系如下：
             A          
                 -      
                     ->C
             B   -      
            3，重复步骤2，直到所有的bundle都移到temp
            4，temp就是排序的结果，返回。
             </summary>
            <param name="bundles"></param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.DefaultBundleSortStrategy.HasDependentBundleInCollection(UIShell.OSGi.Core.Bundle.HostBundle,System.Collections.Generic.List{UIShell.OSGi.Core.Bundle.HostBundle})">
            <summary>
            检查bundle是否有依赖的Bundle在bundlesToCheck中
            </summary>
            <param name="bundle">要检查的Bundle</param>
            <param name="bundlesToCheck"></param>
        </member>
        <member name="T:UIShell.OSGi.Core.Service.LicenseService">
            <summary>
            License 服务，用来检查Bundle license。
            </summary>
            <remarks>
            <para>许可证策略描述如下：</para>
            <para>1 如果当前有效License是AppStoreRuntime（AppStoreRuntime的License位置在AppDomain.CurrentDomain.BaseDirectory），则要求：A）当前Framework的License必须有效；B）当前必须至少有一个Bundle的License有效；C）在Bundle启动时，会验证License是否有效。</para>
            <para>2 如果当前有效License是AppStoreSDK或者UIOSP（位置在[CommonAppDataFolder]/XAUI/License文件夹下），如果有效，则启动成功，而且不再验证Bundle的License了。</para>
            
            <para>如果同时安装了AppStoreSDK和AppStoreRuntime，则先搜索AppDomain.CurrentDomain.BaseDirectory，判断是否为AppStoreRuntime。若在当前应用域根目录没有License文件，则为AppStoreSDK的License，AppStoreSDK的许可证是每年获取许可一次。</para>
            
            <para>License将按照以下方式探测获取：</para>
            <para>1 从可执行文件夹中获取license.lic文件，如果获取成功，则正确，否则尝试下面步骤。</para>
            <para>2 [CommonAppDataFolder]/XAUI/License这个文件夹依次搜索许可证，如果没有找到，则抛出异常。</para>
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.LicenseService.UpdateLicense(System.String,System.Byte[])">
            <summary>
            更新指定路径下Bundle的license文件
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.LicenseService.EnsureHasAvailableBundleLicense">
            <summary>
            1, 对于开发者，需要给Framework单独颁发一个license，不用检查bundle license
            2，对于消费者，只要有一个合法license的bundle，就允许Framework运行，但需要检查每个bundle license
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.LicenseService.TryGetLicense(System.String)">
            <summary>
            尝试读取指定路径下的Bundle的license
            </summary>
            <param name="bundlePath"></param>
            <returns></returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.LicenseService.GetLicenseStatus(UIShell.OSGi.Configuration.BundleManifest.BundleData)">
            <summary>
            检查一个Bundle 证书状态
            </summary>
            <returns>
            License状态。
            </returns>
        </member>
        <member name="P:UIShell.OSGi.Core.Service.LicenseService.RequireBundleLicenseValidation">
            <summary>
            This is for HostBundle usage.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.ExtensionHandlerBase`1">
            <summary>
            扩展处理基类。这是一个抽象类，你需要来实现扩展XML节点到扩展对象转换逻辑和忽略重复定义的逻辑。
            </summary>
            <typeparam name="T">扩展XML节点对应的数据对象类型。</typeparam>
        </member>
        <member name="M:UIShell.OSGi.ExtensionHandlerBase`1.GetFirstOrDefaultExtensionData(UIShell.OSGi.IBundle)">
            <summary>
            获取指定插件默认的扩展对象。
            </summary>
            <param name="bundleContext">提供扩展的插件。</param>
            <returns>扩展对象。</returns>
        </member>
        <member name="M:UIShell.OSGi.ExtensionHandlerBase`1.GetExtensionDatas(UIShell.OSGi.IBundle)">
            <summary>
            获取指定插件提供的所有扩展对象。
            </summary>
            <param name="bundle">提供扩展的插进。</param>
            <returns>扩展对象列表。</returns>
        </member>
        <member name="M:UIShell.OSGi.ExtensionHandlerBase`1.#ctor(UIShell.OSGi.IBundleContext,System.String)">
            <summary>
            创建扩展处理基类。
            </summary>
            <param name="bundleContext">实现扩展处理所在的插件的上下文。</param>
            <param name="extensionPoint">扩展点名称。</param>
        </member>
        <member name="M:UIShell.OSGi.ExtensionHandlerBase`1.Dispose">
            <summary>
            清理所有的资源。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.FrameworkOptions">
            <summary>
            内核选项。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.FrameworkOptions.BaseDirectory">
            <summary>
            根目录。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.FrameworkOptions.PluginsDirectoryName">
            <summary>
            默认插件存放的文件夹的名称，即“Plugins”。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.FrameworkOptions.PluginsDirectoryList">
            <summary>
            初始化Framework时，逻辑目录中指定的Plugins中的Bundle要拷贝到Workspace下，
            这个属性指定了要拷贝到Workspace下的文件夹的名称。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.FrameworkOptions.BundlePersistentFileName">
            <summary>
            单个Bundle的持久存储的文件名称，保存Bundle私有数据，如上次退出系统时的BundleState。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.FrameworkOptions.GlobalPersistentFile">
            <summary>
            全局持久存储，在根目录下。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.FrameworkOptions.DefaultBundleState">
            <summary>
            Bundle默认状态。如果一个Bundle的Manifest.xml没有指定InitializedState，则框架将使用默认状态
            来操作该Bundle。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Command.ICommandRepository.Run(System.String)">
            <returns>
            Indicate whether this cmd be excuted or not.
            </returns>
        </member>
        <member name="T:UIShell.OSGi.Core.Service.IServiceManager">
            <summary>
            服务管理服务。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IServiceManager.AddService(UIShell.OSGi.IBundle,System.Type,System.Object[])">
            <summary>
            为一个服务契约注册多个服务实例。
            </summary>
            <param name="owner">服务实现所在的模块。</param>
            <param name="serviceType">服务契约。</param>
            <param name="serviceInstances">服务实例列表。</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IServiceManager.AddService``1(UIShell.OSGi.IBundle,System.Object[])">
            <summary>
            为一个服务契约注册多个服务实例。
            </summary>
            <typeparam name="T">服务契约。</typeparam>
            <param name="owner">服务实现所在的模块。</param>
            <param name="serviceInstances">服务实例列表。</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IServiceManager.AddService(UIShell.OSGi.IBundle,System.Object,System.Type[])">
            <summary>
            注册一个服务实例，该服务实现了多个契约。
            </summary>
            <param name="owner">服务实现所在的模块。</param>
            <param name="serviceInstance">服务实例。</param>
            <param name="serviceTypes">服务契约列表。</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IServiceManager.RemoveService(UIShell.OSGi.IBundle,System.Type,System.Object)">
            <summary>
            删除一个服务实例。
            </summary>
            <param name="owner">注册服务实例的模块。</param>
            <param name="serviceType">服务契约。</param>
            <param name="serviceInstance">服务实例。</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IServiceManager.RemoveService``1(UIShell.OSGi.IBundle,System.Object)">
            <summary>
            删除一个服务实例。
            </summary>
            <typeparam name="T">服务契约。</typeparam>
            <param name="owner">注册服务实例的模块。</param>
            <param name="serviceInstance">服务实例。</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IServiceManager.RemoveService(UIShell.OSGi.IBundle,System.Object)">
            <summary>
            删除指定服务实例的所有注册。
            </summary>
            <param name="owner">注册服务实例的模块。</param>
            <param name="serviceInstance">服务实例。</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IServiceManager.GetFirstOrDefaultService``1">
            <summary>
            获取一个服务契约的默认实例。
            </summary>
            <typeparam name="T">服务契约。</typeparam>
            <returns>服务实例。</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IServiceManager.GetFirstOrDefaultService(System.Type)">
            <summary>
            获取一个服务契约的默认实例。
            </summary>
            <param name="serviceType">服务契约。</param>
            <returns>服务实例。</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IServiceManager.GetFirstOrDefaultService(System.String)">
            <summary>
            获取一个服务契约的默认实例。
            </summary>
            <param name="serviceTypeName">服务契约名称。</param>
            <returns>服务实例。</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IServiceManager.GetService(System.String)">
            <summary>
            获取指定服务契约的所有实例。
            </summary>
            <param name="serviceTypeName">服务契约类型名称。</param>
            <returns>服务实例列表。</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IServiceManager.GetService``1">
            <summary>
            获取指定服务契约的所有实例。
            </summary>
            <typeparam name="T">服务契约。</typeparam>
            <returns>服务实例列表。</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IServiceManager.GetService(System.Type)">
            <summary>
            获取指定服务契约的所有实例。
            </summary>
            <param name="serviceType">服务契约。</param>
            <returns>服务实例列表。</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IServiceManager.GetServices">
            <summary>
            获取所有服务。
            </summary>
            <returns>服务列表。</returns>
        </member>
        <member name="T:UIShell.OSGi.Logging.Log">
            <summary>
            Log is where messages are written from Loggers.
            </summary>
            <remarks>
            All Log implementations should be usuable from multiple threads.
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.Log.#ctor">
            <summary>
            Initializes a new instance of the Log class
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Logging.Log.WriteLine(System.String,UIShell.OSGi.Logging.LogLevel)">
            <summary>
            Writes the <paramref name="message"/> to some destination.
            </summary>
            <param name="message">The message to write</param>
            <param name="level">The <see cref="T:UIShell.OSGi.Logging.LogLevel"/> of the message.</param>
            <remarks>
            <para>
            See derivatives for specific details on log destination and
            configuration.
            </para>
            <para>
            Derivatives can use the <paramref name="level"/> as a hint of the
            importance of the message.
            </para>
            </remarks>
        </member>
        <member name="P:UIShell.OSGi.Logging.Log.IsLogging">
            <summary>
            Gets or sets a value indicating whether or not this Log should write messages.
            </summary>
        </member>
        <member name="T:OpenLicense.AssemblyOpenLicenseHelperAttribute">
            <summary>
            This is an assembly attribute to be used to defined the product and 
            company information.  This information will be used when an exception
            is thrown because a valid license couldn't be found.  It may also be 
            used by a developer to access their information to display in a 
            product's about page. 
            </summary>
            <example>
            c#
            <code>
            &#91;assembly: OpenLicense.AssemblyOpenLicenseHelper("Open License", "SP extreme")&#93;
            </code>
            vb#
            <code>
            &lt;assembly: OpenLicense.AssemblyOpenLicenseHelper("Open License", "SP extreme")&gt;
            </code>
            </example>
        </member>
        <member name="M:OpenLicense.AssemblyOpenLicenseHelperAttribute.#ctor">
            <summary>
            The constructor for an empty <c>AssemblyOpenLicenseHelperAttribute</c>.
            </summary>
        </member>
        <member name="M:OpenLicense.AssemblyOpenLicenseHelperAttribute.#ctor(System.String)">
            <summary>
            The constructor for an <c>AssemblyOpenLicenseHelperAttribute</c>.
            </summary>
            <param name="product">
            The name of the product this licensing scheme is for.
            </param>
        </member>
        <member name="M:OpenLicense.AssemblyOpenLicenseHelperAttribute.#ctor(System.String,System.String)">
            <summary>
            The constructor for an <c>AssemblyOpenLicenseHelperAttribute</c>.
            </summary>
            <param name="product">
            The name of the product this licensing scheme is for.
            </param>
            <param name="company">
            The name of the company who developed this product.
            </param>
        </member>
        <member name="M:OpenLicense.AssemblyOpenLicenseHelperAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            The constructor for an <c>AssemblyOpenLicenseHelperAttribute</c>.
            </summary>
            <param name="product">
            The name of the product this licensing scheme is for.
            </param>
            <param name="company">
            The name of the company who developed this product.
            </param>
            <param name="url">
            The URL of the company.
            </param>
        </member>
        <member name="M:OpenLicense.AssemblyOpenLicenseHelperAttribute.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            The constructor for an <c>AssemblyOpenLicenseHelperAttribute</c>.
            </summary>
            <param name="product">
            The name of the product this licensing scheme is for.
            </param>
            <param name="company">
            The name of the company who developed this product.
            </param>
            <param name="url">
            The URL of the company.
            </param>
            <param name="email">
            An email address to contact the company. Generally this is a support email address.
            </param>
        </member>
        <member name="M:OpenLicense.AssemblyOpenLicenseHelperAttribute.#ctor(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            The constructor for an <c>AssemblyOpenLicenseHelperAttribute</c>.
            </summary>
            <param name="product">
            The name of the product this licensing scheme is for.
            </param>
            <param name="company">
            The name of the company who developed this product.
            </param>
            <param name="url">
            The URL of the company.
            </param>
            <param name="email">
            An email address to contact the company. Generally this is a support email address.
            </param>
            <param name="phone">
            A phone number to contact the company. Generally this is a support phone number.
            </param>
        </member>
        <member name="P:OpenLicense.AssemblyOpenLicenseHelperAttribute.Product">
            <summary>
            Gets or Sets the name of the product this licensing scheme is for.
            </summary>
            <param>
            Sets the name of the product this licensing scheme is for.
            </param>
            <returns>
            Gets the name of the product this licensing scheme is for.
            </returns>
        </member>
        <member name="P:OpenLicense.AssemblyOpenLicenseHelperAttribute.Company">
            <summary>
            Gets or Sets the name of the company who developed this product.
            </summary>
            <param>
            Sets the name of the company who developed this product.
            </param>
            <returns>
            Gets the name of the company who developed this product.
            </returns>
        </member>
        <member name="P:OpenLicense.AssemblyOpenLicenseHelperAttribute.Url">
            <summary>
            Gets or Sets the URL of the company's web address who developed this product.
            </summary>
            <param>
            Sets the URL of the company's web address who developed this product.
            </param>
            <returns>
            Gets the URL of the company's web address who developed this product.
            </returns>
        </member>
        <member name="P:OpenLicense.AssemblyOpenLicenseHelperAttribute.Email">
            <summary>
            Gets or Sets an email address to contact the company. Generally this is a support email address.
            </summary>
            <param>
            Gets an email address to contact the company.
            </param>
            <returns>
            Gets an email address to contact the company.
            </returns>
        </member>
        <member name="P:OpenLicense.AssemblyOpenLicenseHelperAttribute.Phone">
            <summary>
            Gets or Sets phone number to contact the company. Generally this is a support phone number.
            </summary>
            <param>
            Sets phone number to contact the company. 
            </param>
            <returns>
            Gets phone number to contact the company.
            </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.AbstractConstraint">
            <summary>
            <p><c>AbstractConstraint</c> is an abstract class which all licensing
            constraints are built from.  The <c>AbstractConstraint</c> defines
            the necessary items for a Constraint to be used by
            the <see cref="T:OpenLicense.OpenLicenseProvider">OpenLicenseProvider</see>.  The
            provider then uses the constraints <c>Validate</c> function to
            enforce the Constraint.</p>
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.IConstraint">IConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
            <seealso cref="T:OpenLicense.OpenLicenseProvider">OpenLicenseProvider</seealso>
            <seealso cref="T:System.String">String</seealso>
            <seealso cref="T:System.Xml.XmlDocument">XmlDocument</seealso>
            <seealso cref="T:System.Xml.XmlNode">XmlNode</seealso>
        </member>
        <member name="T:OpenLicense.LicenseFile.AbstractLicenseData">
            <summary>
            <p><c>AbstractLicenseData</c> is an abstract class which all licensing
            data, other then Constraints) must inherit.  The <c>AbstractLicenseData</c>
            defines the necessary items for any license data to be used by
            the <see cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</see>.</p>
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.ILicenseData">ILicenseData</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
            <seealso cref="T:System.String">String</seealso>
            <seealso cref="T:System.Xml.XmlDocument">XmlDocument</seealso>
            <seealso cref="T:System.Xml.XmlNode">XmlNode</seealso>
        </member>
        <member name="T:OpenLicense.LicenseFile.ILicenseData">
            <summary>
            <p><c>ILicenseData</c> is an interface class which all licensing
            data, other then Constraints) must inherit.  The <c>ILicenseData</c>
            defines the necessary items for any license data to be used by
            the <see cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</see>.</p>
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
            <seealso cref="T:System.String">String</seealso>
            <seealso cref="T:System.Xml.XmlDocument">XmlDocument</seealso>
            <seealso cref="T:System.Xml.XmlNode">XmlNode</seealso>
        </member>
        <member name="M:OpenLicense.LicenseFile.ILicenseData.ToXmlString">
            <summary>
            Converts this instance of License Data to a <see cref="T:System.String">String</see>
            representing the Xml of the specific License Data object.
            </summary>
            <return>
            The <c>String</c> representing this License Data.
            </return>
        </member>
        <member name="M:OpenLicense.LicenseFile.ILicenseData.Saved">
            <summary>
            Resets the IsDirty flag to know this item has been saved.
            </summary>
        </member>
        <member name="P:OpenLicense.LicenseFile.ILicenseData.IsDirty">
            <summary>
            Gets if the license data has changed since the last save.
            </summary>
            <returns>
            Gets if the license data has changed since the last save.
            </returns>
        </member>
        <member name="F:OpenLicense.LicenseFile.AbstractLicenseData.isDirty">
            <summary>
            Used to denote if this object has changed and hasn't yet been saved.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.AbstractLicenseData.ToXmlString">
            <summary>
            Converts this instance of License Data to a
            <see cref="T:System.String">String</see> representing the XML
            of the specific License Data object.
            </summary>
            <return>
            The <c>String</c> representing this License Data.
            </return>
        </member>
        <member name="M:OpenLicense.LicenseFile.AbstractLicenseData.Saved">
            <summary>
            Resets the is dirty flag to know this item has been saved.
            </summary>
        </member>
        <member name="P:OpenLicense.LicenseFile.AbstractLicenseData.IsDirty">
            <summary>
            Gets if this object has changed since the last save.
            </summary>
            <returns>
            Gets if this object has changed since the last save.
            </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.IConstraint">
            <summary>
            <p><c>IConstraint</c> is an interface class which all Constraints must inherit.  The
            <c>IConstraint</c> defines the necessary items for a Constraint to be used by the
            <see cref="T:OpenLicense.OpenLicenseProvider">OpenLicenseProvider</see>.  The provider then uses
            the Constraint's Validate( ) function to enforce the Constraint.</p>
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
            <seealso cref="T:OpenLicense.OpenLicenseProvider">OpenLicenseProvider</seealso>
            <seealso cref="T:System.String">String</seealso>
            <seealso cref="T:System.Xml.XmlDocument">XmlDocument</seealso>
            <seealso cref="T:System.Xml.XmlNode">XmlNode</seealso>
        </member>
        <member name="M:OpenLicense.LicenseFile.IConstraint.Validate">
            <summary>
            Defines the validation method of this Constraint.  This is the method the
            Constraint uses to accept or reject a license request.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.IConstraint.FromXml(System.String)">
            <summary>
            This is used to create a Constraint from a <see cref="T:System.String">String</see>
            representing the Xml data of a Constraints node in the <see cref="T:OpenLicense.LicenseFile.OpenLicenseFile"/>.
            </summary>
            <param name="xmlData">
            A <c>String</c> representing the XML data for this Constraint.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.IConstraint.FromXml(System.Xml.XmlNode)">
            <summary>
            This loads the XML data for a Constraint from an <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            The <c>XmlNode</c> is the piece of the <see cref="T:System.Xml.XmlDocument">XmlDocument</see>
            that is contained within the Constraint block of the <c>XmlDocument</c>.
            </summary>
            <param name="xmlData">
            A <c>XmlNode</c> representing the Constraint of the <c>XmlDocument</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.IConstraint.Dispose">
            <summary>
            Destroys this instance of the Constraint.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.IConstraint.ToXmlString">
            <summary>
            Converts this instance of the Constraint to a <see cref="T:System.String">String</see>
            representing the Xml of the Constraint object.
            </summary>
            <return>
            The <c>String</c> representing this Constraint.
            </return>
        </member>
        <member name="M:OpenLicense.LicenseFile.IConstraint.Saved">
            <summary>
            Resets the is dirty flag.
            </summary>
        </member>
        <member name="P:OpenLicense.LicenseFile.IConstraint.License">
            <summary>
            Gets or Sets the <see cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</see> this Constraint belongs to.
            </summary>
            <param>
            Sets the <c>OpenLicenseFile</c> this Constraint belongs to.
            </param>
            <returns>
            Gets the <c>OpenLicenseFile</c> this Constraint belongs to.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.IConstraint.Name">
            <summary>
            Gets or Sets the name of this Constraint.
            </summary>
            <param>
            Sets the name of this Constraint.
            </param>
            <returns>
            Gets the name of this Constraint.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.IConstraint.Description">
            <summary>
            Gets or Sets the description of this Constraint.
            </summary>
            <param>
            Sets the description of this Constraint.
            </param>
            <returns>
            Gets the description of this Constraint.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.IConstraint.IsDirty">
            <summary>
            Gets if this Constraint has changed since the last save.
            </summary>
            <returns>
            Gets if this Constraint has changed since the last save.
            </returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.AbstractConstraint.Validate">
            <summary>
            Defines the validation method of this Constraint.  This
            is the method the Constraint uses to accept or reject a
            license request.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.AbstractConstraint.FromXml(System.String)">
            <summary>
            This is used to create the Constraint from a
            <see cref="T:System.String">String</see> representing the Xml data
            of a constraint node.
            </summary>
            <param name="xmlData">
            A <c>String</c> representing the XML data for this Constraint.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.AbstractConstraint.FromXml(System.Xml.XmlNode)">
            <summary>
            This loads the XML data for the Constraint from an
            <see cref="T:System.Xml.XmlNode">XmlNode</see>.  The <c>XmlNode</c>
            is the piece of the <see cref="T:System.Xml.XmlDocument">XmlDocument</see>
            that is contained within the constraint block of the
            <c>XmlDocument</c>.
            </summary>
            <param name="xmlData">
            A <c>XmlNode</c> representing the constraint
            of the <c>XmlDocument</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.AbstractConstraint.Dispose">
            <summary>
            Destroys this instance of the Constraint.
            </summary>
        </member>
        <member name="P:OpenLicense.LicenseFile.AbstractConstraint.License">
            <summary>
            Gets or Sets <see cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</see> this constraint belongs to.
            </summary>
            <param>
            Sets the <c>OpenLicenseFile</c> this constraint belongs to.
            </param>
            <returns>
            Gets the <c>OpenLicenseFile</c> this constraint belongs to.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.AbstractConstraint.Name">
            <summary>
            Gets or Sets the name of this constraint.
            </summary>
            <param>
            Sets the name of this constraint.
            </param>
            <returns>
            Gets the name of this constraint.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.AbstractConstraint.Description">
            <summary>
            Gets or Sets the description of this constraint.
            </summary>
            <param>
            Sets the description of this constraint.
            </param>
            <returns>
            Gets the description of this constraint.
            </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.AbstractContainerConstraint">
            <summary>
            <p>This <see cref="T:OpenLicense.LicenseFile.AbstractContainerConstraint">AbstractContainerConstraint</see> 
            is used to define a container for other constraints.  This is used to provide
            a method to create grouping of constraints to provide bitwise operations.</p>
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.AbstractConstraint">AbstractConstraint</seealso>
        </member>
        <member name="P:OpenLicense.LicenseFile.AbstractContainerConstraint.Items">
            <summary>
            Gets or Sets the <c>ConstraintCollection</c> for this ContainerConstraint.
            </summary>
            <param>
            Sets the <c>ConstraintCollection</c> for this ContainerConstraint.
            </param>
            <returns>
            Gets the <c>ConstraintCollection</c> for this ContainerConstraint.
            </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.Constraints.AndConstraint">
            <summary>
            <p>This <see cref="T:OpenLicense.LicenseFile.Constraints.AndConstraint"/> contains a collection of constraints that 
            will be grouped together as a bitwise AND operation.  It is responsible for 
            validating the containing <c>IConstraints</c> and will be valid as long as 
            all the constraints contained are valid.  The purpose of this is to allow 
            a user to force multiple constraints to pass before allowing the license 
            to be valid.</p>
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.AbstractConstraint">AbstractConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.IConstraint">IConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.AndConstraint.#ctor">
            <summary>
            This is the constructor for the <c>AndConstraint</c>.  The constructor
            is used to create the object without a valid license attached it to.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.AndConstraint.#ctor(OpenLicense.LicenseFile.OpenLicenseFile)">
            <summary>
            This is the constructor for the <c>AndConstraint</c>.  The constructor
            is used to create the object and assign it to the proper license.
            </summary>
            <param name="license">
            The <see cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</see> this constraint
            belongs to.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.AndConstraint.Validate">
            <summary>
            This verifies the license meets its desired validation criteria.  This test will 
            pass providing all contained constraints are valid. If any one of them is invalid then 
            the validate will fail and the license failure reason will be set to the first 
            constraint which failed while being validated.
            </summary>
            <returns>
            <c>True</c> if the license meets the validation criteria.  Otherwise
            <c>False</c>.
            </returns>
            <remarks>
            When a failure occurs the FailureReason will be set to the details of the
            failure for the last constraint which failed.
            </remarks>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.AndConstraint.FromXml(System.String)">
            <summary>
            This is responsible for parsing a <see cref="T:System.String">String</see>
            to form the <c>AndConstriant</c>.
            </summary>
            <param name="xmlData">
            The Xml data in the form of a <c>String</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.AndConstraint.FromXml(System.Xml.XmlNode)">
            <summary>
            This creates an <c>AndConstraint</c> from an <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </summary>
            <param name="itemsNode">
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the <c>AndConstraint</c>.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the <see cref="T:System.Xml.XmlNode">XmlNode</see> is null.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.AndConstraint.parseConstraintsFields(System.Xml.XmlNode)">
            <summary>
            Parse the XML content of the constraints group/fields section of the license.
            </summary>
            <param name="itemsNode">
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the
            Constraints List (System.Collections.Generic.List) section of the
            license.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.AndConstraint.ToXmlString">
            <summary>
            Converts this <c>AndConstraint</c> to an Xml <c>String</c>.
            </summary>
            <returns>
            A <c>String</c> representing the IConstraint as Xml data.
            </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.Constraints.BetaConstraint">
            <summary>
            <p>This <see cref="T:OpenLicense.LicenseFile.Constraints.BetaConstraint"/> constrains the user
            to a given time period.  It supports an end date that the license will expire.
            It also has the ability to show the user a link to download an update to the
            beta once it expires.</p>
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.AbstractConstraint">AbstractConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.IConstraint">IConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.BetaConstraint.#ctor">
            <summary>
            This is the constructor for the <c>BetaConstraint</c>.  The constructor
            is used to create the object with a valid license to attach it to.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.BetaConstraint.#ctor(OpenLicense.LicenseFile.OpenLicenseFile)">
            <summary>
            This is the constructor for the <c>BetaConstraint</c>.  The constructor
            is used to create the object and assign it to the proper license.
            </summary>
            <param name="license">
            The <see cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</see> this constraint
            belongs to.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.BetaConstraint.Validate">
            <summary>
            <p>This verifies the license meets its desired validation criteria.  This includes
            validating that the license is before the defined end date.  If it is not then
            the license validation will return false and the failure reason will be set.</p>
            </summary>
            <returns>
            <c>True</c> if the license meets the validation criteria.  Otherwise
            <c>False</c>.
            </returns>
            <remarks>
            When a failure occurs the FailureReason will be set to: "The beta period has
            expired. You may get an update at: xxx"  The section "You may get an update
            at: xxx" will only be displayed if UpdateUrl has been assinged a value.
            </remarks>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.BetaConstraint.FromXml(System.String)">
            <summary>
            This is responsible for parsing a <see cref="T:System.String">String</see>
            to form the <c>BetaConstriant</c>.
            </summary>
            <param name="xmlData">
            The Xml data in the form of a <c>String</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.BetaConstraint.FromXml(System.Xml.XmlNode)">
            <summary>
            This creates a <c>BetaConstraint</c> from an <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </summary>
            <param name="itemsNode">
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the <c>BetaConstraint</c>.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the <see cref="T:System.Xml.XmlNode">XmlNode</see> is null.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.BetaConstraint.ToXmlString">
            <summary>
            Converts this <c>BetaConstraint</c> to an Xml <c>String</c>.
            </summary>
            <returns>
            A <c>String</c> representing the BetaConstraint as Xml data.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.BetaConstraint.EndDate">
            <summary>
            Gets or Sets the end date/time for this <see cref="T:OpenLicense.LicenseFile.Constraints.BetaConstraint">BetaConstraint</see>.
            </summary>
            <param>
            Sets the end date/time for this <see cref="T:OpenLicense.LicenseFile.Constraints.BetaConstraint">BetaConstraint</see>.
            </param>
            <returns>
            Gets the end date/time for this <see cref="T:OpenLicense.LicenseFile.Constraints.BetaConstraint">BetaConstraint</see>.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.BetaConstraint.UpdateURL">
            <summary>
            Gets or Sets the URL, as a <see cref="T:System.String">String</see>, which
            points to where an update can be obtained.
            </summary>
            <param>
            Sets the URL, as a <see cref="T:System.String">String</see>, which
            points to where an update can be obtained.
            </param>
            <returns>
            Gets the URL, as a <see cref="T:System.String">String</see>, which
            points to where an update can be obtained.
            </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.Constraints.DayTimeConstraint">
            <summary>
            <p>The <see cref="T:OpenLicense.LicenseFile.Constraints.DayTimeConstraint">DayTimeConstraint</see> constrains the user
            to only using this license during a period of time within a day.  I.E. A user may
            use the license between midnight and 7am and 5pm and midnight - Non business hours.
            </p>
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.AbstractConstraint">AbstractConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.IConstraint">IConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
        </member>
        <member name="F:OpenLicense.LicenseFile.Constraints.DayTimeConstraint.timeRange">
            <summary>
            The time range values collection.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DayTimeConstraint.#ctor">
            <summary>
            This is the constructor for the <c>DayTimeConstraint</c>.  The constructor
            is used to create the object with a valid license to attach it to.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DayTimeConstraint.#ctor(OpenLicense.LicenseFile.OpenLicenseFile)">
            <summary>
            This is the constructor for the <c>DayTimeConstraint</c>.  The constructor
            is used to create the object and assign it to the proper license.
            </summary>
            <param name="license">
            The <see cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</see> this constraint
            belongs to.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DayTimeConstraint.Validate">
            <summary>
            This verifies the license is allowed to be used during the current time range.
            </summary>
            <returns>
            <c>True</c> if the license meets the validation criteria.  Otherwise
            <c>False</c>.
            </returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DayTimeConstraint.FromXml(System.String)">
            <summary>
            This is responsible for parsing a <see cref="T:System.String">String</see>
            to form the <c>DayTimeConstriant</c>.
            </summary>
            <param name="xmlData">
            The Xml data in the form of a <c>String</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DayTimeConstraint.FromXml(System.Xml.XmlNode)">
            <summary>
            This creates a <c>DayTimeConstraint</c> from an <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </summary>
            <param name="itemsNode">
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the <c>DayTimeConstraint</c>.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the <see cref="T:System.Xml.XmlNode">XmlNode</see> is null.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DayTimeConstraint.ToXmlString">
            <summary>
            Converts this <c>DayTimeConstraint</c> to an Xml <c>String</c>.
            </summary>
            <returns>
            A <c>String</c> representing the DayTimeConstraint as Xml data.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.DayTimeConstraint.Items">
            <summary>
            Gets or Sets the time range to be used for this constraint.
            </summary>
            <param>
            Sets the time range to be used for this constraint.
            </param>
            <returns>
            Gets the time range to be used for this constraint.
            </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.Constraints.Time">
            <summary>
            <p>The Time object is a rough implementation of military time to be used as the
            time range.  This will eventually change but for now it serves the purpose of
            defining a time range using 0 to 2400.  This class also has the ability to convert
            the current DateTime.Now to a Time object value.</p>
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.Time.Now">
            <summary>
            A static method to return the current Time.  This uses the DateTime.Now call
            and then converts it to a Time object.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.Time.#ctor">
            <summary>
            This will create a Time object with no time value being set
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.Time.#ctor(System.Int32)">
            <summary>
            This will create a time value with the passed in time value.
            </summary>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.Time.MilitaryTime">
            <summary>
            Gets or Sets the current Military time value.  Military time is in the range of 0 to 2400.
            </summary>
            <param>
            Sets the current Military time value.
            </param>
            <returns>
            Gets the current Military time value.
            </returns>
            <exception cref="T:System.ApplicationException">
            This will throw an exception if the time value is out of range (0 to 2400).
            </exception>
        </member>
        <member name="T:OpenLicense.LicenseFile.Constraints.TimeRange">
            <summary>
            This is a range of Time values to provide a start/end time.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.TimeRange.#ctor">
            <summary>
            Initialized a Time Range with a start time of 0 and an end time of 2400.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.TimeRange.#ctor(OpenLicense.LicenseFile.Constraints.Time)">
            <summary>
            Initialized a Time Range with a given start time and an end time of 2400.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.TimeRange.#ctor(OpenLicense.LicenseFile.Constraints.Time,OpenLicense.LicenseFile.Constraints.Time)">
            <summary>
            Initialized a Time Range with a the given start and stop time.
            </summary>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.TimeRange.Start">
            <summary>
            Gets or Sets the Start Time value of this range.
            </summary>
            <param>
            Sets the Start Time value of this range.
            </param>
            <returns>
            Gets the Start Time value of this range.
            </returns>
            <exception cref="T:System.ApplicationException">
            This will throw an exception if the start time is greater then or equal to the end time.
            </exception>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.TimeRange.End">
            <summary>
            Gets or Sets the End Time value of this range.
            </summary>
            <param>
            Sets the End Time value of this range.
            </param>
            <returns>
            Gets the End Time value of this range.
            </returns>
            <exception cref="T:System.ApplicationException">
            This will throw an exception if the end time is less then or equal to the start time.
            </exception>
        </member>
        <member name="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection">
            <summary>
              A collection that stores <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/> objects.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/>.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.#ctor(OpenLicense.LicenseFile.Constraints.TimeRangeCollection)">
            <summary>
              Initializes a new instance of <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/> based on another <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/>.
            </summary>
            <param name="val">
              A <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/> from which the contents are copied
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.#ctor(OpenLicense.LicenseFile.Constraints.TimeRange[])">
            <summary>
              Initializes a new instance of <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/> containing any array of <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/> objects.
            </summary>
            <param name="val">
                  A array of <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/> objects with which to initialize the collection
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.Add(OpenLicense.LicenseFile.Constraints.TimeRange)">
            <summary>
              Adds a <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/> with the specified value to the
              <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/>.
            </summary>
            <param name="val">The <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/> to add.</param>
            <returns>The index at which the new element was inserted.</returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.AddRange(OpenLicense.LicenseFile.Constraints.TimeRange[])">
            <summary>
              Copies the elements of an array to the end of the <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/>.
            </summary>
            <param name="val">
               An array of type <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/> containing the objects to add to the collection.
            </param>
            <seealso cref="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.Add(OpenLicense.LicenseFile.Constraints.TimeRange)"/>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.AddRange(OpenLicense.LicenseFile.Constraints.TimeRangeCollection)">
            <summary>
              Adds the contents of another <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/> to the end of the collection.
            </summary>
            <param name="val">
               A <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/> containing the objects to add to the collection.
            </param>
            <seealso cref="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.Add(OpenLicense.LicenseFile.Constraints.TimeRange)"/>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.Contains(OpenLicense.LicenseFile.Constraints.TimeRange)">
            <summary>
              Gets a value indicating whether the
               <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/> contains the specified <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/>.
            </summary>
            <param name="val">The <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/> to locate.</param>
            <returns>
            <see langword="true"/> if the <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/> is contained in the collection;
              otherwise, <see langword="false"/>.
            </returns>
            <seealso cref="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.IndexOf(OpenLicense.LicenseFile.Constraints.TimeRange)"/>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.CopyTo(OpenLicense.LicenseFile.Constraints.TimeRange[],System.Int32)">
            <summary>
              Copies the <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/> values to a one-dimensional <see cref="T:System.Array"/> instance at the
               specified index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the values copied from <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/>.</param>
            <param name="index">The index in <paramref name="array"/> where copying begins.</param>
            <exception cref="T:System.ArgumentException">
              <para><paramref name="array"/> is multidimensional.</para>
              <para>-or-</para>
              <para>The number of elements in the <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/> is greater than
                    the available space between <paramref name="index"/> and the end of
                    <paramref name="array"/>.</para>
            </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is <see langword="null"/>. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than <paramref name="array"/>'s lowbound. </exception>
            <seealso cref="T:System.Array"/>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.IndexOf(OpenLicense.LicenseFile.Constraints.TimeRange)">
            <summary>
               Returns the index of a <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/> in
                  the <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/>.
            </summary>
            <param name="val">The <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/> to locate.</param>
            <returns>
              The index of the <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/> of <paramref name="val"/> in the
              <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/>, if found; otherwise, -1.
            </returns>
            <seealso cref="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.Contains(OpenLicense.LicenseFile.Constraints.TimeRange)"/>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.Insert(System.Int32,OpenLicense.LicenseFile.Constraints.TimeRange)">
            <summary>
              Inserts a <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/> into the <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/> at the specified index.
            </summary>
            <param name="index">The zero-based index where <paramref name="val"/> should be inserted.</param>
            <param name="val">The <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/> to insert.</param>
            <seealso cref="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.Add(OpenLicense.LicenseFile.Constraints.TimeRange)"/>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.GetEnumerator">
            <summary>
             Returns an enumerator that can iterate through the <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/>.
            </summary>
            <seealso cref="T:System.Collections.IEnumerator"/>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.Remove(OpenLicense.LicenseFile.Constraints.TimeRange)">
            <summary>
              Removes a specific <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/> from the <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/>.
            </summary>
            <param name="val">The <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/> to remove from the <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/>.</param>
            <exception cref="T:System.ArgumentException"><paramref name="val"/> is not found in the Collection.</exception>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.Item(System.Int32)">
            <summary>
              Represents the entry at the specified index of the <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/>.
            </summary>
            <param name="index">The zero-based index of the entry to locate in the collection.</param>
            <value>The entry at the specified index of the collection.</value>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is outside the valid range of indexes for the collection.</exception>
        </member>
        <member name="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.TimeRangeEnumerator">
            <summary>
              Enumerator that can iterate through a TimeRangeCollection.
            </summary>
            <seealso cref="T:System.Collections.IEnumerator"/>
            <seealso cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/>
            <seealso cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.TimeRangeEnumerator.#ctor(OpenLicense.LicenseFile.Constraints.TimeRangeCollection)">
            <summary>
              Initializes a new instance of <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.TimeRangeEnumerator"/>.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.TimeRangeEnumerator.MoveNext">
            <summary>
              Advances the enumerator to the next <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/> of the <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/>.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.TimeRangeEnumerator.Reset">
            <summary>
              Sets the enumerator to its initial position, which is before the first element in the <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/>.
            </summary>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.TimeRangeCollection.TimeRangeEnumerator.Current">
            <summary>
              Gets the current <see cref="T:OpenLicense.LicenseFile.Constraints.TimeRange"/> in the <seealso cref="T:OpenLicense.LicenseFile.Constraints.TimeRangeCollection"/>.
            </summary>
        </member>
        <member name="T:OpenLicense.LicenseFile.Constraints.DemoConstraint">
            <summary>
            <p>This <see cref="T:OpenLicense.LicenseFile.Constraints.DemoConstraint"/> constrains the user
            to a given time period or duration.  It supports start and end date that the
            license will expire.  It also support a duration, to constrain the license to
            a number of days.  The constraint contains a purchase URL, Conditions, and
            info URL so they may obtain a registered license, the conditions of the
            constraint and more information.</p>
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.AbstractConstraint">AbstractConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.IConstraint">IConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DemoConstraint.#ctor">
            <summary>
            This is the constructor for the <c>DemoConstraint</c>.  The constructor
            is used to create the object without a valid license attached it to.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DemoConstraint.#ctor(OpenLicense.LicenseFile.OpenLicenseFile)">
            <summary>
            This is the constructor for the <c>DemoConstraint</c>.  The constructor
            is used to create the object and assign it to the proper license.
            </summary>
            <param name="license">
            The <see cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</see> this constraint
            belongs to.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DemoConstraint.Validate">
            <summary>
            This verifies the license meets its desired validation criteria.  This
            includes the following if defined:
            <list>
            <item>Verify the license is after the start date</item>
            <item>Verify the license is before the end data</item>
            <item>The maximum number of days has not been exceeded</item>
            </list>
            If any of these is exceeded then the license failure reason is set to
            the reason for the failure and this function returns false.  Otherwise
            the license is valid and the method returns true.
            </summary>
            <returns>
            <c>True</c> if the license meets the validation criteria.  Otherwise
            <c>False</c>.
            </returns>
            <remarks>
            When a failure occurs the FailureReason will be set to the details of the
            failure.  If the Conditions, Purchase URL, or the Information URL is defined
            then they will also be added to the failure reason.
            </remarks>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DemoConstraint.FromXml(System.String)">
            <summary>
            This is responsible for parsing a <see cref="T:System.String">String</see>
            to form the <c>DemoConstriant</c>.
            </summary>
            <param name="xmlData">
            The Xml data in the form of a <c>String</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DemoConstraint.FromXml(System.Xml.XmlNode)">
            <summary>
            This creates a <c>DemoConstraint</c> from an <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </summary>
            <param name="itemsNode">
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the <c>DemoConstraint</c>.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the <see cref="T:System.Xml.XmlNode">XmlNode</see> is null.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DemoConstraint.ToXmlString">
            <summary>
            Converts this <c>DemoConstraint</c> to an Xml <c>String</c>.
            </summary>
            <returns>
            A <c>String</c> representing the DemoConstraint as Xml data.
            </returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DemoConstraint.BuildErrorString(System.String)">
            <summary>
            This is called whenever a license failure occurs to build the Failure
            Reason string. It will take the passed in string and append the conditions,
            Purchase URL, and Information URL if they are defined.  The returned string
            is the complete failure reason for this constraint.
            </summary>
            <returns>
            A <c>String</c> representing the failure reason for this constraint.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.DemoConstraint.StartDate">
            <summary>
            Gets or Sets the start date/time for this constraint.
            </summary>
            <param>
            Sets the start date/time for this constraint.
            </param>
            <returns>
            Gets the start date/time for this constraint.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.DemoConstraint.EndDate">
            <summary>
            Gets or Sets the end date/time for this constraint.
            </summary>
            <param>
            Sets the end date/time for this constraint.
            </param>
            <returns>
            Gets the end date/time for this constraint.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.DemoConstraint.Duration">
            <summary>
            Gets or Sets the duration in days this license should be valid from the first use.
            </summary>
            <param>
            Sets the duration in days this license should be valid from the first use.
            </param>
            <returns>
            Gets the duration in days this license should be valid from the first use.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.DemoConstraint.InfoURL">
            <summary>
            Gets or Sets the URL, as a <c>String</c>, which points to where more information may be found.
            </summary>
            <param>
            Sets the URL, as a <c>String</c>, which points to where more information may be found.
            </param>
            <returns>
            Gets the URL, as a <c>String</c>, which points to where more information may be found.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.DemoConstraint.PurchaseURL">
            <summary>
            Gets or Sets the URL, as a <c>String</c>, which points to where a license can be purchased from.
            </summary>
            <param>
            Sets the URL, as a <c>String</c>, which points to where a license can be purchased from.
            </param>
            <returns>
            Gets the URL, as a <c>String</c>, which points to where a license can be purchased from.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.DemoConstraint.Condition">
            <summary>
            Gets or Sets the Terms/Conditions this license is valid for.
            </summary>
            <param>
            Sets the Terms/Conditions this license is valid for.
            </param>
            <returns>
            Gets the Terms/Conditions this license is valid for.
            </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.Constraints.DesigntimeConstraint">
            <summary>
            <p>This <see cref="T:OpenLicense.LicenseFile.Constraints.DesigntimeConstraint"/> constrains the user to only running
            the license in a design time environment.  If it is not in a Design Time
            environment then this constraint will fail.</p>
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.AbstractConstraint">AbstractConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.IConstraint">IConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DesigntimeConstraint.#ctor">
            <summary>
            This is the constructor for the <c>DesigntimeConstraint</c>.  The constructor
            is used to create the object with a valid license to attach it to.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DesigntimeConstraint.#ctor(OpenLicense.LicenseFile.OpenLicenseFile)">
            <summary>
            This is the constructor for the <c>DesigntimeConstraint</c>.  The constructor
            is used to create the object and assign it to the proper license.
            </summary>
            <param name="license">
            The <see cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</see> this constraint
            belongs to.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DesigntimeConstraint.Validate">
            <summary>
            <p>This verifies the license meets its desired validation criteria.  This includes
            validating that the license is being used in the context of Design Time. If it is
            not then the license validation will return false and the failure reason will be
            set.</p>
            </summary>
            <returns>
            <c>True</c> if the license meets the validation criteria.  Otherwise
            <c>False</c>.
            </returns>
            <remarks>
            When a failure occurs the FailureReason will be set to: "The license may only be used
            in a Design Time environment.  Runtime licensing is not supported."
            </remarks>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DesigntimeConstraint.FromXml(System.String)">
            <summary>
            This is responsible for parsing a <see cref="T:System.String">String</see>
            to form the <c>DesigntimeConstraint</c>.
            </summary>
            <param name="xmlData">
            The Xml data in the form of a <c>String</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DesigntimeConstraint.FromXml(System.Xml.XmlNode)">
            <summary>
            This creates a <c>DesigntimeConstraint</c> from an <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </summary>
            <param name="itemsNode">
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the <c>DesigntimeConstraint</c>.
            </param>
            <exception cref="T:System.ArgumentException">
            Thrown if the <see cref="T:System.Xml.XmlNode">XmlNode</see> is null.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DesigntimeConstraint.ToXmlString">
            <summary>
            Converts this <c>DesigntimeConstraint</c> to an Xml <c>String</c>.
            </summary>
            <returns>
            A <c>String</c> representing the DesigntimeConstraint as Xml data.
            </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.Constraints.DomainConstraint">
            <summary>
            <p>This <see cref="T:OpenLicense.LicenseFile.Constraints.DomainConstraint"/> constrains the user to running within a
            given set of Domains.  This is primarily used for web based licensing to make
            sure that the license is only used for specific domains.</p>
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.AbstractConstraint">AbstractConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.IConstraint">IConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DomainConstraint.#ctor">
            <summary>
            This is the constructor for the <c>DomainConstraint</c>.  The constructor
            is used to create the object with a valid license to attach it to.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DomainConstraint.#ctor(OpenLicense.LicenseFile.OpenLicenseFile)">
            <summary>
            This is the constructor for the <c>DomainConstraint</c>.  The constructor
            is used to create the object and assign it to the proper license.
            </summary>
            <param name="license">
            The <see cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</see> this constraint
            belongs to.
            </param>
            <remarks>
            This constructor initializes the current domain.  When initializing this
            an exception can be thrown.  The constructor will catch the exception
            and set the current domain to an empty string.  The license can handle this
            by setting one of the domains to an empty string which should allow the
            validation to pass.  This call will throw an exception only when used in
            a non web environment.
            </remarks>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DomainConstraint.Validate">
            <summary>
            <p>This verifies the license meets its desired validation criteria.  This includes
            validating that the license is run within the set of given domains.  If the license
            is able to match a domain with the current domain then it will be successful (true).
            Otherwise it will return false and set the failure reason to the reason for the
            failure.</p>
            </summary>
            <returns>
            <c>True</c> if the license meets the validation criteria.  Otherwise
            <c>False</c>.
            </returns>
            <remarks>
            When a failure occurs the FailureReason will be set to: "The current domain is not
            supported by this license."
            </remarks>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DomainConstraint.FromXml(System.String)">
            <summary>
            This is responsible for parsing a <see cref="T:System.String">String</see>
            to form the <c>DomainConstriant</c>.
            </summary>
            <param name="xmlData">
            The Xml data in the form of a <c>String</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DomainConstraint.FromXml(System.Xml.XmlNode)">
            <summary>
            This creates a <c>DomainConstraint</c> from an <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </summary>
            <param name="itemsNode">
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the <c>DomainConstraint</c>.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the <see cref="T:System.Xml.XmlNode">XmlNode</see> is null.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.DomainConstraint.ToXmlString">
            <summary>
            Converts this <c>DomainConstraint</c> to an Xml <c>String</c>.
            </summary>
            <returns>
            A <c>String</c> representing the DomainConstraint as Xml data.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.DomainConstraint.Domains">
            <summary>
            Gets or Sets the an array of strings which represent the domain names allowed to use this license.
            </summary>
            <param>
            Sets the an array of strings which represent the domain names allowed to use this license.
            </param>
            <returns>
            Gets the an array of strings which represent the domain names allowed to use this license.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.DomainConstraint.CurrentDomain">
            <summary>
            Gets or Sets the current domain this license is being executed on.
            </summary>
            <param>
            Sets the current domain this license is being executed on.
            </param>
            <returns>
            Gets the current domain this license is being executed on.
            </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.Constraints.MacConstraint">
            <summary>
            用于限制一个软件只能在一个机器上使用。使用的验证方式为验证MAC地址。
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.MacConstraint.GetMacAddress">
            <summary>
            获取本机MAC地址
            </summary>
        </member>
        <member name="T:OpenLicense.LicenseFile.Constraints.OrConstraint">
            <summary>
            <p>This <see cref="T:OpenLicense.LicenseFile.Constraints.OrConstraint"/> contains a collection of constraints that 
            will be grouped together as a bitwise OR operation.  It is responsible for 
            validating the containing <c>IConstraints</c> and will be valid as long as 
            one of the constraints contained is valid.  The purpose of this is to allow 
            multiple constraints to be added and create a run as long as one is valid 
            scheme.</p>
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.AbstractConstraint">AbstractConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.IConstraint">IConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.OrConstraint.#ctor">
            <summary>
            This is the constructor for the <c>OrConstraint</c>.  The constructor
            is used to create the object without a valid license attached it to.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.OrConstraint.#ctor(OpenLicense.LicenseFile.OpenLicenseFile)">
            <summary>
            This is the constructor for the <c>OrConstraint</c>.  The constructor
            is used to create the object and assign it to the proper license.
            </summary>
            <param name="license">
            The <see cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</see> this constraint
            belongs to.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.OrConstraint.Validate">
            <summary>
            This verifies the license meets its desired validation criteria.  This test will 
            pass as long as one of the constraints contained within it's collection is valid.
            If all of them are invalid, then the validate will fail and the license failure 
            reason will be set to the last constraint which failed while being validated.
            </summary>
            <returns>
            <c>True</c> if the license meets the validation criteria.  Otherwise
            <c>False</c>.
            </returns>
            <remarks>
            When a failure occurs the FailureReason will be set to the details of the
            failure for the last constraint which failed.
            </remarks>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.OrConstraint.FromXml(System.String)">
            <summary>
            This is responsible for parsing a <see cref="T:System.String">String</see>
            to form the <c>OrConstriant</c>.
            </summary>
            <param name="xmlData">
            The Xml data in the form of a <c>String</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.OrConstraint.FromXml(System.Xml.XmlNode)">
            <summary>
            This creates an <c>OrConstraint</c> from an <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </summary>
            <param name="itemsNode">
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the <c>OrConstraint</c>.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the <see cref="T:System.Xml.XmlNode">XmlNode</see> is null.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.OrConstraint.parseConstraintsFields(System.Xml.XmlNode)">
            <summary>
            Parse the XML content of the constraints group/fields section of the license.
            </summary>
            <param name="itemsNode">
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the
            Constraints List (System.Collections.Generic.List) section of the
            license.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.OrConstraint.ToXmlString">
            <summary>
            Converts this <c>OrConstraint</c> to an Xml <c>String</c>.
            </summary>
            <returns>
            A <c>String</c> representing the IConstraint as Xml data.
            </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.Constraints.ProcessorConstraint">
            <summary>
            <p>This <see cref="T:OpenLicense.LicenseFile.Constraints.ProcessorConstraint"/> constrains the user to only use the license
            with a given OS or Processor</p>
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.AbstractConstraint">AbstractConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.IConstraint">IConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.ProcessorConstraint.#ctor">
            <summary>
            This is the constructor for the <c>ProcessorConstraint</c>.  The constructor
            is used to create the object with a valid license to attach it to.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.ProcessorConstraint.#ctor(OpenLicense.LicenseFile.OpenLicenseFile)">
            <summary>
            This is the constructor for the <c>ProcessorConstraint</c>.  The constructor
            is used to create the object and assign it to the proper license.
            </summary>
            <param name="license">
            The <see cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</see> this constraint
            belongs to.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.ProcessorConstraint.Validate">
            <summary>
            <p>This verifies the license meets its desired validation criteria.  This includes
            validating that the assembly version is within the licenses defined range.</p>
            </summary>
            <returns>
            <c>True</c> if the license meets the validation criteria.  Otherwise
            <c>False</c>.
            </returns>
            <remarks>
            When a failure occurs the FailureReason will be set to: "The current version is not
            within the constraints of this license."
            </remarks>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.ProcessorConstraint.FromXml(System.String)">
            <summary>
            This is responsible for parsing a <see cref="T:System.String">String</see>
            to form the <c>ProcessorConstraint</c>.
            </summary>
            <param name="xmlData">
            The Xml data in the form of a <c>String</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.ProcessorConstraint.FromXml(System.Xml.XmlNode)">
            <summary>
            This creates a <c>ProcessorConstraint</c> from an <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </summary>
            <param name="itemsNode">
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the <c>ProcessorConstraint</c>.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the <see cref="T:System.Xml.XmlNode">XmlNode</see> is null.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.ProcessorConstraint.ToXmlString">
            <summary>
            Converts this <c>ProcessorConstraint</c> to an Xml <c>String</c>.
            </summary>
            <returns>
            A <c>String</c> representing the IConstraint as Xml data.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.ProcessorConstraint.OS">
            <summary>
            Gets or Sets the minimum version allowed for this license.
            </summary>
            <param>
            Sets the minimum version allowed for this license.
            </param>
            <returns>
            Gets the minimum version allowed for this license.
            </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.Constraints.RuntimeConstraint">
            <summary>
            <p>This <see cref="T:OpenLicense.LicenseFile.Constraints.RuntimeConstraint"/> constrains the user to only running
            the license in a runtime environment.  If it is not in a Runtime
            environment then this constraint will fail.</p>
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.AbstractConstraint">AbstractConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.IConstraint">IConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.RuntimeConstraint.#ctor">
            <summary>
            This is the constructor for the <c>RuntimeConstraint</c>.  The constructor
            is used to create the object with a valid license to attach it to.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.RuntimeConstraint.#ctor(OpenLicense.LicenseFile.OpenLicenseFile)">
            <summary>
            This is the constructor for the <c>RuntimeConstraint</c>.  The constructor
            is used to create the object and assign it to the proper license.
            </summary>
            <param name="license">
            The <see cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</see> this constraint
            belongs to.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.RuntimeConstraint.Validate">
            <summary>
            <p>This verifies the license meets its desired validation criteria.  This includes
            validating that the license is being used in the context of Runtime. If it is
            not then the license validation will return false and the failure reason will be
            set.</p>
            </summary>
            <returns>
            <c>True</c> if the license meets the validation criteria.  Otherwise
            <c>False</c>.
            </returns>
            <remarks>
            When a failure occurs the FailureReason will be set to: "The license may only be used
            in a Runtime environment.  Design Time licensing is not supported."
            </remarks>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.RuntimeConstraint.FromXml(System.String)">
            <summary>
            This is responsible for parsing a <see cref="T:System.String">String</see>
            to form the <c>RuntimeConstraint</c>.
            </summary>
            <param name="xmlData">
            The Xml data in the form of a <c>String</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.RuntimeConstraint.FromXml(System.Xml.XmlNode)">
            <summary>
            This creates a <c>RuntimeConstraint</c> from an <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </summary>
            <param name="itemsNode">
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the <c>RuntimeConstraint</c>.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the <see cref="T:System.Xml.XmlNode">XmlNode</see> is null.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.RuntimeConstraint.ToXmlString">
            <summary>
            Converts this <c>RuntimeConstraint</c> to an Xml <c>String</c>.
            </summary>
            <returns>
            A <c>String</c> representing the RuntimeConstraint as Xml data.
            </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.Constraints.UsageConstraint">
            <summary>
            <p>This <see cref="T:OpenLicense.LicenseFile.Constraints.UsageConstraint"/> constrains the user
            to a usage limit.  It supports a Maximum Usage, Hit and Days count.  Once
            the maximum number is reached the license expires.</p>
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.AbstractConstraint">AbstractConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.IConstraint">IConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.UsageConstraint.#ctor">
            <summary>
            This is the constructor for the <c>UsageConstraint</c>.  The constructor
            is used to create the object with a valid license to attach it to.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.UsageConstraint.#ctor(OpenLicense.LicenseFile.OpenLicenseFile)">
            <summary>
            This is the constructor for the <c>UsageConstraint</c>.  The constructor
            is used to create the object and assign it to the proper license.
            </summary>
            <param name="license">
            The <see cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</see> this constraint
            belongs to.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.UsageConstraint.Validate">
            <summary>
            <p>This verifies the license meets its desired validation criteria.  This includes
            validating that the license has not been used more times then the usage constraint
            allows. The usage constraints available are:
            <list>
            <item>Hit Count - The maximum number of hits for a web services.</item>
            <item>Usage Count - The maximum number of uses for a application.</item>
            <item>Duration - The maximum number of days this may be used.</item>
            </list>
            If any of these values are exceeded then the license validation will return false
            and the failure reason will be set.</p>
            </summary>
            <returns>
            <c>True</c> if the license meets the validation criteria.  Otherwise
            <c>False</c>.
            </returns>
            <remarks>
            When a failure occurs the FailureReason will be set to one of the following
            depending upon which one failed:
            <list type="definition">
             <listheader>
              <term>Validation Type</term>
              <description>Failure String Result</description>
             </listheader>
             <item>
              <term>Hits</term>
              <description>The maximum number of hits has been reached.</description>
             </item>
             <item>
              <term>Usage</term>
              <description>The maximum number of uses has been reached.</description>
             </item>
             <item>
              <term>Duration</term>
              <description>The maximum number of days has been reached.</description>
             </item>
            </list>
            </remarks>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.UsageConstraint.FromXml(System.String)">
            <summary>
            This is responsible for parsing a <see cref="T:System.String">String</see>
            to form the <c>UsageConstriant</c>.
            </summary>
            <param name="xmlData">
            The Xml data in the form of a <c>String</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.UsageConstraint.FromXml(System.Xml.XmlNode)">
            <summary>
            This creates a <c>UsageConstriant</c> from an <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </summary>
            <param name="itemsNode">
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the <c>UsageConstriant</c>.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the <see cref="T:System.Xml.XmlNode">XmlNode</see> is null.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.UsageConstraint.ToXmlString">
            <summary>
            Converts this <c>UsageConstraint</c> to an Xml <c>String</c>.
            </summary>
            <returns>
            A <c>String</c> representing the UsageConstraint as Xml data.
            </returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.UsageConstraint.IncrementUsage">
            <summary>
            Increments the current usage counter by one.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.UsageConstraint.IncrementHits">
            <summary>
            Increments the current hit counter by one.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.UsageConstraint.IncrementDays">
            <summary>
            Increments the days counter by one when a new day has occurred.
            </summary>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.UsageConstraint.MaxUsageCount">
            <summary>
            Gets or Sets the maximum allowed uses for this <c>UsageConstraint</c>.
            </summary>
            <param>
            Sets the maximum allowed uses for this <c>UsageConstraint</c>.
            </param>
            <returns>
            Gets the maximum allowed uses for this <c>UsageConstraint</c>.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.UsageConstraint.CurrentUsageCount">
            <summary>
            Gets the current usage count for this <c>UsageConstraint</c>.
            </summary>
            <returns>
            Gets the current usage count for this <c>UsageConstraint</c>.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.UsageConstraint.MaxHitCount">
            <summary>
            Gets or Sets the maximum allowed hits for this <c>UsageConstraint</c>.
            </summary>
            <param>
            Sets the maximum allowed hits for this <c>UsageConstraint</c>.
            </param>
            <returns>
            Gets the maximum allowed hits for this <c>UsageConstraint</c>.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.UsageConstraint.CurrentHitCount">
            <summary>
            Gets the current hit count for this <c>UsageConstraint</c>.
            </summary>
            <returns>
            Gets the current hit count for this <c>UsageConstraint</c>.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.UsageConstraint.MaxDays">
            <summary>
            Gets or Sets the maximum number of days allowed for this <c>UsageConstraint</c>.
            </summary>
            <param>
            Sets the maximum number of days allowed for this <c>UsageConstraint</c>.
            </param>
            <returns>
            Gets the maximum number of days allowed for this <c>UsageConstraint</c>.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.UsageConstraint.CurrentDays">
            <summary>
            Gets the current days count for this <c>UsageConstraint</c>.
            </summary>
            <returns>
            Gets the current days count for this <c>UsageConstraint</c>.
            </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.Constraints.VersionConstraint">
            <summary>
            <p>This <see cref="T:OpenLicense.LicenseFile.Constraints.VersionConstraint"/> constrains the user to only use the license
            with a given range of versions attached to an Assembly.  For example if an assembly
            version is 0.95.0.0 and the version range is 0.94.0.0 to 0.96.0.0 then the license
            will pass.  However if the assembly is then upgrade to version 1.0.0.0 then the license
            will expire.</p>
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.AbstractConstraint">AbstractConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.IConstraint">IConstraint</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.VersionConstraint.#ctor">
            <summary>
            This is the constructor for the <c>VersionConstraint</c>.  The constructor
            is used to create the object with a valid license to attach it to.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.VersionConstraint.#ctor(OpenLicense.LicenseFile.OpenLicenseFile)">
            <summary>
            This is the constructor for the <c>VersionConstraint</c>.  The constructor
            is used to create the object and assign it to the proper license.
            </summary>
            <param name="license">
            The <see cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</see> this constraint
            belongs to.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.VersionConstraint.Validate">
            <summary>
            <p>This verifies the license meets its desired validation criteria.  This includes
            validating that the assembly version is within the licenses defined range.</p>
            </summary>
            <returns>
            <c>True</c> if the license meets the validation criteria.  Otherwise
            <c>False</c>.
            </returns>
            <remarks>
            When a failure occurs the FailureReason will be set to: "The current version is not
            within the constraints of this license."
            </remarks>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.VersionConstraint.FromXml(System.String)">
            <summary>
            This is responsible for parsing a <see cref="T:System.String">String</see>
            to form the <c>VersionConstriant</c>.
            </summary>
            <param name="xmlData">
            The Xml data in the form of a <c>String</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.VersionConstraint.FromXml(System.Xml.XmlNode)">
            <summary>
            This creates a <c>VersionConstraint</c> from an <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </summary>
            <param name="itemsNode">
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the <c>VersionConstraint</c>.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the <see cref="T:System.Xml.XmlNode">XmlNode</see> is null.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.Constraints.VersionConstraint.ToXmlString">
            <summary>
            Converts this <c>VersionConstraint</c> to an Xml <c>String</c>.
            </summary>
            <returns>
            A <c>String</c> representing the IConstraint as Xml data.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.VersionConstraint.Minimum">
            <summary>
            Gets or Sets the minimum version allowed for this license.
            </summary>
            <param>
            Sets the minimum version allowed for this license.
            </param>
            <returns>
            Gets the minimum version allowed for this license.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Constraints.VersionConstraint.Maximum">
            <summary>
            Gets or Sets the maximum version allowed for this license.
            </summary>
            <param>
            Sets the maximum version allowed for this license.
            </param>
            <returns>
            Gets the maximum version allowed for this license.
            </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.CustomData">
            <summary>
            The <c>CustomData</c> object inherits from the <see cref="T:OpenLicense.LicenseFile.AbstractLicenseData"/>.  The
            <c>CustomData</c> is used by developers to store unique custom data using a Key/Value
            pairing in a <c>StringDictionary</c>.
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.AbstractLicenseData">AbstractLicenseData</seealso>
            <seealso cref="T:System.Collections.Specialized.StringDictionary">StringDictionary</seealso>
        </member>
        <member name="M:OpenLicense.LicenseFile.CustomData.FromXml(System.String)">
            <summary>
            This is a static method that creates an <c>CustomData</c> from the passed in XML
            <see cref="T:System.String">String</see>.
            </summary>
            <param>
            The <see cref="T:System.String">String</see> representing the XML data.
            </param>
            <returns>
            The <c>CustomData</c> created from parsing this <see cref="T:System.String">String</see>.
            </returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.CustomData.FromXml(System.Xml.XmlNode)">
            <summary>
            This is a static method that creates an <c>CustomData</c> from a <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </summary>
            <param>
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the <c>CustomData</c>.
            </param>
            <returns>
            The <c>CustomData</c> created from this <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the license data is null.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.CustomData.#ctor">
            <summary>
            This initializes an empty <c>CustomData</c> object.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.CustomData.#ctor(System.Collections.Specialized.StringDictionary)">
            <summary>
            This initializes a <c>CustomData</c> object with a given <c>StringCollection</c>.
            </summary>
            <param name="col">
            The string collection data to use.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.CustomData.AddCustomData(System.String,System.String)">
            <summary>
            Adds a key/value pair containing custom data.
            </summary>
            <param name="key">
            A <see cref="T:System.String">String</see> representing the key for this item.
            </param>
            <param name="val">
            A <see cref="T:System.String">String</see> representing the value for this item.
            </param>
            <exception cref="T:System.ArgumentException">
            Thrown if the input key is an empty <see cref="T:System.String">String</see>.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.CustomData.AddCustomData(System.Collections.Specialized.StringDictionary)">
            <summary>
            Adds the values of a <c>StringDictionary</c> to the <c>CustomData</c> object.
            </summary>
            <param>
            A <c>StringDictionary</c> with the data to be added.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.CustomData.ToXmlString">
            <summary>
            This creates a <see cref="T:System.String">String</see> representing the
            XML form for this <c>CustomData</c> object.
            </summary>
            <returns>
            The <see cref="T:System.String">String</see> representing this <c>CustomData</c> object in it's XML form.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.CustomData.Items">
            <summary>
            Gets or Sets the <c>StringDictionary</c> of the <c>CustomData</c> object.
            </summary>
            <param>
            Sets the <c>StringDictionary</c> of the <c>CustomData</c> object.
            </param>
            <returns>
            Gets the <c>StringDictionary</c> of the <c>CustomData</c> object.
            </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.Issuer">
            <summary>
            The <c>Issuer</c> object inherits from the <see cref="T:OpenLicense.LicenseFile.AbstractLicenseData"/>.  The
            <c>Issuer</c> is used as the person who released the license.  The issue contains
            the person's name, email address and URL.
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.AbstractLicenseData">AbstractLicenseData</seealso>
        </member>
        <member name="M:OpenLicense.LicenseFile.Issuer.FromXml(System.String)">
            <summary>
            This is a static method that creates an <c>Issuer</c> from the passed in XML
            <see cref="T:System.String">String</see>.
            </summary>
            <param>
            The <see cref="T:System.String">String</see> representing the Xml data.
            </param>
            <returns>
            The <c>Issuer</c> created from parsing this <see cref="T:System.String">String</see>.
            </returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.Issuer.FromXml(System.Xml.XmlNode)">
            <summary>
            This is a static method that creates an <c>Issuer</c> from a <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </summary>
            <param>
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the <c>Issuer</c>.
            </param>
            <returns>
            The <c>Issuer</c> created from this <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the license data is null.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.Issuer.#ctor">
            <summary>
            This initializes an empty <c>Issuer</c>.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Issuer.#ctor(System.String)">
            <summary>
            This initializes an <c>Issuer</c> with a given name.
            </summary>
            <param name="name">
            The name of the person or company issuing the license.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Issuer.#ctor(System.String,System.String)">
            <summary>
            This initializes an <c>Issuer</c> with a given name and email.
            </summary>
            <param name="name">
            The name of the person or company issuing the license.
            </param>
            <param name="email">
            The email of the person or company issuing the license. Generally this is a support email address.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Issuer.#ctor(System.String,System.String,System.String)">
            <summary>
            This initializes an <c>Issuer</c> with a given name, email and URL.
            </summary>
            <param name="name">
            The name of the person or company issuing the license.
            </param>
            <param name="email">
            The email of the person or company issuing the license. Generally this is a support email address.
            </param>
            <param name="url">
            The url of the person or company issuing the license. Generally this is the company's web address.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Issuer.ToXmlString">
            <summary>
            This creates a <see cref="T:System.String">String</see> representing the
            XML form for this <c>Issuer</c>.
            </summary>
            <returns>
            The <see cref="T:System.String">String</see> representing this <c>Issuer</c> in it's XML form.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Issuer.FullName">
            <summary>
            Gets or Sets the name of the <c>Issuer</c> of this license.
            </summary>
            <param>
            Gets the name of the <c>Issuer</c> of this license.
            </param>
            <returns>
            Sets the name of the <c>Issuer</c> of this license.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Issuer.Email">
            <summary>
            Gets or Sets the email address of the <c>Issuer</c> for this license.
            </summary>
            <param>
            Gets the email address of the <c>Issuer</c> for this license.
            </param>
            <returns>
            Sets the email address of the <c>Issuer</c> for this license.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Issuer.Url">
            <summary>
            Gets or Sets the URL of the <c>Issuer</c> for this license.
            </summary>
            <param>
            Sets the URL of the <c>Issuer</c> for this license.
            </param>
            <returns>
            Gets the URL of the <c>Issuer</c> for this license.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.LicenseItem.LoadLicenseFolder">
            <summary>
            Indicate where should load the license file, if not inidcated, search from default folder.
            </summary>
        </member>
        <member name="P:OpenLicense.LicenseFile.LicenseItem.UpdateLicenseFile">
            <summary>
            Indicate where should save the updated license file, if not inidcated, use the LoadLicenseFolder or default IsolatedStorage folder.
            </summary>
        </member>
        <member name="P:OpenLicense.LicenseFile.LicenseItem.SaveLicenseToIsolatedStorage">
            <summary>
            If save license file to IsolatedStorage 
            </summary>
        </member>
        <member name="T:OpenLicense.LicenseFile.OpenLicenseFile">
            <summary>
            This is the .LIC file object.  This file contains all the fields
            a developer should need to create a license of their choice.  It supports
            many standard fields and has the ability to store custom key/value pairs.
            This file also contains a Constraints List (System.Collections.Generic.List) 
            which is responsible for determine the validity of this license.  The 
            constraints are used to determine if the license may be used.
            </summary>
            <seealso cref="T:OpenLicense.OpenLicenseProvider">OpenLicenseProvider</seealso>
            <seealso cref="T:System.String">String</seealso>
            <seealso cref="T:System.Xml.XmlDocument">XmlDocument</seealso>
            <seealso cref="T:System.Xml.XmlNode">XmlNode</seealso>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.FromXml(OpenLicense.LicenseFile.LicenseItem,System.String)">
            <summary>
            Creates a new <c>OpenLicenseFile</c> from a
            <see cref="T:System.String">String</see> that contains Xml data.
            </summary>
            <param name="type">
            The <see cref="T:System.Type">Type</see> requesting the License.
            </param>
            <param name="str">
            A <see cref="T:System.String">String</see> representing a valid XML version of a
            license.
            </param>
            <returns>
            The <c>OpenLicenseFile</c> generated from this Xml data or null if an error occurred.
            </returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.FromXml(OpenLicense.LicenseFile.LicenseItem,System.Xml.XmlDocument)">
            <summary>
            Creates a new <c>OpenLicenseFile</c> from a <see cref="T:System.String">String</see>.
            </summary>
            <param name="type">
            The <see cref="T:System.Type">Type</see> requesting the object to be licensed.
            </param>
            <param name="doc">
            A <see cref="T:System.Xml.XmlDocument">XmlDocument</see> representing the license.
            </param>
            <returns>
            The <c>OpenLicenseFile</c> generated from this
            <see cref="T:System.Xml.XmlDocument">XmlDocument</see> or null if an error occurred.
            </returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.LoadFromString(System.String,OpenLicense.LicenseFile.LicenseItem)">
            <summary>
            Create an OpenLicenseFile from a string
            </summary>
            <param name="str">
            The string to create the license from.
            </param>
            <param name="type">
            The Type of object being loaded.
            </param>
            <returns>
            A new OpenLicenseFile from the string or blank new file.
            </returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.LoadFile(System.IO.Stream,OpenLicense.LicenseFile.LicenseItem,System.Boolean,System.String)">
            <summary>
            Loads the specified file to create an OpenLicenseFile.
            </summary>
            <param name="stream">
            The stream to use to open the file.
            </param>
            <param name="type">
            The Type of object being loaded.
            </param>
            <param name="useEncryption">
            A flag to know if this file should be encrypted when saved. True will encrypt the
            file.  If this is set then the key value must be defined as a valid string.
            </param>
            <param name="key">
            The encryption key to be used to encrypt the file. Only used if useEncryption is set to true.
            </param>
            <exception cref="T:System.ArgumentException">
            Thrown when the encryption key is blank and the useEncryption value is set to true.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.LoadFile(OpenLicense.LicenseFile.LicenseItem,System.String,System.String,System.Boolean,System.String)">
            <summary>
            Loads the specified file to create an OpenLicenseFile.
            </summary>
            <param name="type">
            The type requesting to load the OpenLicenseFile for.  This is used to create the license.
            </param>
            <param name="path">
            The full path to save the file.
            </param>
            <param name="fileName">
            The name of the file to be created.
            </param>
            <param name="useEncryption">
            A flag to know if this file should be encrypted when saved. True will encrypt the
            file.  If this is set then the key value must be defined as a valid string.
            </param>
            <param name="key">
            The encryption key to be used to encrypt the file. Only used if use_encryption is set to true.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.LoadFile(OpenLicense.LicenseFile.LicenseItem,System.String,System.Boolean,System.String)">
            <summary>
            Loads the specified file to create an OpenLicenseFile.
            </summary>
            <param name="type">
            The type requesting to load the OpenLicenseFile for.  This is used to create the license.
            </param>
            <param name="pathWithFileName">
            The full path including the filename.
            </param>
            <param name="useEncryption">
            A flag to know if this file should be encrypted when saved. True will encrypt the
            file.  If this is set then the key value must be defined as a valid string.
            </param>
            <param name="key">
            The encryption key to be used to encrypt the file. Only used if use_encryption is set to true.
            </param>
            <exception cref="T:System.ArgumentException">
            Thrown if the path does not exist.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.SaveFile(OpenLicense.LicenseFile.OpenLicenseFile,System.IO.Stream,System.Boolean,System.String)">
            <summary>
            Saves the license to the specified path using the given file name.
            </summary>
            <param name="license">
            The <c>OpenLicenseFile</c> to save.
            </param>
            <param name="stream">
            The stream to write the file to.
            </param>
            <param name="useEncryption">
            A flag to know if this file should be encrypted when saved. True will encrypt the
            file.  If this is set then the key value must be defined as a valid string.
            </param>
            <param name="key">
            The encryption key to be used to encrypt the file. Only used if use_encryption is set to true.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.SaveFile(OpenLicense.LicenseFile.OpenLicenseFile,System.String,System.String)">
            <summary>
            Saves the license to the specified path using the given file name.
            </summary>
            <param name="license">
            The <c>OpenLicenseFile</c> to save.
            </param>
            <param name="path">
            The full path to save the file.
            </param>
            <param name="fileName">
            The name of the file to be created.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.SaveFile(OpenLicense.LicenseFile.OpenLicenseFile,System.String,System.String,System.Boolean,System.String)">
            <summary>
            Saves the license to the specified path using the given file name.
            </summary>
            <param name="license">
            The <c>OpenLicenseFile</c> to save.
            </param>
            <param name="path">
            The full path to save the file.
            </param>
            <param name="fileName">
            The name of the file to be created.
            </param>
            <param name="useEncryption">
            A flag to know if this file should be encrypted when saved. True will encrypt the
            file.  If this is set then the key value must be defined as a valid string.
            </param>
            <param name="key">
            The encryption key to be used to encrypt the file. Only used if use_encryption is set to true.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.SaveFile(OpenLicense.LicenseFile.OpenLicenseFile,System.String,System.Boolean,System.String)">
            <summary>
            Saves the license to the specified path using the given file name.
            </summary>
            <param name="license">
            The <c>OpenLicenseFile</c> to save.
            </param>
            <param name="fullPathWithFileName">
            The full path including the filename.
            </param>
            <param name="useEncryption">
            A flag to know if this file should be encrypted when saved. True will encrypt the
            file.  If this is set then the key value must be defined as a valid string.
            </param>
            <param name="key">
            The encryption key to be used to encrypt the file. Only used if use_encryption is set to true.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.#ctor(OpenLicense.LicenseFile.LicenseItem,System.String)">
            <summary>
            The constructor for an <c>OpenLicenseFile</c>.
            </summary>
            <param name="type">
            The <see cref="T:System.Type">Type</see> requesting the License.
            </param>
            <param name="key">
            A <see cref="T:System.String">String</see> representing the Xml data of the license.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.Dispose">
            <summary>
            Destroys this instance of the license.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.LoadFromFile(System.String)">
            <summary>
            Loads a license from a Xml file to generate the license.
            </summary>
            <param name="fullPathWithName">
            A <see cref="T:System.String">String</see> representing the path and file name of
            the license.
            </param>
            <exception cref="T:System.ArgumentException">
            Thrown if the file could not be found.
            </exception>
            <remarks>
            The full path name including the file name is required for this function to know
            where to save the file.  You may want to use the <c>MapPath</c> function to make sure you
            have the proper path.
            </remarks>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.LoadFromXml(System.String)">
            <summary>
            Loads a license from a <see cref="T:System.String">String</see> representing
            the Xml data for the license.
            </summary>
            <param name="xmlData">
            A <see cref="T:System.String">String</see> representing the Xml data of a
            license.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.LoadFromXml(System.Xml.XmlDocument)">
            <summary>
            Loads a license from a <see cref="T:System.Xml.XmlDocument">XmlDocument</see>
            for the license.
            </summary>
            <param name="xmlDoc">
            A <see cref="T:System.Xml.XmlDocument">XmlDocument</see> representing the license.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.LoadFromXml(System.Xml.XmlNode)">
            <summary>
            Loads a license from a <see cref="T:System.Xml.XmlNode">XmlNode</see> for the
            license.
            </summary>
            <param name="xmlData">
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the license.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.parseLicense(System.Xml.XmlNode)">
            <summary>
            Parses the XML content of the license. Used internally when the key is passed
            into the constructor to build the license object.  It is also used by the
            LoadFromXml methods.
            </summary>
            <param name="itemsNode">
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the license.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the license data is null.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.parseLicenseItems(System.Xml.XmlNode)">
            <summary>
            Parse the XML content of the license that is not part of another child object.
            </summary>
            <param name="itemNode">
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the license.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.parseCustomFields(System.Xml.XmlNode)">
            <summary>
            Parse the XML content of the custom fields section of the license.
            </summary>
            <param name="itemsNode">
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the Custom Fields
            section of the license.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.parseConstraintsFields(System.Xml.XmlNode)">
            <summary>
            Parse the XML content of the constraints group/fields section of the license.
            </summary>
            <param name="itemsNode">
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the
            Constraints List (System.Collections.Generic.List) section of the
            license.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.Validate">
            <summary>
            Validated the License against to the hash key to make sure the
            license hasn't been altered.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.SaveFile(System.String)">
            <summary>
            Saves the license to the specified path using the given file name.
            </summary>
            <param name="fullPathWithFileName">
            The full path including the filename.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.SaveFile(System.IO.Stream)">
            <summary>
            Saves the license to the specified path using the given steam.
            </summary>
            <param name="stream">
            The stream to write to.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.SetupEncryptionKey(System.String)">
            <summary>
            This will setup the license to use encryption or disable encryption.  Set the key
            to an empty string to disable encryption
            </summary>
            <param name="key">
            The encryption key
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.ResetCreationStatistics">
            <summary>
            Resets the date information of this license.  This includes the Creation,
            Modification, and First Use dates.  It also includes changing the Statistics
            DateTimeLastAccessed since this is for User Access info not creator.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.ResetIsDirty">
            <summary>
            Converts this <c>OpenLicenseFile</c> to a <see cref="T:System.String">String</see> containing
            the Xml format of the license.
            </summary>
            <returns>
            A <see cref="T:System.String">String</see> representing the Xml for this object.
            </returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.ToString">
            <summary>
            Returns a <see cref="T:System.String">String</see> that represents the current <c>OpenLicenseFile</c>.
            This currently just returns "Open License File".
            </summary>
            <returns>
            A <see cref="T:System.String">String</see> representing this <c>OpenLicenseFile</c>.
            </returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.GenerateHashString">
            <summary>
            This will generate the Hash key based upon the current OpenLicenseFile data.
            It will take the current XML format of the license without the ValidationKey
            tag and generate the key.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.ToXmlString">
            <summary>
            Converts this <c>OpenLicenseFile</c> to a <see cref="T:System.String">String</see> containing
            the Xml format of the license.
            </summary>
            <returns>
            A <see cref="T:System.String">String</see> representing the Xml form of this <c>OpenLicenseFile</c>.
            </returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.ToEncryptionXmlString">
            <summary>
            Get the encrption xml string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.LoadDefaultEncryptionFile(System.IO.Stream)">
            <summary>
            Load from a license file in default encryption format.
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.LoadDefaultEncryptionFile(System.Byte[])">
            <summary>
            Load from a license file in default encryption format.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.OpenLicenseFile.GetCustomFieldValue(System.String)">
            <summary>
            Returns the value for an item set in the <c>CustomData</c> that matches the entered
            key.  If the <c>CustomData</c> has not yet been set then a null exception will be thrown.
            Also if the passed in <see cref="T:System.String">String</see> is empty an argument
            exception is thrown.
            </summary>
            <param>
            A <see cref="T:System.String">String</see> to find the value of the <c>CustomData</c>.
            </param>
            <return>
            The value found matching this key.  Otherwise an empty
            <see cref="T:System.String">String</see> is returned.
            </return>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the <c>CustomData</c> object has no records.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if the input value is an empty <see cref="T:System.String">String</see>.
            </exception>
        </member>
        <member name="P:OpenLicense.LicenseFile.OpenLicenseFile.FailureReason">
            <summary>
            Gets or Sets the reason a failure occurred. This is an empty
            <see cref="T:System.String">String</see> if no error occurred.
            </summary>
            <param>
            Sets the reason a failure occurred.  Should never be directly set by a user.
            </param>
            <returns>
            A <see cref="T:System.String">String</see> representing the reason for the
            failure to obtain a license.  An empty <see cref="T:System.String">String</see>
            if no failure occurred.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.OpenLicenseFile.UseEncryption">
            <summary>
            Gets or Sets if this license should use encryption.
            </summary>
            <param>
            Sets if this license should use encryption.
            </param>
            <returns>
            Gets if this license should use encryption.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.OpenLicenseFile.IsDirty">
            <summary>
            Gets if this license was modified since it was last saved.
            </summary>
            <returns>
            Gets if this license was modified since it was last saved.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.OpenLicenseFile.IsReadOnly">
            <summary>
            Gets or Sets if this license can only be read and not modified.
            </summary>
            <param>
            Sets if this license can only be read and not modified.
            </param>
            <returns>
            Gets if this license can only be read and not modified.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.OpenLicenseFile.LicenseKey">
            <summary>
            Gets the license key (XML string representing the license) granted for this license.
            </summary>
            <returns>
            Gets the license key (XML string representing the license) granted for this license.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.OpenLicenseFile.Type">
            <summary>
            Gets object Type this license is assigned to.
            </summary>
            <returns>
            Gets object Type this license is assigned to.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.OpenLicenseFile.Product">
            <summary>
            Gets or Sets the <see cref="P:OpenLicense.LicenseFile.OpenLicenseFile.Product"/> object declared for this license.
            </summary>
            <param>
            Sets the <see cref="P:OpenLicense.LicenseFile.OpenLicenseFile.Product"/> object declared for this license.
            </param>
            <returns>
            Gets the <see cref="P:OpenLicense.LicenseFile.OpenLicenseFile.Product"/> object declared for this license.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.OpenLicenseFile.User">
            <summary>
            Gets or Sets the <see cref="P:OpenLicense.LicenseFile.OpenLicenseFile.User"/> object who owns this license.
            </summary>
            <param>
            Sets the <see cref="P:OpenLicense.LicenseFile.OpenLicenseFile.User"/> object who owns this license.
            </param>
            <returns>
            Gets the <see cref="P:OpenLicense.LicenseFile.OpenLicenseFile.User"/> object who owns this license.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.OpenLicenseFile.Statistics">
            <summary>
            Gets or Sets the <see cref="P:OpenLicense.LicenseFile.OpenLicenseFile.Statistics"/> object for this license.
            </summary>
            <param>
            Sets the <see cref="P:OpenLicense.LicenseFile.OpenLicenseFile.Statistics"/> object for this license.
            </param>
            <returns>
            Gets the <see cref="P:OpenLicense.LicenseFile.OpenLicenseFile.Statistics"/> object for this license.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.OpenLicenseFile.CreationDate">
            <summary>
            Gets the DateTime this license was created.
            </summary>
            <returns>
            Gets the DateTime this license was created.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.OpenLicenseFile.ModificationDate">
            <summary>
            Gets the DateTime this license was last modified.
            </summary>
            <returns>
            Gets the DateTime this license was last modified.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.OpenLicenseFile.FirstUsesDate">
            <summary>
            Gets the DateTime this license was first used.
            </summary>
            <returns>
            Gets the DateTime this license was first used.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.OpenLicenseFile.Issuer">
            <summary>
            Gets or Sets the <see cref="P:OpenLicense.LicenseFile.OpenLicenseFile.Issuer"/> object for this license.
            </summary>
            <param>
            Sets the <see cref="P:OpenLicense.LicenseFile.OpenLicenseFile.Issuer"/> object for this license.
            </param>
            <returns>
            Gets the <see cref="P:OpenLicense.LicenseFile.OpenLicenseFile.Issuer"/> object for this license.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.OpenLicenseFile.Constraints">
            <summary>
            Gets or Sets the Constraints List (System.Collections.Generic.List) for this license.
            </summary>
            <param>
            Sets the Constraints List (System.Collections.Generic.List) for this license.
            </param>
            <returns>
            Gets the Constraints List (System.Collections.Generic.List) for this license.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.OpenLicenseFile.CustomData">
            <summary>
            Gets or Sets the <see cref="P:OpenLicense.LicenseFile.OpenLicenseFile.CustomData"/> for this license.
            </summary>
            <param>
            Sets the <see cref="P:OpenLicense.LicenseFile.OpenLicenseFile.CustomData"/> for this license.
            </param>
            <returns>
            Gets the <see cref="P:OpenLicense.LicenseFile.OpenLicenseFile.CustomData"/> for this license.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.OpenLicenseFile.KeyString">
            <summary>
             Gets the current Hash Key used for hash code generation.
             </summary>
             <returns>
             Gets the current Hash Key used for hash code generation.
             </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.Product">
            <summary>
            The <c>Product</c> object inherits from the <see cref="T:OpenLicense.LicenseFile.AbstractLicenseData"/>.  The
            <c>Product</c> is the information about the assembly this license is used for.  It
            contains values for the Assembly, name, version, etc...
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.AbstractLicenseData">AbstractLicenseData</seealso>
        </member>
        <member name="M:OpenLicense.LicenseFile.Product.FromXml(System.String)">
            <summary>
            This is a static method that creates an <c>Product</c> from the passed in XML
            <see cref="T:System.String">String</see>.
            </summary>
            <param>
            The <see cref="T:System.String">String</see> representing the Xml data.
            </param>
            <returns>
            The <c>Product</c> created from parsing this <see cref="T:System.String">String</see>.
            </returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.Product.FromXml(System.Xml.XmlNode)">
            <summary>
            This is a static method that creates an <c>Product</c> from a <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </summary>
            <param>
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the <c>Product</c>.
            </param>
            <returns>
            The <c>Product</c> created from this <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the license data is null.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.Product.LoadAssemblyFromFile(System.String)">
            <summary>
            A static method for obtaining the Assembly from a given path.
            </summary>
            <param name="path">
            The path to the given assembly to be loaded.
            </param>
            <returns>
            The Assembly if it was loaded.  Otherwise null.
            </returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.Product.LoadAssemblyFromPartialName(System.String)">
            <summary>
            A static method for obtaining the Assembly from a partial name.  This method
            will only work if the Assembly is located in the GAC or the application bin
            directory.
            </summary>
            <param name="name">
            The path to the given assembly to be loaded.
            </param>
            <returns>
            The Assembly if it was loaded.  Otherwise null.
            </returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.Product.#ctor">
            <summary>
            This initializes an empty <c>Product</c>.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Product.#ctor(System.Reflection.Assembly)">
            <summary>
            This initializes a <c>Product</c> with the passed in value.
            </summary>
            <param name="a">
            The <c>Assembly</c> of the <c>Product</c> object.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Product.#ctor(System.Reflection.Assembly,System.String)">
            <summary>
            This initializes a <c>Product</c> with the passed in values.
            </summary>
            <param name="a">
            The <c>Assembly</c> of the <c>Product</c> object.
            </param>
            <param name="path">
            The path to the location where the Assembly was found.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Product.#ctor(System.Reflection.Assembly,System.String,System.String)">
            <summary>
            This initializes a <c>Product</c> with the passed in values.
            </summary>
            <param name="a">
            The <c>Assembly</c> of the <c>Product</c> object.
            </param>
            <param name="path">
            The path to the location where the Assembly was found.
            </param>
            <param name="sname">
            The short name of this <c>Assembly</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Product.#ctor(System.Reflection.Assembly,System.String,System.String,System.String)">
            <summary>
            This initializes a <c>Product</c> with the passed in values.
            </summary>
            <param name="a">
            The <c>Assembly</c> of the <c>Product</c> object.
            </param>
            <param name="path">
            The path to the location where the Assembly was found.
            </param>
            <param name="sname">
            The short name of this <c>Assembly</c>.
            </param>
            <param name="fname">
            The full name of this <c>Assembly</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Product.#ctor(System.Reflection.Assembly,System.String,System.String,System.String,System.String)">
            <summary>
            This initializes a <c>Product</c> with the passed in values.
            </summary>
            <param name="a">
            The <c>Assembly</c> of the <c>Product</c> object.
            </param>
            <param name="gac">
            True if the assembly is found in the GAC.  Otherwise false
            </param>
            <param name="path">
            The path to the location where the Assembly was found.
            </param>
            <param name="sname">
            The short name of this <c>Assembly</c>.
            </param>
            <param name="fname">
            The full name of this <c>Assembly</c>.
            </param>
            <param name="ver">
            The version of this <c>Assembly</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Product.#ctor(System.Reflection.Assembly,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            This initializes a <c>Product</c> with the passed in values.
            </summary>
            <param name="a">
            The <c>Assembly</c> of the <c>Product</c> object.
            </param>
            <param name="gac">
            True if the assembly is found in the GAC.  Otherwise false
            </param>
            <param name="path">
            The path to the location where the Assembly was found.
            </param>
            <param name="sname">
            The short name of this <c>Assembly</c>.
            </param>
            <param name="fname">
            The full name of this <c>Assembly</c>.
            </param>
            <param name="ver">
            The version of this <c>Assembly</c>.
            </param>
            <param name="dev">
            The developer of this <c>Assembly</c>
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Product.#ctor(System.Reflection.Assembly,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            This initializes a <c>Product</c> with the passed in values.
            </summary>
            <param name="a">
            The <c>Assembly</c> of the <c>Product</c> object.
            </param>
            <param name="gac">
            True if the assembly is found in the GAC.  Otherwise false
            </param>
            <param name="path">
            The path to the location where the Assembly was found.
            </param>
            <param name="sname">
            The short name of this <c>Assembly</c>.
            </param>
            <param name="fname">
            The full name of this <c>Assembly</c>.
            </param>
            <param name="ver">
            The version of this <c>Assembly</c>.
            </param>
            <param name="dev">
            The developer of this <c>Assembly</c>
            </param>
            <param name="desc">
            The description of the <c>Product</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Product.#ctor(System.Reflection.Assembly,System.String,System.String,System.String,System.String,System.String,System.String,System.Boolean)">
            <summary>
            This initializes a <c>Product</c> with the passed in values.
            </summary>
            <param name="a">
            The <c>Assembly</c> of the <c>Product</c> object.
            </param>
            <param name="gac">
            True if the assembly is found in the GAC.  Otherwise false
            </param>
            <param name="path">
            The path to the location where the Assembly was found.
            </param>
            <param name="sname">
            The short name of this <c>Assembly</c>.
            </param>
            <param name="fname">
            The full name of this <c>Assembly</c>.
            </param>
            <param name="ver">
            The version of this <c>Assembly</c>.
            </param>
            <param name="dev">
            The developer of this <c>Assembly</c>
            </param>
            <param name="desc">
            The description of the <c>Product</c>.
            </param>
            <param name="isLicensed">
            True if this <c>Product</c> should be completely licensed.  Otherwise false.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Product.ToXmlString">
            <summary>
            This creates a <see cref="T:System.String">String</see> representing the
            XML form for this <c>Product</c>.
            </summary>
            <returns>
            The <see cref="T:System.String">String</see> representing this <c>Product</c> in it's XML form.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Product.Assembly">
            <summary>
            Gets or Sets the Assembly for this <c>Product</c>.  When the Assembly
            is first assigned to a product the information of the Assembly is parsed
            to fill in other areas of the <c>Product</c> automatically like the full
            name, version, etc...  However this will only perform this action if
            the values have not yet been set (String.Empty).
            </summary>
            <param>
            Sets the Assembly for this <c>Product</c>.
            </param>
            <returns>
            Gets the Assembly for this <c>Product</c>.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Product.FilePath">
            <summary>
            Gets or Sets the file path for this Assembly.
            </summary>
            <param>
            Sets the file path for this Assembly.
            </param>
            <returns>
            Gets the file path for this Assembly.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Product.ShortName">
            <summary>
            Gets or Sets the short name of this Assembly or product,or BundleSymbolicName.
            </summary>
            <param>
            Sets the short name of this Assembly.
            </param>
            <returns>
            Gets the short name of this Assembly.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Product.ProductId">
            <summary>
            Gets or Sets the product id of this Assembly or product,or BundleSymbolicName, it's optional.
            </summary>
        </member>
        <member name="P:OpenLicense.LicenseFile.Product.LicenseType">
            <summary>
            Gets or Sets the license type of this Assembly or product,or BundleSymbolicName, it's optional.
            </summary>
        </member>
        <member name="P:OpenLicense.LicenseFile.Product.FullName">
            <summary>
            Gets or Sets the full name of this Assembly.
            </summary>
            <param>
            Sets the full name of this Assembly.
            </param>
            <returns>
            Gets the full name of this Assembly.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Product.Version">
            <summary>
            Gets or Sets the version of this Assembly.
            </summary>
            <param>
            Sets the version of this Assembly.
            </param>
            <returns>
            Gets the version of this Assembly.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Product.NonAssembly">
            <summary>
            Indicate if this product is non-assembly based product,
            for bundle, it only contains bundle name (short name)+version
            </summary>
        </member>
        <member name="P:OpenLicense.LicenseFile.Product.Developer">
            <summary>
            Gets or Sets the developer of this Assembly.
            </summary>
            <param>
            Sets the developer of this Assembly.
            </param>
            <returns>
            Gets the developer of this Assembly.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Product.Description">
            <summary>
            Gets or Sets a description for this <c>Product</c>.
            </summary>
            <param>
            Sets a description for this <c>Product</c>.
            </param>
            <returns>
            Gets a description for this <c>Product</c>.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Product.IsLicensed">
            <summary>
            Gets or Sets if this <c>Product</c> has been fully licensed with no restrictions.
            </summary>
            <param>
            Sets if this <c>Product</c> has been fully licensed with no restrictions.
            </param>
            <returns>
            Gets if this <c>Product</c> has been fully licensed with no restrictions.
            </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.Statistics">
            <summary>
            The <c>Statistics</c> object inherits from the <see cref="T:OpenLicense.LicenseFile.AbstractLicenseData"/>.  The
            <c>Statistics</c> is the information about usage of the license for general
            information purposes*.
            </summary>
            <remarks>
            Currently it is not used for anything else.  In later version of Open License this
            information may be passed back to a License Server to support tracking License
            Statistics.
            </remarks>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.AbstractLicenseData">AbstractLicenseData</seealso>
        </member>
        <member name="M:OpenLicense.LicenseFile.Statistics.FromXml(System.String)">
            <summary>
            This is a static method that creates an <c>Statistics</c> object from the passed in XML
            <see cref="T:System.String">String</see>.
            </summary>
            <param>
            The <see cref="T:System.String">String</see> representing the Xml data.
            </param>
            <returns>
            The <c>Statistics</c> object created from parsing this
            <see cref="T:System.String">String</see>.
            </returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.Statistics.FromXml(System.Xml.XmlNode)">
            <summary>
            This is a static method that creates an <c>Statistics</c> object from a
            <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </summary>
            <param>
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the <c>Statistics</c> object.
            </param>
            <returns>
            The <c>Statistics</c> object created from this <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the license data is null.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.Statistics.#ctor">
            <summary>
            This initializes an empty <c>Statistics</c> object.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Statistics.#ctor(System.Int32)">
            <summary>
            This initializes a <c>Statistics</c> object with the passed in value.
            </summary>
            <param name="access">
            The account count to initialize this object with.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Statistics.#ctor(System.Int32,System.Int32)">
            <summary>
            This initializes a <c>Statistics</c> object with the passed in values.
            </summary>
            <param name="access">
            The account count to initialize this object with.
            </param>
            <param name="days">
            The day count to initialize this object with.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Statistics.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            This initializes a <c>Statistics</c> object with the passed in values.
            </summary>
            <param name="access">
            The account count to initialize this object with.
            </param>
            <param name="days">
            The day count to initialize this object with.
            </param>
            <param name="usage">
            The usage count to initialize this object with.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Statistics.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            This initializes a <c>Statistics</c> object with the passed in values.
            </summary>
            <param name="access">
            The account count to initialize this object with.
            </param>
            <param name="days">
            The day count to initialize this object with.
            </param>
            <param name="usage">
            The usage count to initialize this object with.
            </param>
            <param name="hits">
            The hit count to initialize this object with.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Statistics.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.DateTime)">
            <summary>
            This initializes a <c>Statistics</c> object with the passed in values.
            </summary>
            <param name="access">
            The account count to initialize this object with.
            </param>
            <param name="days">
            The day count to initialize this object with.
            </param>
            <param name="usage">
            The usage count to initialize this object with.
            </param>
            <param name="hits">
            The hit count to initialize this object with.
            </param>
            <param name="dateAccessed">
            The DateTime value to initialize this objects last access time with.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.Statistics.ToXmlString">
            <summary>
            This creates a <see cref="T:System.String">String</see> representing the
            XML form for this <c>Statistics</c> object.
            </summary>
            <returns>
            The <see cref="T:System.String">String</see> representing this <c>Statistics</c> in it's XML form.
            </returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.Statistics.ResetUserStatistics">
            <summary>
            This resets the statical information that should only be set by the user.  The
            creator of the lilcense shouldn't effect these values.  This is primarily used 
            by Open License Builder.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Statistics.IncrementUsageUsed">
            <summary>
            This increments the total number of uses for this license by one.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Statistics.IncrementDaysUsed">
            <summary>
            This increments the total number of days this license has been used by
            one.  They day will only incremented when a new day has occurred.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Statistics.IncrementHitCount">
            <summary>
            This increments the total number of hits for this license by one.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Statistics.IncrementAccessCount">
            <summary>
            This increments the total number of accesses for this license by one.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.Statistics.UpdateLastAccessDate">
            <summary>
            This updates the LastAccess date.
            </summary>
        </member>
        <member name="P:OpenLicense.LicenseFile.Statistics.AccessCount">
            <summary>
            Gets the number of times the license has been accessed.
            </summary>
            <returns>
            Gets the number of times the license has been accessed.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Statistics.HitCount">
            <summary>
            Gets the number of times the license has been accessed. Generally used in web service environments.
            </summary>
            <returns>
            Gets the number of times the license has been accessed. Generally used in web service environments
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Statistics.DaysCount">
            <summary>
            Gets the number of days this license has been used.
            </summary>
            <returns>
            Gets the number of days this license has been used.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Statistics.UsageCount">
            <summary>
            Gets the number of uses this license has had.
            </summary>
            <returns>
            Gets the number of uses this license has had.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.Statistics.DateTimeLastAccessed">
            <summary>
            Gets the last time this license was accessed.
            </summary>
            <returns>
            Gets the last time this license was accessed.
            </returns>
        </member>
        <member name="T:OpenLicense.LicenseFile.User">
            <summary>
            The <c>User</c> object inherits from the <see cref="T:OpenLicense.LicenseFile.AbstractLicenseData"/>.  The
            <c>User</c> is the information about the owner of the license.  It
            contains the name, email and organization of the individual or company who purchased
            the license.
            </summary>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.AbstractLicenseData">AbstractLicenseData</seealso>
        </member>
        <member name="M:OpenLicense.LicenseFile.User.FromXml(System.String)">
            <summary>
            This is a static method that creates an <c>User</c> from the passed in XML
            <see cref="T:System.String">String</see>.
            </summary>
            <param>
            The <see cref="T:System.String">String</see> representing the Xml data.
            </param>
            <returns>
            The <c>User</c> created from parsing this <see cref="T:System.String">String</see>.
            </returns>
        </member>
        <member name="M:OpenLicense.LicenseFile.User.FromXml(System.Xml.XmlNode)">
            <summary>
            This is a static method that creates an <c>User</c> from a <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </summary>
            <param>
            A <see cref="T:System.Xml.XmlNode">XmlNode</see> representing the <c>User</c>.
            </param>
            <returns>
            The <c>User</c> created from this <see cref="T:System.Xml.XmlNode">XmlNode</see>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the license data is null.
            </exception>
        </member>
        <member name="M:OpenLicense.LicenseFile.User.#ctor">
            <summary>
            This initializes an empty <c>User</c> object.
            </summary>
        </member>
        <member name="M:OpenLicense.LicenseFile.User.#ctor(System.String)">
            <summary>
            This initializes a <c>User</c> object with the passed in values.
            </summary>
            <param name="name">
            The name of the <c>User</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.User.#ctor(System.String,System.String)">
            <summary>
            This initializes a <c>User</c> object with the passed in values.
            </summary>
            <param name="name">
            The name of the <c>User</c>.
            </param>
            <param name="email">
            The email address of the <c>User</c>.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.User.#ctor(System.String,System.String,System.String)">
            <summary>
            This initializes a <c>User</c> object with the passed in values.
            </summary>
            <param name="name">
            The name of the <c>User</c>.
            </param>
            <param name="email">
            The email address of the <c>User</c>.
            </param>
            <param name="organization">
            The organization the <c>User</c> belongs to.
            </param>
        </member>
        <member name="M:OpenLicense.LicenseFile.User.ToXmlString">
            <summary>
            This creates a <see cref="T:System.String">String</see> representing the
            XML form for this <c>User</c>.
            </summary>
            <returns>
            The <see cref="T:System.String">String</see> representing this <c>User</c> in it's XML form.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.User.Name">
            <summary>
            Gets or Sets the name of the <c>User</c> who owns this license.
            </summary>
            <param>
            Sets the name of the <c>User</c> who owns this license.
            </param>
            <returns>
            Gets the name of the <c>User</c> who owns this license.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.User.Email">
            <summary>
            Gets or Sets the email address of the <c>User</c> who owns this license.
            </summary>
            <param>
            Sets the email address of the <c>User</c> who owns this license.
            </param>
            <returns>
            Gets the email address of the <c>User</c> who owns this license.
            </returns>
        </member>
        <member name="P:OpenLicense.LicenseFile.User.Organization">
            <summary>
            Gets or Sets the organization/company of the <c>User</c> who owns purchased this license.
            </summary>
            <param>
            Gets the organization/company of the <c>User</c> who owns purchased this license.
            </param>
            <returns>
            Sets the organization/company of the <c>User</c> who owns purchased this license.
            </returns>
        </member>
        <member name="T:OpenLicense.OpenLicenseProvider">
            <summary>
            This is the core piece to Open License.  It is the piece that the <c>LicenseManager</c>
            used to validate that a license can be granted to a specific type.  This provider is
            referenced by the process attempting to validate a license.
            </summary>
            <seealso cref="T:System.ComponentModel.LicenseProvider">LicenseProvider</seealso>
            <seealso cref="T:OpenLicense.LicenseFile.OpenLicenseFile">OpenLicenseFile</seealso>
        </member>
        <member name="M:OpenLicense.OpenLicenseProvider.ResetCashe(OpenLicense.LicenseFile.LicenseItem)">
            <summary>
            Removes the instance of <see cref="T:System.Type">Type</see> from the cache. Cache is
            only used in web environments.  This call should only be used if you want to force
            Open License to read the file from the disk.
            </summary>
            <param name="type">
            The <see cref="T:System.Type">Type</see> to remove from the cache.
            </param>
            <remarks>
            It is highly recommended that this never be used in real world environments because
            the cache is where all settings are kept.  Currently as of 0.941 Open License does
            save the license to a file.  So if the cache is reset then the license will never
            expire for Usage type constraints.
            </remarks>
        </member>
        <member name="M:OpenLicense.OpenLicenseProvider.#ctor">
            <summary>
            This is the constructor for the <c>OpenLicenseProvider</c>.
            </summary>
        </member>
        <member name="M:OpenLicense.OpenLicenseProvider.CreateLicense(OpenLicense.LicenseFile.LicenseItem,System.String)">
            <summary>
            Creates a new license based upon the data passed in.
            </summary>
            <param name="type">
            The <see cref="T:System.Type">Type</see> this license is for.
            </param>
            <param name="key">
            They key to generate this license.  The key should be a string in the proper XML format
            of an <c>OpenLicenseFile</c>.
            </param>
        </member>
        <member name="M:OpenLicense.OpenLicenseProvider.CreateEmptyLicense(OpenLicense.LicenseFile.LicenseItem)">
            <summary>
            Creates a new empty license based upon the type passed in.
            </summary>
            <param name="type">
            The <see cref="T:System.Type">Type</see> this license is for.
            </param>
        </member>
        <member name="M:OpenLicense.OpenLicenseProvider.GetLicense(System.ComponentModel.LicenseContext,System.Type,System.Object,System.Boolean)">
            <summary>
            This is responsible for obtaining the license or reporting the error if non is found.
            </summary>
            <param name="context">
            The context this license is for (Run Time or Design Time)
            </param>
            <param name="type">
            The <see cref="T:System.Type">Type</see> this license is for.
            </param>
            <param name="instance">
            The instance of an object requesting the license.
            </param>
            <param name="allowExceptions">
            True if an exception should be thrown. Otherwise false
            </param>
            <exception name="LicenseException">
            <p>The reason the validation failed.</p>
            </exception>
        </member>
        <member name="M:OpenLicense.OpenLicenseProvider.GetLicenseFromPaths(System.String,OpenLicense.LicenseFile.LicenseItem,System.String)">
            <summary>
            Obtains a license from a preset set of paths.  The paths are defined as:
            <list>
            <item>Application start path</item>
            <item>The Application Bin directory</item>
            </list>
            If the file doesn't exist then it will return null.
            </summary>
            <param name="licFile">
            The string name of the license file.
            </param>
            <param name="type">
            The <see cref="T:System.Type">Type</see> this license is for.
            </param>
            <param name="key">
            The encryption key to decrypt the license stream.  Empty Sting if not encrypted.
            </param>
            <returns>
            A valid license file if found.  Otherwise null if an error occurs or the license file could
            not be found.
            </returns>
        </member>
        <member name="M:OpenLicense.OpenLicenseProvider.GetEmbeddedLicense(System.String,OpenLicense.LicenseFile.LicenseItem,System.String)">
            <summary>
            Obtains a license embedded into the Assembly. It checks the running assembly
            to see if the license has been embedded.  If the file doesn't exist then it
            will return null.
            </summary>
            <param name="licFile">
            The string name of the license file.
            </param>
            <param name="type">
            The <see cref="T:System.Type">Type</see> this license is for.
            </param>
            <param name="key">
            The encryption key to decrypt the license stream.  Empty Sting if not encrypted.
            </param>
            <returns>
            A valid license file if found.  Otherwise null if an error occurs or the license file could
            not be found.
            </returns>
        </member>
        <member name="M:OpenLicense.OpenLicenseProvider.ValidateLicense(OpenLicense.LicenseFile.OpenLicenseFile)">
            <summary>
            Validate this license against the defined <see cref="T:OpenLicense.LicenseFile.IConstraint">IConstraints</see> in the
            Constraints List (System.Collections.Generic.List).
            </summary>
            <param name="license">
            The <see cref="T:OpenLicense.LicenseFile.OpenLicenseFile"/> to validate.
            </param>
            <returns>
            <c>True</c> if the license is valid; Otherwise <c>False</c>.
            </returns>
        </member>
        <member name="M:OpenLicense.OpenLicenseProvider.SaveLicenseFile(OpenLicense.LicenseFile.OpenLicenseFile,System.String,System.Boolean)">
            <summary>
            This saves the license in the proper location.
            </summary>
            <param name="licenseFile">
            The license file to save.
            </param>
            <param name="key">
            The encryption key to use for encrypting the license.  If empty string then no encryption will be used.
            </param>
            <param name="useIsolatedStorage">
            Save to IsolatedStorage if true. Otherwise use path.
            </param>
        </member>
        <member name="M:OpenLicense.OpenLicenseProvider.GenerateIsolatedFileName(System.String)">
            <summary>
            Returns the hash key based upon the passed in string.
            </summary>
            <param name="fileName">
            The string to generate the Hash key for.
            </param>
            <returns>
            The generated hash key as a <see cref="T:System.String">String</see>.
            </returns>
        </member>
        <member name="M:OpenLicense.OpenLicenseProvider.GetFilePath(System.String)">
            <summary>
            The path to a license file based on the license name.
            </summary>
            <param name="licenseFile">
            The name of the license file to attempt to find.
            </param>
            <returns>
            The path appended with the file name where the license was found.  Otherwise an
            empty string is returned.
            </returns>
        </member>
        <member name="M:OpenLicense.OpenLicenseProvider.BuildExceptionString(System.Type)">
            <summary>
            Used to build an exception string with the Helper Attributes data
            if it exists.
            </summary>
            <param name="type">
            The object type that the exception occurred for.
            </param>
        </member>
        <member name="P:OpenLicense.OpenLicenseProvider.EncryptionKey">
            <summary>
            Encryption key for the license file.
            </summary>
        </member>
        <member name="P:OpenLicense.OpenLicenseProvider.LicenseCollector">
            <summary>
            Gets the LicenseCollector from the current location.  Used to access the proper context
            for the License Collection.
            </summary>
        </member>
        <member name="T:OpenLicense.OpenLicenseProvider.OpenLicenseCollector">
            <summary>
            This is a collection of Licenses used internally by the provider when caching
            license files.
            </summary>
        </member>
        <member name="M:OpenLicense.OpenLicenseProvider.OpenLicenseCollector.AddLicense(OpenLicense.LicenseFile.LicenseItem,OpenLicense.LicenseFile.OpenLicenseFile)">
            <summary>
             This adds a new license to the collector.
             </summary>
             <param name="type">
             The <see cref="T:System.Type">Type</see> of this object to create the license for.
             </param>
             <param name="license">
             The license to add.
             </param>
             <exception name="ArgumentNullException">
             <p>Thrown if the license or type value are null</p>
             </exception>
        </member>
        <member name="M:OpenLicense.OpenLicenseProvider.OpenLicenseCollector.GetLicense(OpenLicense.LicenseFile.LicenseItem)">
            <summary>
             This gets the license for the given <see cref="T:System.Type">Type</see>.
             </summary>
             <param>
             The <see cref="T:System.Type">Type</see> to get the license for.
             </param>
             <exception name="ArgumentNullException">
             <p>Thrown if the type value are null</p>
             </exception>
        </member>
        <member name="M:OpenLicense.OpenLicenseProvider.OpenLicenseCollector.RemoveLicense(OpenLicense.LicenseFile.LicenseItem)">
            <summary>
             This removes the license for the given <see cref="T:System.Type">Type</see>.
             </summary>
             <param>
             The <see cref="T:System.Type">Type</see> to remove.
             </param>
             <exception name="ArgumentNullException">
             <p>Thrown if the type value are null</p>
             </exception>
        </member>
        <member name="T:OpenLicense.Utilities">
            <summary>
            A set of static functions to support different functionality throughout Open License 
            that is shared.
            </summary>
        </member>
        <member name="M:OpenLicense.Utilities.CreateCryptoServiceProvider(System.String)">
            <summary>
            This creates the Crypto Service Provider for an encryption stream.  This 
            also handles setting up the key for the provider and validating it is 
            the proper length.  If it is not the proper length it will be padded 
            to the correct size.
            </summary>
            <param name="key">
            The sting to be used as the encryption Key and IV.
            </param>
            <returns>
            The RijndaelManaged to be use as the Encryption Provider.
            </returns>
        </member>
        <member name="M:OpenLicense.Utilities.WriteDebugOutput(System.String)">
            <summary>
            Writes debug output to trace calls in the web environment... To be deleted
            and replace with the <see cref="T:System.Diagnostics.Debug">Debug</see> Class.
            </summary>
            <param name="str">
            The string to output to the screen
            </param>
        </member>
        <member name="M:OpenLicense.Utilities.GetIdentifier(System.Type)">
            <summary>
            Map type to one unique string.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:OpenLicense.Utilities.CheckStringForInvalidFileNameCharacters(System.String)">
            <summary>
            This will remove any unusable characters in strings which can not be 
            used as file names.
            </summary>
            <param name="str">
            The string to check
            </param>
            <returns>
            The resulting string
            </returns>
        </member>
        <member name="T:UIShell.OSGi.ServiceTracker`1">
            <summary>
            服务跟踪对象是获取服务的辅助类，它用于获取并实时跟踪服务的变化事情，一旦
            服务产生变化，则动态更新服务的实例。
            </summary>
            <typeparam name="TServiceInterface">服务的接口类型。</typeparam>
            <example>
            <para>以下代码是使用该类型的示例。在这里，你使用服务时，不再需要关心服务是否发生了变更或者为空。如果服务变更了会自动更新，如果服务为空，则可以设置抛出“服务不可用”的异常。</para>
            <code>
            <![CDATA[
            using(ServiceTracker<IMyService> myService = new ServiceTracker<IMyService>(bundleContext))
            {
                myService.DefaultOrFirstService.SayHello();
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:UIShell.OSGi.ServiceTracker`1.#ctor(UIShell.OSGi.IBundleContext)">
            <summary>
            创建一个服务跟踪对象。当服务不可用时，抛出异常。
            </summary>
            <param name="context">消费服务的模块上下文。</param>
        </member>
        <member name="M:UIShell.OSGi.ServiceTracker`1.#ctor(UIShell.OSGi.IBundleContext,System.Boolean)">
            <summary>
             创建一个服务跟踪对象。
            </summary>
            <param name="context">消费服务的模块上下文。</param>
            <param name="throwsExceptionIfServiceNotFound">当服务不可用时，是否抛出异常。</param>
        </member>
        <member name="M:UIShell.OSGi.ServiceTracker`1.Dispose">
            <summary>
            取消服务变更事件订阅，清空实例引用。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.ServiceTracker`1.BundleContext">
            <summary>
            所在的插件上下文。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.ServiceTracker`1.IsServiceAvailable">
            <summary>
            是否存在可用的服务。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.ServiceTracker`1.DefaultOrFirstService">
            <summary>
            默认服务实例。如果设置抛出异常，则当服务为空时，会抛出“服务不可用的异常”。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.ServiceTracker`1.ServiceInstances">
            <summary>
            所有服务实例。如果设置抛出异常，则当服务列表为空时，会抛出“服务不可用的异常”。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Extension">
            <summary>
            表示一个扩展信息。
            </summary>
            <remarks>
            有关Extension的使用方法，请查看<see cref="T:UIShell.OSGi.ExtensionPoint"/>的例子。
            </remarks>
            <seealso cref="T:UIShell.OSGi.ExtensionPoint"/>
        </member>
        <member name="M:UIShell.OSGi.Extension.#ctor">
            <summary>
            新建一个扩展。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Extension.Owner">
            <summary>
            所在的Bundle。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Extension.Data">
            <summary>
            扩展信息。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.ExtensionEventArgs">
            <summary>
            扩展事件参数，用于跟踪扩展的添加与修改。
            </summary>
            <remarks>
            有关ExtensionEventArgs的使用方法，请查看<see cref="T:UIShell.OSGi.ExtensionPoint"/>的例子。
            </remarks>
            <seealso cref="T:UIShell.OSGi.ExtensionPoint"/>
        </member>
        <member name="P:UIShell.OSGi.ExtensionEventArgs.ExtensionManager">
            <summary>
            扩展管理器。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.ExtensionEventArgs.Action">
            <summary>
            扩展变更操作类别。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.ExtensionEventArgs.ExtensionPoint">
            <summary>
            对应的扩展点。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.ExtensionEventArgs.Extension">
            <summary>
            产生这个事件的扩展实例。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.ExtensionEventArgs.Bundle">
            <summary>
            触发这个事件的Bundle。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.ExtensionPointEventArgs">
            <summary>
            扩展点事件参数，用于跟踪扩展点添加与删除。
            </summary>
            <remarks>
            有关ExtensionPointEventArgs的使用方法，请查看<see cref="T:UIShell.OSGi.ExtensionPoint"/>的例子。
            </remarks>
            <seealso cref="T:UIShell.OSGi.ExtensionPoint"/>
        </member>
        <member name="P:UIShell.OSGi.ExtensionPointEventArgs.ExtensionManager">
            <summary>
            扩展管理器。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.ExtensionPointEventArgs.ExtensionPoint">
            <summary>
            对应的扩展点事件。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.ExtensionPointEventArgs.Action">
            <summary>
            扩展点变更操作类别。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.ExtensionPointEventArgs.Bundle">
            <summary>
            触发这个事件的Bundle。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.ExtensionPoint">
            <summary>
            扩展点。该框架提供了基于ExtensionPoint和Extension的插件扩展技术，
            他们通过Manifest.xml的ExtensionPoint和Extension XML节点配置。
            一个待扩展的插件通过向其它插件暴露扩展点，并监听扩展变化，从而
            处理扩展信息。
            </summary>
            <example>
            <para>该平台利用ExtensionPoint和Extension技术来实现插件的动态的松耦合扩展，
            它们分别表示一个可以被扩展的信息和一个扩展。
            </para>
            <para>一个想要被其它插件扩展的插件
            通过在Manifest.xml的<![CDATA[<ExtensionPoint />]]>XML节点声明一个扩展点，并且
            在插件的实现中处理其它插件对其的扩展，每一个<![CDATA[<ExtensionPoint />]]>XML节点
            最终会转换成一个ExtensionPoint对象，可以通过IBundleActivator的Start/Stop方法中的
            IBundleContext context中获取。
            </para>
            <para>
            一个模块对另一个模块的扩展则通过在Manifest.xml的<![CDATA[<Extension />]]>XML节点
            声明对其它模块暴露的扩展点的扩展。每一个<![CDATA[<Extension />]]>XML节点
            最终会转换成一个Extension对象，可以通过IBundleActivator的Start/Stop方法中的
            IBundleContext context中获取。
            </para>
            <para>
            下面实现了一个示例，ShellPlugin实现一个带有一个菜单栏的空的Windows窗体，它向
            其它插件暴露了一个名为“ShellPlugin.MenuStrip”的扩展点，用于实现其它插件可以动态
            的在这个空的窗体上创建菜单；而AppPlugin1和AppPlugin2则是两个扩展了该扩展点的插件。
            </para>
            <para>
            1 建立一个控制台宿主，在“应用程序”选项卡将其“输出类型”属性修改为“Windows应用程序”，然后修改Program.cs。
            <code>
            using System;
            using System.Collections.Generic;
            using System.Linq;
            using System.Text;
            using UIShell.OSGi;
            using System.Windows.Forms;
            
            namespace WinFormShell
            {
                class Program
                {
                    [STAThread]
                    static void Main(string[] args)
                    {
                        Application.EnableVisualStyles();
                        Application.SetCompatibleTextRenderingDefault(false);
            
                        using (BundleRuntime bundleRuntime = new BundleRuntime())
                        {
                            bundleRuntime.Start();
            
                            // 获取Form服务，并运行。
                            Form mainForm = bundleRuntime.GetFirstOrDefaultService<![CDATA[<Form>]]>();
            
                            if (mainForm != null)
                            {
                                Application.Run(mainForm);
                            }
                        }
                    }
                }
            }
            </code>
            </para>
            <para>
            2 建立一个WinForm插件，该插件名称为ShellPlugin，用于提供一个带有菜单栏的主窗体。这个插件还向其它
            插件暴露一个ShellPlugin.MenuStrip的扩展点，使得其它插件可以通过声明扩展方式向这个主窗体注册菜单项。
            </para>
            <para>
            2.1 修改Manifest.xml设置StartLevel为2，并添加一个ExtensionPoint<![CDATA[<ExtensionPoint Point="ShellPlugin.MenuStrip" />]]>，如下。
            </para>
            
            <code>
            <![CDATA[
            <?xml version="1.0" encoding="utf-8"?>
            <Bundle xmlns="urn:uiosp-bundle-manifest-2.0" Name="ShellPlugin" SymbolicName="ShellPlugin" Version="1.0.0.0" InitializedState="Active" StartLevel="2">
              <Activator Type="ShellPlugin.Activator" Policy="Immediate" />
              <Runtime>
                <Assembly Path="bin\ShellPlugin.dll" Share="false" />
              </Runtime>
              <ExtensionPoint Point="ShellPlugin.MenuStrip" />
            </Bundle>
            ]]>
            </code>
            
            <para>
            2.2 创建一个Form，并命名为MainForm。向该窗体添加一个MenuStrip控件。
            </para>
            <para>
            2.3 更新Activator.cs如下：
            </para>
            <code>
            using System;
            using System.Collections.Generic;
            using System.Linq;
            using System.Text;
            using UIShell.OSGi;
            using System.Windows.Forms;
            
            namespace ShellPlugin
            {
                internal delegate void CloseFormDelegate();
            
                public class Activator : IBundleActivator
                {
                    private MainForm MainForm { get; set; }
                    private MenuStripExtHandler MenuStripExtHandler { get; set; }
            
                    public void Start(IBundleContext context)
                    {
                        // Create a MainFrom and register it as a Service.
                        MainForm = new MainForm();
                        context.AddService<![CDATA[<Form>]]>(MainForm);
            
                        // Listen the extension changed.
                        MenuStripExtHandler = new MenuStripExtHandler(context.Bundle, MainForm);
                    }
            
                    public void Stop(IBundleContext context)
                    {
                        context.RemoveService<![CDATA[<Form>]]>(MainForm);
            
                        MenuStripExtHandler.Dispose();
            
                        CloseFormDelegate closeFormDel = delegate()
                        {
                            MainForm.Close();
                        };
            
                        if (!MainForm.IsDisposed)
                        {
                            MainForm.BeginInvoke(closeFormDel);
                        }
                    }
                }
            }
            </code>
            <para>
            2.4 创建一个MenuStripExtHandler类，该类将处理扩展并监听扩展信息变化事件，从而更新MainForm的界面。
            </para>
            <code>
            using System;
            using System.Collections.Generic;
            using System.Linq;
            using System.Text;
            using UIShell.OSGi;
            using System.Windows.Forms;
            using System.Xml;
            
            namespace ShellPlugin
            {
                /// <![CDATA[<summary>]]>
                /// 处理菜单扩展点。
                /// <![CDATA[</summary>]]>
                class MenuStripExtHandler : IDisposable
                {
                    private const string SHELL_MENUSTRIP_EXTENSION = "ShellPlugin.MenuStrip";
            
                    private IBundle Bundle { get; set; }
                    private MainForm MainForm { get; set; }
                    private Dictionary<![CDATA[<Extension, List<ToolStripMenuItem>>]]> ExtensionMenuItemsMap { get; set; }
                    private MenuStripXmlConvertor MenuStripConvertor { get; set; }
            
                    public MenuStripExtHandler(IBundle bundle, MainForm mainForm)
                    {
                        Bundle = bundle;
                        MainForm = mainForm;
                        ExtensionMenuItemsMap = new Dictionary<![CDATA[<Extension, List<ToolStripMenuItem>>]]>();
                        MenuStripConvertor = new MenuStripXmlConvertor(mainForm);
                        IBundleContext context = Bundle.Context;
                        if (context != null)
                        {
                            HandleMenuStripExtensionPoint();
                            context.ExtensionChanged += ExtensionChanged;
                        }
                    }
            
                    /// <![CDATA[<summary>]]>
                    /// 处理MenuStrip扩展点。
                    /// <![CDATA[</summary>]]>
                    private void HandleMenuStripExtensionPoint()
                    {
                        IBundleContext context = Bundle.Context;
                        if (context == null)
                        {
                            return;
                        }
                        // 获取所有扩展。
                        List<![CDATA[<Extension>]]> menuStripExtensions = context.GetExtensions(SHELL_MENUSTRIP_EXTENSION);
                        if (menuStripExtensions != null)
                        {
                            List<![CDATA[<ToolStripMenuItem>]]> menuItems = new List<![CDATA[<ToolStripMenuItem>]]>();
                            List<![CDATA[<ToolStripMenuItem>]]> menuItemsOfExtension;
                            foreach (Extension menuStripExtension in menuStripExtensions)
                            {
                                menuItemsOfExtension = MenuStripConvertor.CreateMenuItemForExtension(menuStripExtension);
                                ExtensionMenuItemsMap[menuStripExtension] = menuItemsOfExtension;
                                // 为每一个扩展创建MenuItem。
                                menuItems.AddRange(menuItemsOfExtension);
                            }
                            // 将所有扩展的MenuItem添加到菜单栏。
                            MainForm.MainMenuStrip.Items.AddRange(menuItems.ToArray());
                        }
                    }
            
                    /// <![CDATA[<summary>]]>
                    /// 监听扩展点变化，如果扩展点被删除，则相应的删除菜单项；如果扩展点增加，则相应增加菜单项。
                    /// <![CDATA[</summary>]]>
                    private void ExtensionChanged(object sender, ExtensionEventArgs e)
                    {
                        if (MainForm.IsDisposed || MainForm.MainMenuStrip == null)
                        {
                            return;
                        }
                        if (e.ExtensionPoint.Equals(SHELL_MENUSTRIP_EXTENSION))
                        {
                            List<![CDATA[<ToolStripMenuItem>]]> menuItemsOfExtension = null;
                            if (e.Action == CollectionChangedAction.Add)
                            {
                                menuItemsOfExtension = MenuStripConvertor.CreateMenuItemForExtension(e.Extension);
                                if (menuItemsOfExtension != null)
                                {
                                    ExtensionMenuItemsMap[e.Extension] = menuItemsOfExtension;
                                    MainForm.MainMenuStrip.Items.AddRange(menuItemsOfExtension.ToArray());
                                }
                            }
                            else if (e.Action == CollectionChangedAction.Remove)
                            {
                                menuItemsOfExtension = ExtensionMenuItemsMap[e.Extension];
                                if (menuItemsOfExtension != null)
                                {
                                    menuItemsOfExtension.ForEach(menuItem =&gt; MainForm.MainMenuStrip.Items.Remove(menuItem));
                                }
                            }
                        }
                    }
            
                    /// <![CDATA[<summary>]]>
                    /// 取消事件监听。
                    /// <![CDATA[</summary>]]>
                    public void Dispose()
                    {
                        IBundleContext context = Bundle.Context;
                        if (context != null)
                        {
                            context.ExtensionChanged -= ExtensionChanged;
                        }
                    }
                }
            }
            </code>
            <para>
            2.5 创建一个MenuStripXmlConvertor类，该类用于处理扩展的XML元素，并将其转换成MenuStrip对象。
            </para>
            <code>
            using System;
            using System.Collections.Generic;
            using System.Linq;
            using System.Text;
            using UIShell.OSGi;
            using System.Windows.Forms;
            using System.Xml;
            
            namespace ShellPlugin
            {
                /// <![CDATA[<summary>]]>
                /// 该类的功能就是将XML扩展电转换成MainForm的菜单项。
                /// <![CDATA[</summary>]]>
                class MenuStripXmlConvertor
                {
                    private MainForm MainForm { get; set; }
            
                    public MenuStripXmlConvertor(MainForm mainForm)
                    {
                        MainForm = mainForm;
                    }
            
                    /// <![CDATA[<summary>]]>
                    /// 为一个Extension创建菜单项。
                    /// <![CDATA[</summary>]]>
                    /// <![CDATA[<param name="menuStripExtension">菜单项Extension。</param>]]>
                    /// <![CDATA[<returns>菜单列表。</returns>]]>
                    public List<![CDATA[<ToolStripMenuItem>]]> CreateMenuItemForExtension(Extension menuStripExtension)
                    {
                        List<![CDATA[<ToolStripMenuItem>]]> menuItems = new List<![CDATA[<ToolStripMenuItem>]]>();
                        List<![CDATA[<XmlNode>]]> nodes = menuStripExtension.Data;
                        ToolStripMenuItem menuItem;
                        if (nodes != null)
                        {
                            foreach (XmlNode node in nodes)
                            {
                                if (node is XmlAttribute)
                                {
                                    continue;
                                }
            
                                menuItem = CreateMenuItemForXmlNode(menuStripExtension, node);
                                if (menuItem != null)
                                {
                                    menuItems.Add(menuItem);
                                }
                            }
                        }
                        return menuItems;
                    }
            
                    /// <![CDATA[<summary>]]>
                    /// 为一个XmlNode创建一个菜单项。
                    /// <![CDATA[</summary>]]>
                    /// <![CDATA[<param name="menuStripExtension">扩展信息。</param>]]>
                    /// <![CDATA[<param name="node">XML节点。</param>]]>
                    /// <![CDATA[<returns>菜单项。</returns>]]>
                    public ToolStripMenuItem CreateMenuItemForXmlNode(Extension menuStripExtension, XmlNode node)
                    {
                        ToolStripMenuItem menuItem = ConvertXmlNodeToMenuItem(node);
                        if (menuItem != null)
                        {
                            CreateChildMenuItemForXmlNode(menuStripExtension, menuItem, node);
                        }
            
                        return menuItem;
                    }
                    /// <![CDATA[<summary>]]>
                    /// 为一个XML节点的子节点创建相应的子菜单。
                    /// <![CDATA[</summary>]]>
                    /// <![CDATA[<param name="menuStripExtension">扩展信息。</param>]]>
                    /// <![CDATA[<param name="menuItem">父菜单项。</param>]]>
                    /// <![CDATA[<param name="node">父XML节点。</param>]]>
                    public void CreateChildMenuItemForXmlNode(Extension menuStripExtension, ToolStripMenuItem menuItem, XmlNode node)
                    {
                        if (menuItem == null || menuStripExtension == null || node == null)
                        {
                            return;
                        }
            
                        ToolStripMenuItem childMenuItem;
                        foreach (XmlNode childNode in node.ChildNodes)
                        {
                            childMenuItem = ConvertXmlNodeToMenuItem(childNode);
                            if (childMenuItem != null)
                            {
                                menuItem.DropDownItems.Add(childMenuItem);
                                CreateChildMenuItemForXmlNode(menuStripExtension, childMenuItem, childNode);
                            }
                        }
                    }
                    /// <![CDATA[<summary>]]>
                    /// 将一个单独的XML节点转换成菜单项。
                    /// <![CDATA[</summary>]]>
                    /// <![CDATA[<param name="node">XML节点。</param>]]>
                    /// <![CDATA[<returns>对应的菜单项。</returns>]]>
                    public ToolStripMenuItem ConvertXmlNodeToMenuItem(XmlNode node)
                    {
                        if (node is XmlAttribute)
                        {
                            return null;
                        }
                        ToolStripMenuItem menuItem = new ToolStripMenuItem();
                        if (node.Attributes["Name"] != null)
                        {
                            menuItem.Name = node.Attributes["Name"].Value;
                        }
                        if (node.Attributes["Text"] != null)
                        {
                            menuItem.Text = node.Attributes["Text"].Value;
                        }
                        return menuItem;
                    }
                }
            }
            </code>
            <para>2.6 创建2个WinForm插件，修改第一个Manifest.xml添加如下扩展：</para>
            <code>
            <![CDATA[
            <Extension Point="ShellPlugin.MenuStrip">
              <MenuStripItem Name="item1" Text="TopMenuOfPlugin1">
                <MenuStripItem Name="item11" Text="SecondMenu1OfPlugin1" />
                <MenuStripItem Name="item12" Text="SecondMenu2OfPlugin1" />
              </MenuStripItem>
            </Extension>
            ]]>
            </code>
            <para>修改第二个Manifest.xml添加如下扩展：</para>
            <code>
            <![CDATA[
            <Extension Point="ShellPlugin.MenuStrip">
              <MenuStripItem Name="item2" Text="TopMenuOfPlugin2">
                <MenuStripItem Name="item21" Text="SecondMenu1OfPlugin2" />
                <MenuStripItem Name="item22" Text="SecondMenu2OfPlugin3" />
              </MenuStripItem>
            </Extension>
            ]]>
            </code>
            <para>运行该工程后会弹出一个带有两个菜单的Windows窗体。如果打开远程控制台，输入list/stop/start命令还可以查看窗体菜单将随着插件的启动或停止出现或消失。</para>
            </example>
            <seealso cref="T:UIShell.OSGi.Extension"/>
        </member>
        <member name="M:UIShell.OSGi.ExtensionPoint.AddExtension(UIShell.OSGi.Extension)">
            <summary>
            添加一个扩展对象。
            </summary>
            <param name="extension">扩展对象。</param>
        </member>
        <member name="M:UIShell.OSGi.ExtensionPoint.RemoveExtension(UIShell.OSGi.Extension)">
            <summary>
            删除一个扩展对象。
            </summary>
            <param name="extension">扩展对象。</param>
        </member>
        <member name="P:UIShell.OSGi.ExtensionPoint.Owner">
            <summary>
            暴露这个扩展点的Bundle。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.ExtensionPoint.Point">
            <summary>
            扩展点标识。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.ExtensionPoint.Schema">
            <summary>
            验证扩展的XML Schema。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.ExtensionPoint.Extensions">
            <summary>
            这个扩展点的所有扩展。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Core.Service.IExtensionManager">
            <summary>
            扩展点管理服务。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IExtensionManager.AddExtension(System.String,UIShell.OSGi.Extension)">
            <summary>
            向一个扩展点添加一个扩展。
            </summary>
            <param name="point">扩展点标识。</param>
            <param name="extension">扩展对象。</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IExtensionManager.RemoveExtension(UIShell.OSGi.Extension)">
            <summary>
            删除一个扩展对象。
            </summary>
            <param name="extension">扩展对象。</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IExtensionManager.GetExtensions(System.String)">
            <summary>
            获取指定扩展点的所有扩展。
            </summary>
            <param name="extensionPoint">扩展点标识。</param>
            <returns>扩展列表。</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IExtensionManager.GetExtensionPoints">
            <summary>
            获取所有扩展点对象。
            </summary>
            <returns>扩展点对象列表。</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IExtensionManager.GetExtensionPoints(UIShell.OSGi.IBundle)">
            <summary>
            获取指定模块的所有扩展点。
            </summary>
            <param name="bundle">指定模块对象。</param>
            <returns>指定模块的扩展点对象。</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IExtensionManager.GetExtensionPoint(System.String)">
            <summary>
            获取指定扩展点。
            </summary>
            <param name="point">扩展点标识。</param>
            <returns>扩展点对象。</returns>
        </member>
        <member name="E:UIShell.OSGi.Core.Service.IExtensionManager.ExtensionChanged">
            <summary>
            扩展变更事件。
            </summary>
        </member>
        <member name="E:UIShell.OSGi.Core.Service.IExtensionManager.ExtensionPointChanged">
            <summary>
            扩展点变更事件。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IBundleFactory.CreateBundle(UIShell.OSGi.Configuration.BundleManifest.BundleData)">
            <summary>
            根据BundleData创建IBundle，如HostBundle,FragementBundle
            </summary>
            <param name="bundleData"></param>
            <returns></returns>
        </member>
        <member name="P:UIShell.OSGi.Core.Service.IBundleFactory.InitialBundleId">
            <summary>
            BundleId 的起始数（不包括SystemBundle）
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Core.Service.IBundleFactory.MaxBundleID">
            <summary>
            当前最大的BundleID
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Core.Bundle.AbstractBundle">
            <summary>
            该类将实现所有Bundle的共同操作：
            1 权限检查——在该版本不支持。
            2 生命周期操作加锁和释放锁。
            3 公共属性的实现。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.IBundle">
            <summary>
            Bundle表示由内核创建的一个插件，一般而言，“Bundle=Manifest.xml + 类 + 其它资源”。
            </summary>
            <remarks>
            <para>
            Manifest.xml是插件的清单文件，它由Bundle、Activator、Runtime、Services、ExtensionPoint、Extension和BundleInfo几个配置节组成。以下是一个清单文件的示例。它定义了插件的唯一名称和名称为ShellPlugin，版本1.0.0.0，初始状态为激活，启动级别为2；声明了一个
            ShellPlugin.Activator的激活器，激活方式为立即激活；定义了一个本地程序集bin\ShellPlugin.dll；同时暴露了一个ShellPlugin.MenuStrip
            的扩展点。
            
            <code>
            <![CDATA[
            <?xml version="1.0" encoding="utf-8"?>
            <Bundle xmlns="urn:uiosp-bundle-manifest-2.0" Name="ShellPlugin" SymbolicName="ShellPlugin" Version="1.0.0.0" InitializedState="Active" StartLevel="2">
              <Activator Type="ShellPlugin.Activator" Policy="Immediate" />
              <Runtime>
                <Assembly Path="bin\ShellPlugin.dll" Share="false" />
              </Runtime>
              <ExtensionPoint Point="ShellPlugin.MenuStrip" />
            </Bundle>
            ]]>
            </code>
            
            程序集清单详细描述如下。
            
            <list type="table">
            <listheader>
            <node>节点名称</node>
            <desc>描述</desc>
            <attrs>包含的属性属性</attrs>
            </listheader>
            
            <item>
            <node>Bundle</node>
            <desc>Bundle基本信息描述</desc>
            <attrs>
            <list type="bullet">
            <item>xmlns：定义了清单文件的名字空间，其值为"urn:uiosp-bundle-manifest-2.0"。</item>
            <item>SymbolicName：插件的唯一名称，必填属性。</item>
            <item>Version：插件的版本，比如1.2.0.3，默认为1.0.0.0，可选属性。</item>
            <item>Name：插件的名称，可选属性。</item>
            <item>InitializedState：平台加载插件后，插件处于的默认状态，其默认值为Active，可选属性。</item>
            <item>StartLevel：插件的启动级别，启动级别越小优先级越高，越先被启动，普通插件的启动级别一般小于等于2，可选属性。</item>
            <item>HostBundleSymbolicName：插件的宿主唯一名称，一旦声明了该属性，则当前插件便是一个片段插件。片段插件不能被当成宿主插件来使用，它仅是作为宿主的一部分而存在，在宿主解析时，会自动将片段插件的定义附加到宿主。
            因此片段插件不能定义StartLevel、InitializedState和Activator，且不能从片段加载类或者资源。如果需要加载，必须通过其宿主来实现。</item>
            <item>HostBundleVersion：宿主插件版本约束，可以不填写（版本无关）、固定的版本（1.0.0.0）或者某一范围版本（[1.0, 2.0)）。</item>
            </list>
            </attrs>
            </item>
            
            <item>
            <node>Activator</node>
            <desc>插件激活器信息，可选节点</desc>
            <attrs>
            <list type="bullet">
            <item>Type：插件激活器类型全名称，比如ConsolePlugin1.Activator，该类型必须实现IBundleActivator接口，必填属性。</item>
            <item>Policy：激活策略，Immediate或者Lazy，分别为立即激活或者晚激活。立即激活是指一旦插件执行启动，激活器的Start(IBundleContext context)会被调用并进入Active状态；而晚激活则是一旦插件执行启动，只是将状态变为Starting，而激活器的Start(IBundleContext context)方法会推迟到直到从该插件加载一个类型时才调用，从而进入Active状态。该属性为可选属性。</item>
            </list>
            </attrs>
            </item>
            
            <item>
            <node>Runtime</node>
            <desc>插件运行时信息</desc>
            <attrs>
            运行时信息包括本地程序集和依赖程序集，由Assembly和Dependency两个字节点定义。
            </attrs>
            </item>
            
            <item>
            <node>Assembly</node>
            <desc>插件一个本地程序集声明</desc>
            <attrs>
            由于插件的类型空间与普通程序类型.NET程序不同，插件具有灵活的程序集部署和依赖，并且完全支持晚激活。因此我们需要为每一个本地类库声明一个程序集定义。
            <list type="bullet">
            <item>Path：程序集的路径，可以是相对于插件根目录的路径，也可以是绝对路径，必选属性。</item>
            <item>Share：程序集是否可以被其它插件共享，默认为false，可选属性。</item>
            </list>
            </attrs>
            </item>
            
            <item>
            <node>Dependency</node>
            <desc>插件一个程序集依赖声明，表示该插件引用了另一个插件在Assemly定义的Share为true的程序集。</desc>
            <attrs>
            <list type="bullet">
            <item>BundleSymbolicName：依赖程序集所在的插件唯一名称。</item>
            <item>BundleVersion：依赖程序集所在的插件的版本约束，可以不填写（版本无关）、固定的版本（1.0.0.0）或者某一范围版本（[1.0, 2.0)），可选属性。</item>
            <item>AssemblyName：程序集名称，可选属性，如果没有指明依赖的程序集名称，则意味着依赖指定插件所有程序集。</item>
            <item>AssemblyVersion：程序集版本，可以不填写（版本无关）、固定的版本（1.0.0.0）或者某一范围版本（[1.0, 2.0)），可选属性。</item>
            <item>Resolution：依赖解析方式，Mandatory或者Optional，分别表示依赖必须强制解析成功这个插件才能够被启动、依赖可以解析失败。</item>
            </list>
            </attrs>
            </item>
            
            <item>
            <node>Services</node>
            <desc>服务集合。</desc>
            <attrs>
            由若干Service节点组成。插件可以通过2种方式向其它插件暴露服务：（1）通过Services/Service定义；（2）利用激活器的Start/Stop的参数context的IBundleContext.AddService方法注册服务。
            </attrs>
            </item>
            
            <item>
            <node>Service</node>
            <desc>服务定义。</desc>
            <attrs>
            <list type="bullet">
            <item>Interface：服务的接口全名称，使用“,”分割多个接口，如ConsolePlugin1.IMyService1,ConsolePlugin1.IMyService2。</item>
            <item>Type：服务的实现类型全名称，如ConsolePlugin1.MyService。</item>
            </list>
            </attrs>
            </item>
            
            <item>
            <node>ExtensionPoint</node>
            <desc>暴露的扩展点。</desc>
            <attrs>
            它用于向其它插件暴露扩展点。一般而言，插件扩展需要通过2个步骤实现：（1）在Manifest.xml定义一个扩展点；（2）在插件
            实现通过IBundleContext.ExtensionChanged事件和IBundleContext.GetExtensions获取其它插件对其扩展并进行处理。
            <list type="bullet">
            <item>Point：扩展点名称。</item>
            <item>Schema：扩展XML定义需要遵守的架构。</item>
            </list>
            </attrs>
            </item>
            
            <item>
            <node>Extension</node>
            <desc>扩展定义。</desc>
            <attrs>
            <list type="bullet">
            <item>Point：扩展的扩展点名称。</item>
            </list>
            </attrs>
            </item>
            
            <item>
            <node>BundleInfo</node>
            <desc>插件的详细信息定义，可选节点。</desc>
            <attrs>
            <list type="bullet">
            <item>ManifestVersion：清单版本，为2。</item>
            <item>DocumentLocation：文档位置。</item>
            <item>UpdateLocation：插件更新时下载新插件的地址。</item>
            <item>Category：类别。</item>
            <item>Description：详细描述。</item>
            <item>Author：作者。</item>
            <item>ContactAddress：联系方式称。</item>
            <item>Copyright：版权声明。</item>
            </list>
            </attrs>
            </item>
            
            </list>
            
            </para>
            
            <para>
            使用Visual Studio工程模板创建的默认插件由一个激活器Activator.cs和一个Manifest.xml组成。
            </para>
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.IBundle.Start(UIShell.OSGi.BundleStartOptions)">
            <summary>
            启动一个Bundle。
            </summary>
            <param name="option">启动选项。</param>
            <example>
            <code>
            IBundle bundle = context.GetBundleByName("SimpleModule");
            // 瞬时启动SimpleModule插件，这种启动方式不会对该插件在平台重启后产生影响。
            bundle.Start(BundleStartOptions.Transient); 
            // 或者采用以下方式启动插件，这会使得平台以后重启时自动启动该插件。
            bundle.Start(BundleStartOptions.General); 
            </code>
            </example>
        </member>
        <member name="M:UIShell.OSGi.IBundle.Stop(UIShell.OSGi.BundleStopOptions)">
            <summary>
            停止一个Bundle。
            </summary>
            <param name="option">停止选项，可以是BundleStopOptions.Transient和BundleStopOptions.General，
            前者表示临时停止一个插件，后者表示永久的停止一个插件这意味着下次平台启动后将不再启动该插件。</param>
            <remarks>停止插件的操作和启动相反。</remarks>
        </member>
        <member name="M:UIShell.OSGi.IBundle.Uninstall">
            <summary>
            卸载Bundle。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.IBundle.LoadResource(System.String,UIShell.OSGi.ResourceLoadMode)">
            <summary>
            装载资源。
            </summary>
            <param name="resourceName">资源名称。</param>
            <param name="loadMode">资源装载搜索模式。</param>
            <returns>资源对象。</returns>
            <example>
            <code>
            <![CDATA[
            using System;
            using System.Collections.Generic;
            using UIShell.OSGi;
            using System.Reflection;
            using System.Diagnostics;
            using System.Drawing;
            using System.IO;
            
            namespace SimpleModule
            {
                public class Activator : IBundleActivator
                {
                    public void Start(IBundleContext context)
                    {
                        // 动态加载类型
                        Type sayHelloFromFragmentType = context.Bundle.LoadClass("FragmentModule.SayHelloFromFragment");
                        // 或者也可以通过如下方式实现隐式加载，它由平台对CLR类加载机制扩展而实现上述的加载效果。
                        // FragmentModule.SayHelloFromFragment sayHello = new FragmentModule.SayHelloFromFragment()
                        if (sayHelloFromFragmentType != null)
                        {
                            object sayHello = System.Activator.CreateInstance(sayHelloFromFragmentType);
                            MethodInfo helloMethod = sayHello.GetType().GetMethod("Hello");
                            helloMethod.Invoke(sayHello, new object[] { "FragmentModule." });
            
                            // 动态加载嵌入式的资源。
                            object resourceStream = context.Bundle.LoadResource("SimpleModule.Koala.jpg", ResourceLoadMode.Local);
                            Image image = Image.FromStream((Stream)resourceStream);
                            Debug.Assert(image != null);
                        }
            
                        
                    }
            
                    public void Stop(IBundleContext context)
                    {
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:UIShell.OSGi.IBundle.LoadClass(System.String)">
            <summary>
            加载类型。
            </summary>
            <param name="className">类型全名称。</param>
            <returns>对应的类型。</returns>
            <example>
            <code>
            <![CDATA[
            using System;
            using System.Collections.Generic;
            using UIShell.OSGi;
            using System.Reflection;
            using System.Diagnostics;
            using System.Drawing;
            using System.IO;
            
            namespace SimpleModule
            {
                public class Activator : IBundleActivator
                {
                    public void Start(IBundleContext context)
                    {
                        // 动态加载类型
                        Type sayHelloFromFragmentType = context.Bundle.LoadClass("FragmentModule.SayHelloFromFragment");
                        // 或者也可以通过如下方式实现隐式加载，它由平台对CLR类加载机制扩展而实现上述的加载效果。
                        // FragmentModule.SayHelloFromFragment sayHello = new FragmentModule.SayHelloFromFragment()
                        if (sayHelloFromFragmentType != null)
                        {
                            object sayHello = System.Activator.CreateInstance(sayHelloFromFragmentType);
                            MethodInfo helloMethod = sayHello.GetType().GetMethod("Hello");
                            helloMethod.Invoke(sayHello, new object[] { "FragmentModule." });
            
                            // 动态加载嵌入式的资源。
                            object resourceStream = context.Bundle.LoadResource("SimpleModule.Koala.jpg", ResourceLoadMode.Local);
                            Image image = Image.FromStream((Stream)resourceStream);
                            Debug.Assert(image != null);
                        }
            
                        
                    }
            
                    public void Stop(IBundleContext context)
                    {
                    }
                }
            }
            ]]>
            </code>
            </example>
            <remarks>
            在该平台，每一个插件都有一个单独的类型空间。插件的类型空间表示这个插件可以访问的所有类型
            的集合。它由以下几部分组成：
            <list type="bullet">
            <item>本地程序集：由Manifest.xml的Assembly节点定义，表示该插件一个本地的类库。插件直接依赖的类库
            必须通过Assembly定义。当从插件加载一个类型时，本地程序集是首先匹配的一个地方。</item>
            <item>片段本地程序集：当一个插件的HostSymbolicName定义了，则这个插件是一个片段插件。片段插件是
            作为宿主的一部分而存在的，对外表现只有宿主插件，因此不能从片段加载资源和执行生命周期操作。由于片段
            插件是宿主的部分，因此，其定义的本地程序集也是宿主的类型空间之一，片段的本地程序集是类加载
            匹配的第二个地方。</item>
            <item>
            依赖的程序集：由Manifest.xml的Dependency节点定义，表示该插件依赖另一个插件的程序集，它也是当前插件的
            类型空间之一。当加载类型时，如果类型不在插件的本地程序集和其片段本地程序集，它会尝试从依赖的程序集
            中搜索类型。需要注意的是，如果依赖的程序集没有指定具体的AssemblyName，则相当于依赖一个插件，这样会
            递归执行类型搜索。依赖程序集是执行类型加载的第三个地方。
            </item>
            <item>
            片段依赖的程序集：由该插件的片段插件的Manifest.xml定义，也是该插件类型空间的组成之一，它搜索方式和
            依赖的程序集类似，这是插件类型加载搜索的第四个地方。
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.IBundle.GetBunldeStartLevel">
            <summary>
            获取Bundle的启动级别，越小越先启动，但越后停止。
            </summary>
            <returns>启动级别</returns>
        </member>
        <member name="P:UIShell.OSGi.IBundle.SymbolicName">
            <summary>
            Bundle唯一名称。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.IBundle.Name">
            <summary>
            Bundle的名称。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.IBundle.Version">
            <summary>
            Bundle的版本信息。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.IBundle.State">
            <summary>
            当前状态。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.IBundle.BundleID">
            <summary>
            Bundle的唯一ID。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.IBundle.Location">
            <summary>
            Bundle安装的位置。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.IBundle.Context">
            <summary>
            Bundle当前执行上下文。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.IBundle.StartLevel">
            <summary>
            Bundle启动级别，启动级别越小，越早启动。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.IBundle.BundleType">
            <summary>
            Bundle类型，宿主插件或者片段插件。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Core.Bundle.AbstractBundle._preStarting">
            <summary>
            是否Bundle在启动过程中
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.AbstractBundle.CheckValidState">
            <summary>
            检查是否处在UNINSTALL状态，如果是抛出异常。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.AbstractBundle.Start(UIShell.OSGi.BundleStartOptions)">
            <summary>
            Starts this bundle. 
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.AbstractBundle.GetBunldeStartLevel">
            <summary>
            获取Bundle的启动级别，越小，越先启动，后停止
            </summary>
            <returns>启动级别</returns>
        </member>
        <member name="P:UIShell.OSGi.Core.Bundle.AbstractBundle.BundleID">
            <summary>
            Bundle安装后，由Framework分配的唯一ID。这个ID在Bundle处于安装状态时，
            保持不变。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Core.Bundle.AbstractBundle.Context">
            <summary>
            只有在STARTING、STOPPING和ACTIVE状态下，Bundle才具有执行上下文。
            如果一个Bundle被启动，则必须新建一个上下文；如果一个Bundle被停止，
            则必须销毁这个上下文。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Core.Bundle.BundleContext">
            <summary>
            当Start一个Bundle时，我们将为其创建一个BundleContext并在停止时进行销毁。
            
            BundleContext分为3类操作：
            1 Bundle查询和安装：查询操作将利用Framework的BundleRepository，安装则调用Framework.InstallBundle；
            2 启动和停止：装载激活器进行启动或者停止；
            3 事件监听器：支持Framework和Bundle事件；
            4 清理：清理工作包括事件监听器清理和服务引用，在Bundle被停止后，将执行清理工作。
            
            BundleContext的服务支持在V1.0将不支持。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.IBundleContext">
            <summary>
            IBundleContext表示插件上下文，实现了对内核的反射。
            </summary>
            <example>
            <para>以下例举了IBundleContext的功能。</para>
            <para>1 服务注册与卸载示例。以下示例展示了如何定义一个服务接口、服务，以及如何注册和卸载。</para>
            <para>1.1 服务接口定义</para>
            <code>
            <![CDATA[
            using System;
            using System.Collections.Generic;
            using System.Text;
            
            namespace ServiceContractModule
            {
                public interface ISayHelloService
                {
                    string Hello(string name);
                }
            }
            ]]>
            </code>
            <para>1.2 服务注册与卸载</para>
            <code>
            <![CDATA[
            using System;
            using System.Collections.Generic;
            using UIShell.OSGi;
            using ServiceContractModule;
            using ServiceProviderModule.Impl;
            
            namespace ServiceProviderModule
            {
                public class Activator : IBundleActivator
                {
                    private SayHelloService _sayHelloService;
            
                    public void Start(IBundleContext context)
                    {
                        // 注册服务
                        _sayHelloService = new SayHelloService();
                        context.AddService<ISayHelloService>(_sayHelloService);
                    }
            
                    public void Stop(IBundleContext context)
                    {
                        // 卸载服务
                        context.RemoveService<ISayHelloService>(_sayHelloService);
                    }
                }
            }
            ]]>
            </code>
            <para>2 服务查询与绑定示例，以下示例查询了ISayHelloService的所有实现、过滤并绑定。</para>
            <code>
            <![CDATA[
            public void Start(IBundleContext context)
            {
                // 获取实现了ISayHelloService服务契约的所有服务实现。
                List<ISayHelloService> sayHelloServiceImpls = context.GetService<ISayHelloService>();
                if (sayHelloServiceImpls != null)
                {
                    // 从所有实现中选择其中一个并调用该服务。
                    foreach (var sayHelloService in sayHelloServiceImpls)
                    {
                        if(sayHelloService.GetType().FullName.Contains("MySayHello"))
                        {
                            // 使用服务
                            Console.WriteLine(sayHelloService.Hello("ServiceConsumerModule"));
                        }
                    }
                }
            }
            ]]>
            </code>
            <para>3 关联插件、插件仓库、生命周期操作示例</para>
            <code>
            // 获取当前上下文关联的插件
            IBundle bundle = context.Bundle;
            Console.WriteLine(bundle.SymbolicName);
            // 停止Bundle
            bundle.Stop(BundleStopOptions.Transient);
            // 启动Bundle
            bundle.Start(BundleStartOptions.Transient);
            // 卸载Bundle
            bundle.Uninstall();
            // 查询其它Bundle
            IBundle consolePlugin1 = context.GetBundleByName("ConsolePlugin1"); // 按唯一名称查询。
            // 安装Bundle并启动，安装的位置是Manifest.xml所在的位置
            IBundle serviceConsumerModule = context.InstallBundle(@"D:\ServiceModuleShell\bin\plugins\ServiceConsumerModule");
            serviceConsumerModule.Start(BundleStartOptions.General);
            </code>
            <para>4 有关获取扩展点/扩展的使用，可以查看<see cref="T:UIShell.OSGi.ExtensionPoint"/>的示例。</para>
            <para>5 IBundleContext暴露了SyncBundleStateChanged、BundleStateChanged、ExtensionChanged、
            ExtensionPointChanged、ServiceChanged、FrameworkStateChanged事件，分别用于同步监控插件生命周期状态、
            异步监听插件生命周期状态、扩展变更、扩展点变更、服务变更、平台状态变更。</para>
            </example>
            <remarks>
            插件上下文实现了对内核的反射，我们只能通过模块激活器IBundleActivator的Start/Stop方法获取该参数，
            它向我们暴露了以下功能：
            <list type="bullet">
            <item>获取对应的插件实例</item>
            <item>对插件执行生命周期操作，安装其它插件</item>
            <item>插件仓库查询。</item>
            <item>服务注册与绑定</item>
            <item>获取本插件的扩展点和扩展</item>
            <item>监听框架事件、服务事件、插件事件和扩展事件</item>
            </list>
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.RemoveService``1(System.Object)">
            <summary>
            删除指定服务。
            </summary>
            <typeparam name="T">服务接口。</typeparam>
            <param name="serviceInstance">服务实例。</param>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.RemoveService(System.Type,System.Object)">
            <summary>
            删除指定服务。
            </summary>
            <param name="serviceType">服务接口。</param>
            <param name="serviceInstance">服务实例。</param>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.AddService(System.Type,System.Object)">
            <summary>
            添加一个服务。
            </summary>
            <param name="serviceType">服务接口。</param>
            <param name="serviceInstance">服务实例。</param>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.AddService``1(``0)">
            <summary>
            添加一个服务。
            </summary>
            <typeparam name="T">服务类型。</typeparam>
            <param name="serviceInstance">服务实例。</param>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.GetFirstOrDefaultService``1">
            <summary>
            获取第一个或者默认的服务。
            </summary>
            <typeparam name="T">服务接口。</typeparam>
            <returns>与服务契约匹配的服务。</returns>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.GetFirstOrDefaultService(System.Type)">
            <summary>
            获取第一个或者默认的服务。
            </summary>
            <param name="serviceType">服务接口。</param>
            <returns>与服务契约匹配的服务。</returns>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.GetFirstOrDefaultService(System.String)">
            <summary>
            获取第一个或者默认的服务。
            </summary>
            <param name="serviceTypFullName">服务接口名称。</param>
            <returns>与服务契约匹配的服务。</returns>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.GetService``1">
            <summary>
            获取实现指定服务接口的所有服务实例。
            </summary>
            <typeparam name="T">服务接口。</typeparam>
            <returns>所有服务实例集合。</returns>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.GetService(System.Type)">
            <summary>
            获取实现指定服务接口的所有服务实例。
            </summary>
            <param name="serviceType">服务接口。</param>
            <returns>所有服务实例集合。</returns>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.GetService(System.String)">
            <summary>
            获取实现指定服务接口的所有服务实例。
            </summary>
            <param name="serviceTypeName">服务接口名称。</param>
            <returns>所有服务实例集合。</returns>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.InstallBundle(System.String)">
            <summary>
            安装一个插件。
            </summary>
            <param name="location">插件所在位置。</param>
            <returns>插件对象。</returns>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.InstallBundle(System.String,System.IO.Stream)">
            <summary>
            安装一个插件。
            </summary>
            <param name="location">插件所在位置。</param>
            <param name="stream">插件流媒体。</param>
            <returns>插件对象。</returns>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.GetBundleByID(System.Int64)">
            <summary>
            使用ID获取插件对象。
            </summary>
            <param name="bundleID">插件ID。</param>
            <returns>插件对象。</returns>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.GetBundleBySymbolicName(System.String)">
            <summary>
            使用唯一名称获取插件对象。
            </summary>
            <param name="symbolicName">唯一名称</param>
            <returns>插件对象。</returns>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.GetBundles">
            <summary>
            获取所有插件。
            </summary>
            <returns>所有插件集合。</returns>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.GetBundleByLocation(System.String)">
            <summary>
            使用插件位置获取插件。
            </summary>
            <param name="location">指定位置。</param>
            <returns>插件对象。</returns>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.AddExtension(System.String,UIShell.OSGi.Extension)">
            <summary>
            添加一个扩展。
            </summary>
            <param name="point">对应的扩展点。</param>
            <param name="extension">扩展实例。</param>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.RemoveExtension(UIShell.OSGi.Extension)">
            <summary>
            删除一个扩展。
            </summary>
            <param name="extension">扩展对象。</param>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.GetExtensions(System.String)">
            <summary>
            获取指定扩展点的所有扩展。
            </summary>
            <param name="extensionPoint">扩展点。</param>
            <returns>所有扩展。</returns>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.GetExtensionPoints">
            <summary>
            获取所有扩展点。
            </summary>
            <returns></returns>
        </member>
        <member name="M:UIShell.OSGi.IBundleContext.GetExtensionPoint(System.String)">
            <summary>
            获取指定扩展点实例。
            </summary>
            <param name="point">扩展点。</param>
            <returns>扩展点实例。</returns>
        </member>
        <member name="P:UIShell.OSGi.IBundleContext.Bundle">
            <summary>
            当前插件实例。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.IBundleContext.Framework">
            <summary>
            内核实例。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.IBundleContext.IsDisposed">
            <summary>
            插件上下文是否被清理了。在OSGi，当插件启动时，创建上下文被创建，当停止时，被清理。我们不可以在程序中使用一个已经被清理的插件上下文。
            </summary>
        </member>
        <member name="E:UIShell.OSGi.IBundleContext.SyncBundleStateChanged">
            <summary>
            同步方式监听Bundle事件变更，可以监听到Starting和Stopping。
            </summary>
        </member>
        <member name="E:UIShell.OSGi.IBundleContext.BundleStateChanged">
            <summary>
            异步方式监听Bundle事件变更，不包括Starting和Stopping。
            </summary>
        </member>
        <member name="E:UIShell.OSGi.IBundleContext.BundleLazyActivated">
            <summary>
            同步方式监听Bundle晚激活事件。
            </summary>
        </member>
        <member name="E:UIShell.OSGi.IBundleContext.FrameworkStateChanged">
            <summary>
            内核状态变更事件。
            </summary>
        </member>
        <member name="E:UIShell.OSGi.IBundleContext.ServiceChanged">
            <summary>
            服务变更事件。
            </summary>
        </member>
        <member name="E:UIShell.OSGi.IBundleContext.ExtensionChanged">
            <summary>
            扩展变更事件。
            </summary>
        </member>
        <member name="E:UIShell.OSGi.IBundleContext.ExtensionPointChanged">
            <summary>
            扩展点变更事件。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.BundleContext.InstallBundle(System.String)">
            <summary>
            安装一个Bundle。
            1 检查是否存在指定location的Bundle，若存在，直接返回。
            2 读取Bundle内容，验证Bundle，若失败，则抛出异常。
            3 分配Bundle需要的最小资源——ID和持久存储。
            4 设置为Install状态。
            5 触发Install事件。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.BundleContext.Stop">
            <summary>
            装载并启动激活器。
            3 停止：停止过程需要1）检查Framework是否运行；2）状态是否满足；3）停止并关闭上下文。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.BundleContext.System#IDisposable#Dispose">
            <summary>
            清理事件监听器和服务。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.BundleContext.CheckValid">
            <summary>
            将检查一个BundleContext是否可用，即是否已经Closed。当一个BundleContext为Closed，对其的任何操作，则必须抛出一个异常。
            </summary>
        </member>
        <member name="E:UIShell.OSGi.Core.Bundle.BundleContext.FrameworkStateChanged">
            <summary>
            挂载到Framework的事件派发器，并记录当前事件监听器列表，以便在清理时删除监听器。
            </summary>
        </member>
        <member name="E:UIShell.OSGi.Core.Bundle.BundleContext.SyncBundleStateChanged">
            <summary>
            Bundle状态变化的同步步处理事件。
            </summary>
        </member>
        <member name="E:UIShell.OSGi.Core.Bundle.BundleContext.BundleLazyActivated">
            <summary>
            同步监视Bundle 的晚激活事件。
            </summary>
        </member>
        <member name="E:UIShell.OSGi.Core.Bundle.BundleContext.BundleStateChanged">
            <summary>
            Bundle状态变化的同步步处理事件， 挂载到Framework的事件派发器，并记录当前事件监听器列表，以便在清理时删除监听器。
            </summary>
        </member>
        <member name="E:UIShell.OSGi.Core.Bundle.BundleContext.ServiceChanged">
            <summary>
            服务变更事件
            </summary>
        </member>
        <member name="E:UIShell.OSGi.Core.Bundle.BundleContext.ExtensionChanged">
            <summary>
            扩展变更事件
            </summary>
        </member>
        <member name="E:UIShell.OSGi.Core.Bundle.BundleContext.ExtensionPointChanged">
            <summary>
            扩展点变更事件
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.FragmentBundle.DoStart(UIShell.OSGi.BundleStartOptions)">
            <summary>
            片段Bundle不能被启动，抛出异常。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.FragmentBundle.DoStop(UIShell.OSGi.BundleStopOptions)">
            <summary>
            片段Bundle不能被停止，抛出异常。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.FragmentBundle.LoadResource(System.String,UIShell.OSGi.ResourceLoadMode)">
            <summary>
            装载资源，返回null。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.FragmentBundle.LoadClass(System.String)">
            <summary>
            不能装载类。直接抛出类型没有找到异常。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.FragmentBundle.DoUninstall">
            <summary>
            片段Bundle也可以卸载，目前仅仅从持久存储中卸载
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Core.Bundle.HostBundle">
            <summary>
            Host bundle class。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.IHostBundle.ActivateForStarting">
            <summary>
            HostBundle可能由于LazyLoad的策略进入Starting后没有直接进入Active,
            因此这里提供尝试激活
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Core.IHostBundle.Activator">
            <summary>
            模块激活器实例。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.HostBundle.DoStart(UIShell.OSGi.BundleStartOptions)">
            <summary>
            启动一个Bundle。
            1 若该Bundle的状态是Starting或Stopping，则等待。(基类中已经有状态判断，不需要做这一步了)
            2 若处于Active，则直接返回。
            3 根据Option设置autostart。
            4 若Bundle未解析，则尝试解析，如果解析失败则抛出异常。
            5 若该Bundle声明了晚激活策略并使用ActivationPolicy作为启动参数，则：若状态为Starting，则返回，否则设置状态为Starting，然后触发LASY_ACTIVATION事件。
            6 设置状态为Starting。
            7 触发Starting事件。
            8 调用BundleActivatior.start方法，如果出现异常，则执行Stop操作，并抛出异常。
            9 若状态为Uninstall，则抛出异常。
            10 状态设置为Active。
            11 触发Started事件。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.HostBundle.GetBundleStartState">
            <summary>
            1,如果Bundle的持久存储中已经指定，则采用此设置
            2,如果Bundle的Manifest中指定了InitializedState，则采用此设置
            3,如果以上都没有指定，则采用ApplicationOption.DefaultBundleState，并且BundleStartOptions，BundleStopOptions为Transient
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.HostBundle.CallTryStart">
            <summary>
            Calls the try start to avoid reenter.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.HostBundle.DoStop(UIShell.OSGi.BundleStopOptions)">
            <summary>
            停止一个Bundle。
            1 若处于Starting或Stopping，则等待完成。（不需要了）
            2 根据Option设置autostart。
            3 如果状态不是Active，则返回。
            4 状态设置为Stopping。
            5 触发Stopping事件。
            6 执行BundleActivator.stop方法，如果异常，则继续，并在完成以下步骤后，抛出这个异常。
            7 卸载服务、服务引用和监听器。
            8 若处于Uninstall状态，则抛出异常。
            9 设置为Resolved状态。
            10 触发Stopped事件。
            </summary>
            <param name="option"></param>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.HostBundle.ActivateForStarting">
            <summary>
            HostBundle可能由于LazyLoad的策略进入Starting后没有直接进入Active,
            因此这里提供尝试激活
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.HostBundle.LoadResource(System.String,UIShell.OSGi.ResourceLoadMode)">
            <summary>
            Loads the resource.
            </summary>
            <param name="resourceName">Name of the resource.</param>
            <param name="loadMode">The load mode.</param>
            <returns></returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.HostBundle.DoUninstall">
            <summary>
            卸载Bundle。
            1 如果处于Active、Starting或Stopping，则执行停止操作。
            2 设置状态为Uninstall状态。
            3 触发Uninstall事件。
            4 删除持久存储。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.HostBundle.GetDefaultPersistFile">
            <summary>
            Gets the default persist file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.HostBundle.SavePersistent">
            <summary>
            保存持久存储数据
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.SystemBundle.DoStart(UIShell.OSGi.BundleStartOptions)">
            <summary>
            启动Framework。
            1 如果已经Active、Starting、Stopping，则直接返回。
            注：启动Framework事件系统在Framework初始化完成。
            2 设置系统状态为Starting。
            3 触发Starting事件。
            4 创建上下文并启动上下文。
            5 利用StartLevelManager启动所有已经安装的Bundle。
            6 如果启动Bundle出现一个异常，则触发包括这个异常的FrameworkEvent.ERROR事件。
            7 设置Start状态。
            8 触发BundleEvent.STARTED事件。
            9 触发FrameworkEvent.STARTED事件。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.SystemBundle.Stop(UIShell.OSGi.BundleStopOptions)">
            <summary>
            SystemBundle停止时，必须启动一个线程停止Framework。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.SystemBundle.Stop">
            <summary>
            Stop the framework directly.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Bundle.SystemBundle.DoStop(UIShell.OSGi.BundleStopOptions)">
            <summary>
            停止Framework。
            1 如果状态不是Active，则直接返回。
            2 设置Stopping状态。
            3 触发Stopping事件。
            4 利用StartLevelManager停止所有Bundle。
            5 停止BundleContext。
            6 设置为Stopped状态。
            7 触发BundleEvent.STOPPED事件。
            8 触发FrameworkEvent.STOPPED事件。
            注：停止Framework的事件系统在Framework的Dispose完成。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.IBundleActivator">
            <summary>
            Bundle激活器，这是插件的唯一入口。用于在插件启动或停止时执行相关操作。
            </summary>
            <example>
            <para>Bundle激活器通过Manifest.xml的Activator节点配置，在启动或停止时会被访问。以下示例定义了一个激活器。
            这里定义的激活器当插件被启动时，Start方法被调用并在控制台输出“SimpleModule is started”；当插件被停止时，
            则调用Stop方法输出“SimpleModule is stopped.”。</para>
            <para>1 在Manifest.xml添加一个激活器配置：<![CDATA[<Activator Type="SimpleModule.Activator" Policy="Immediate" />]]>。</para>
            <para>2 定义如下激活器。</para>
            <code>
            using System;
            using System.Collections.Generic;
            using UIShell.OSGi;
            
            namespace SimpleModule
            {
                /// <![CDATA[<summary>]]>
                /// 模块激活器，它是一个模块启动和停止的入口。当模块被启动时，激活器的Start方法会被调用；如果是被停止，则其Stop方法会被调用。
                /// 一般而言，一个模块会在Start方法中向系统提供功能、注册服务、申请如线程等资源等，在Stop方法会执行回收操作，比如关闭功能、
                /// 卸载服务、释放资源等。需要注意的是，在Start方法中申请的资源必须在Stop方法中得到释放，而且一个模块的Start/Stop方法在运行
                /// 过程可能会被调用多次，必须确保再次调用Start/Stop方法不会出现异常。
                /// <![CDATA[</summary>]]>
                public class Activator : IBundleActivator
                {
                    /// <![CDATA[<summary>]]>
                    /// 模块启动时调用的方法。
                    /// <![CDATA[</summary>]]>
                    /// <![CDATA[<param name="context">]]>模块上下文，通过模块上下文可以获取对框架功能访问、服务注册表访问、模块生命周期等功能访问。
                    /// 模块上下文是框架提供给模块唯一的对象。<![CDATA[</param>]]>
                    public void Start(IBundleContext context)
                    {
                        Console.WriteLine("SimpleModule is started.");
                    }
            
                    /// <![CDATA[<summary>]]>
                    /// 模块停止时调用的方法。
                    /// <![CDATA[</summary>]]>
                    /// <![CDATA[<param name="context">模块上下文。</param>]]>
                    public void Stop(IBundleContext context)
                    {
                        Console.WriteLine("SimpleModule is stopped.");
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:UIShell.OSGi.IBundleActivator.Start(UIShell.OSGi.IBundleContext)">
            <summary>
            插件启动入口。当插件被启动时，如果指定了激活器时，内核会调用激活器的Start方法
            来完成插件启动。一般来讲，插件在该方法会暴露该插件的功能或者注册它提供的服务，
            此外，还用于申请资源或者获取绑定服务等。
            </summary>
            <param name="context">当前插件上下文。它提供了对内核的反射功能。插件上下文允许用于注册/卸载服务、获取模块对象、查询插件仓库、安装其它插件、访问扩展信息、监听事件等。注意：插件上下文在停止后将被销毁，因此不要通过记住上下文来执行操作。有关context的详细信息，请查看<see cref="T:UIShell.OSGi.IBundleContext"/>所示。</param>
        </member>
        <member name="M:UIShell.OSGi.IBundleActivator.Stop(UIShell.OSGi.IBundleContext)">
            <summary>
            插件停止入口。当插件被停止时，如果指定了激活器时，内核会调用激活器的Stop方法
            来完成插件停止。一般来讲，插件在该方法会执行与Start相反的操作，比如释放在Start
            方法中申请的资源。
            </summary>
            <param name="context">当前插件上下文。它提供了对内核的反射功能。插件上下文允许用于注册/卸载服务、获取模块对象、查询插件仓库、安装其它插件、访问扩展信息、监听事件等。注意：插件上下文在停止后将被销毁，因此不要通过记住上下文来执行操作。有关context的详细信息，请查看<see cref="T:UIShell.OSGi.IBundleContext"/>所示。</param>
        </member>
        <member name="T:UIShell.OSGi.Console.ICommandContext">
            <summary>
            包含执行命令时的上下文信息
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Console.ICommandContext.Handled">
            <summary>
            执行命令需要对所有注册的ICommand进行尝试，直到发现某个ICommand将此Handled置为true以表明接受了此命令，否则就会继续尝试下去。
            </summary>
            <value><c>true</c> if handled; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:UIShell.OSGi.Console.ICommandContext.Words">
            <summary>
            要执行的命令被以空格分成的数组。
            </summary>
            <value>The words.</value>
        </member>
        <member name="P:UIShell.OSGi.Console.ICommandContext.Framework">
            <summary>
            执行命令的Framework
            </summary>
            <value>The framework.</value>
        </member>
        <member name="P:UIShell.OSGi.Console.ICommandContext.Message">
            <summary>
            保存执行命令时的一些信息。
            </summary>
            <value>The message.</value>
        </member>
        <member name="M:UIShell.OSGi.Console.CommandRepository.SplitCmdWords(System.String)">
            <summary>
            将要执行的命令按空格分隔成单词，这样在执行命令时可以方便使用命令中的参数
            </summary>
            <param name="cmd">The CMD.</param>
            <returns></returns>
        </member>
        <member name="M:UIShell.OSGi.Console.CommandRepository.Run(System.String)">
            <summary>
            Try run command.
            </summary>
            <param name="cmd">The CMD.</param>
            <returns>
            Indicate whether this cmd be excuted or not.
            </returns>
        </member>
        <member name="P:UIShell.OSGi.Console.CommandRepository.Commands">
            <summary>
            保存注册的命令，比如StartBundleCommand,StopBundleCommand
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Console.CommandRepository.NamedCommands">
            <summary>
            这里把命令分成2种，一种是命令格式固定的命令，比如停止Framework的命令："stop"，这种命令特点是命令中不传递任何参数，
            第二种命令是需要传递参数的命令，比如启动、停止Bundle的命令：
            "start [bundle name]"和"stop [bundle name]",他们不仅需要前缀"start"，“stop”外，还需要通过命令指定操作的对象是谁
            为了快速处理第一中命令，这里将他们分开了。
            当然，我们可以让每个命令指定一个匹配策略（比如能够解析的命令的正则表达式），进行更进一步的性能优化，
            但目前Framework认为没有必要设计的过于复杂，而丧失了简洁性。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Console.StartBundleCommand">
            <summary>
            启动一个Bundle
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Console.StopBundleCommand">
            <summary>
            停止一个Bundle，命令格式：
            stop [Bundle SymbolicName]
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Core.Event.EventDispatcher`1">
            <summary>
            事件派发器。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Core.Event.EventDispatcher`1._eventThread">
            <summary>
            一个派发异步事件的线程。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventDispatcher`1.DispatchToListeners(System.Object,`0,System.Collections.Generic.IEnumerable{System.EventHandler{`0}},UIShell.OSGi.Core.Event.EventDispatcher{`0}.DispatchEventItemDelegate)">
            <summary>
            使用一个Delegate来实现事件派发。
            </summary>
            <param name="sender">事件发出者。</param>
            <param name="e">事件参数。</param>
            <param name="listeners">监听器快照。</param>
            <param name="dispatchEventItemDelegate">派发代理。</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventDispatcher`1.DispatchToAsyncListeners(System.Object,`0,System.Collections.Generic.IEnumerable{System.EventHandler{`0}})">
            <summary>
            异步派发，将事件派发项添加到派发线程的工作队列中。
            </summary>
            <param name="sender">事件发出者。</param>
            <param name="e">事件参数。</param>
            <param name="listeners">监听器快照。</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventDispatcher`1.DispatchToSyncListeners(System.Object,`0,System.Collections.Generic.IEnumerable{System.EventHandler{`0}})">
            <summary>
            同步派发。
            </summary>
            <param name="sender">事件发出者。</param>
            <param name="e">事件参数。</param>
            <param name="listeners">监听器快照。</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventDispatcher`1.Dispose">
            <summary>
            清理资源。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventDispatcher`1.SyncDispatchEventItem(UIShell.OSGi.Core.Event.EventDispatcher{`0}.EventThreadItem)">
            <summary>
            事件项的同步处理。
            </summary>
            <param name="item">事件项。</param>
        </member>
        <member name="T:UIShell.OSGi.Core.Event.EventDispatcher`1.DispatchEventItemDelegate">
            <summary>
            事件派发代理。
            </summary>
            <param name="item">事件项。</param>
        </member>
        <member name="T:UIShell.OSGi.Core.Event.EventDispatcher`1.EventThreadItem">
            <summary>
            事件项。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Core.Event.EventDispatcher`1.EventThread">
            <summary>
            异步事件派发线程。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventDispatcher`1.EventThread.#ctor">
            <summary>
            启动一个线程执行事件派发。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventDispatcher`1.EventThread.Dispatch">
            <summary>
            如果派发列表为空，则暂停线程。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventDispatcher`1.EventThread.Push(UIShell.OSGi.Core.Event.EventDispatcher{`0}.EventThreadItem)">
            <summary>
            插入一个事件项，唤醒线程。
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventDispatcher`1.EventThread.Pop">
            <summary>
            取出一个事件项。
            </summary>
            <returns></returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventDispatcher`1.EventThread.Dispose">
            <summary>
            清理资源。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Core.Event.EventManager">
            <summary>
            事件管理器，用于事件注册、抓取事件快照和利用派发器，派发事件。
            注意：
            1 抓取监听器快照时，需要加锁。
            2 派发事件后，快照需要销毁，防止内存泄漏。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventManager.#ctor">
            <summary>
            创建一个EventManager实例。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventManager.AddBundleLazyActivatedEventListener(System.EventHandler{UIShell.OSGi.BundleLazyActivatedEventArgs})">
            <summary>
            按照osgi规范，ServiceEvent是同步的
            </summary>
            <param name="handler"></param>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventManager.AddServiceEventListener(System.EventHandler{UIShell.OSGi.ServiceEventArgs})">
            <summary>
            按照osgi规范，ServiceEvent是同步的
            </summary>
            <param name="handler"></param>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventManager.RemoveBundleEventListener(System.EventHandler{UIShell.OSGi.BundleStateChangedEventArgs},System.Boolean)">
            <summary>
            删除一个事件处理函数。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventManager.Start">
            <summary>
            启动事件管理器：接受订阅事件，接受派发。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventManager.Stop">
            <summary>
            停止事件管理器。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventManager.DispatchFrameworkEvent(System.Object,UIShell.OSGi.FrameworkEventArgs)">
            <summary>
            启动一个线程用于派发Framework异步监听器。
            1 首先抓取Framework异步监听器快照；
            2 启动一个线程派发快照。
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventManager.DispatchBundleLazyActivateEvent(System.Object,UIShell.OSGi.BundleLazyActivatedEventArgs)">
             <summary>
            发布Bundle晚激活事件。
             </summary>
             <param name="sender"></param>
             <param name="e"></param>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventManager.DispatchBundleEvent(System.Object,UIShell.OSGi.BundleStateChangedEventArgs)">
            <summary>
            监听器分为两类：1 监听器为同步监听器；2 监听器为异步监听器。
            1 抓取同步监听器快照；
            2 抓取异步监听器快照；
            3 派发同步事件；
            4 如果事件不是STARTING、STOPPING和LASY_ACTIVATION，则派发异步事件。
            </summary>
            <param name="exception"></param>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventManager.DispatchServiceEvent(System.Object,UIShell.OSGi.ServiceEventArgs)">
            <summary>
            监听器分为两类：1 监听器为同步监听器；2 监听器为异步监听器。
            1 抓取同步监听器快照；
            3 派发同步事件；
            </summary>
            <param name="exception"></param>
        </member>
        <member name="M:UIShell.OSGi.Core.Event.EventManager.Dispose">
            <summary>
            清理事件派发器和事件监听器列表。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Core.Event.EventManager.FrameworkEventListeners">
            <summary>
            获取侦听Framework事件的处理函数。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Core.Event.EventManager.BundleEventListeners">
             <summary>
            获取侦听Bundle事件的异步处理函数。 
             </summary>
        </member>
        <member name="P:UIShell.OSGi.Core.Event.EventManager.SyncBundleEventListeners">
             <summary>
            获取侦听Bundle事件的同步处理函数。 
             </summary>
        </member>
        <member name="P:UIShell.OSGi.Core.Event.EventManager.PreviewBundleStartingEventListeners">
             <summary>
            获取侦听Bundle 启动预览事件的同步处理函数。 
             </summary>
        </member>
        <member name="T:UIShell.OSGi.Core.IFramework">
            <summary>
            OSGi通过此接口向用户暴露功能
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.IFramework.GetBundleBySymbolicName(System.String)">
            <summary>
            Gets the bundle by bundle name.
            </summary>
            <param name="name">The bundle name.</param>
            <returns>Instance of IBundle</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.IFramework.GetBundleByID(System.Int32)">
            <summary>
            Gets the bundle by bundle id.
            </summary>
            <param name="bundleID">The bundle id.</param>
            <returns>Instance of IBundle</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.IFramework.GetBundle(System.String)">
            <summary>
            Get the bundle by location.
            </summary>
            <param name="location">The installation location to the bundle.</param>
            <returns>Instance of IBundle.</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.IFramework.RunCommand(System.String)">
            <summary>
            Runs the command.
            </summary>
            <param name="cmd">The CMD.</param>
            <returns></returns>
        </member>
        <member name="M:UIShell.OSGi.Core.IFramework.Start">
            <summary>
            Starts the framework.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.IFramework.Stop">
            <summary>
            Stops framework.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.IFramework.RemoveSystemService(System.Type,System.Object)">
            <summary>
            Remove system service.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.IFramework.AddSystemService(System.Object,System.Type[])">
            <summary>
            Register system service.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.IFramework.AddSystemService(System.Type,System.Object[])">
            <summary>
            Register system service.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Core.IFramework.Options">
            <summary>
            System option.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Core.IFramework.Commands">
            <summary>
            Get the command repository.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Core.IFramework.ServiceContainer">
            <summary>
            Gets the service container.
            </summary>
            <value>The service container.</value>
        </member>
        <member name="P:UIShell.OSGi.Core.IFramework.Bundles">
            <summary>
            All installed Bundles
            </summary>
            <value>The bundles.</value>
        </member>
        <member name="P:UIShell.OSGi.Core.IFramework.IsActive">
            <summary>
            Gets a value indicating whether this framework is active.
            </summary>
            <value><c>true</c> if this framework is active; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:UIShell.OSGi.Core.IFramework.EventManager">
            <summary>
            Gets the event manager.
            </summary>
            <value>The event manager.</value>
        </member>
        <member name="M:UIShell.OSGi.Core.Framework.InitializeCommands(UIShell.OSGi.Core.Command.ICommandRepository)">
            <summary>
            Initializes the commands repository with build-in commands.
            </summary>
            <param name="_commands">The commands repository.</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Framework.AddCommand(System.String,UIShell.OSGi.Console.ICommandAdaptor)">
            <summary>
            Adds the command for fixed format command string
            </summary>
            <param name="cmd">The CMD.</param>
            <param name="cmdAdaptor">The CMD adaptor.</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Framework.AddCommand(UIShell.OSGi.Console.ICommandAdaptor)">
            <summary>
            Adds the command.
            </summary>
            <param name="cmd">The CMD.</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Framework.Start">
            <summary>
            Starts Framework。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Framework.GetBundleMetadata(System.Int64)">
            <summary>
            Gets the bundle metadata by specifed Bundle ID.
            </summary>
            <param name="bundleID">The bundle ID.</param>
            <returns></returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Framework.GetBundleBySymbolicName(System.String)">
            <summary>
            Gets the bundle by bundle name.
            </summary>
            <param name="name">The bundle name.</param>
            <returns>Instance of IBundle</returns>
        </member>
        <member name="P:UIShell.OSGi.Core.Framework.Bundles">
            <summary>
            All installed Bundles
            </summary>
            <value>The bundles.</value>
        </member>
        <member name="T:UIShell.OSGi.BundleRuntimeState">
            <summary>
            BundleRuntime的状态。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleRuntimeState.Starting">
            <summary>
            正在启动。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleRuntimeState.Started">
            <summary>
            已经启动。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleRuntimeState.Stopping">
            <summary>
            正在停止。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleRuntimeState.Stopped">
            <summary>
            已经停止。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleRuntimeState.Disposed">
            <summary>
            已经执行垃圾回收。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.BundleRuntime">
            <summary>
            Bundle即插件，BundleRuntime是插件运行时。插件运行时是整个插件框架的入口点，
            用于从指定位置加载并启动或者停止所有插件。
            </summary>
            <example>
            <para>
            以下是利用创建并启动BundleRuntime的示例，此时BuntimeRuntime将从AppDomain.BaseDirectory下
            的plugins加载插件。
            </para>
            <code>
            using System;
            using System.Collections.Generic;
            using System.Linq;
            using System.Text;
            using UIShell.OSGi;
            using System.Windows.Forms;
            
            namespace WinFormShell
            {
                class Program
                {
                    [STAThread]
                    static void Main(string[] args)
                    {
                        Application.EnableVisualStyles();
                        Application.SetCompatibleTextRenderingDefault(false);
                        // 创建插件运行时。
                        using (BundleRuntime bundleRuntime = new BundleRuntime())
                        {
                            // 启动插件运行时。
                            bundleRuntime.Start();
            
                            // 获取Form服务，并运行。
                            Form mainForm = bundleRuntime.GetFirstOrDefaultService<![CDATA[<Form>]]>();
            
                            if (mainForm != null)
                            {
                                Application.Run(mainForm);
                            }
                        }
                    }
                }
            }
            </code>
            <para>
            BundleRuntime有一个无参构造器，还有一个有参构造器。有参构造器允许指定插件的位置。以下是有参构造器的用法，它将从D:\UIOSP\MyShell\plugins这个位置加载插件。
            </para>
            <code>
            using(BundleRuntime bundleRuntime = new BundleRuntime(@"D:\UIOSP\MyShell\plugins"))
            {
                Console.WriteLine("Enter 'enter' key to exit...");
                bundleRuntime.Start(); // 启动插件运行时。
                Console.ReadLine();
            }
            </code>
            </example>
        </member>
        <member name="M:UIShell.OSGi.BundleRuntime.Dispose">
            <summary>
            释放运行时。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.BundleRuntime.#ctor">
            <summary>
            创建一个Bundle运行时，此时运行时默认插件的位置在/plugins目录下。
            </summary>
            <example>
            <para>
            以下是利用创建并启动BundleRuntime的示例，此时BuntimeRuntime将从AppDomain.BaseDirectory下
            的plugins加载插件。
            </para>
            <code>
            using (UIShell.OSGi.BundleRuntime bundleRuntime = new UIShell.OSGi.BundleRuntime())
            {
                Console.WriteLine("Enter 'enter' key to exit...");
                bundleRuntime.Start(); // 启动模块插件运行时。
                Console.ReadLine();
            }
            </code>
            </example>
        </member>
        <member name="M:UIShell.OSGi.BundleRuntime.#ctor(System.String)">
            <summary>
            创建一个指定插件文件夹的Bundle运行时。
            </summary>
            <param name="pluginsPath">插件位置。</param>
            <example>
            <para>
            以下是该构造器的用法，它将从D:\UIOSP\MyShell\plugins这个位置加载插件。
            </para>
            <code>
            using(BundleRuntime bundleRuntime = new BundleRuntime(new string[] { @"D:\UIOSP\MyShell\plugins", "plugins2"}))
            {
                Console.WriteLine("Enter 'exit' key to exit...");
                bundleRuntime.Start(); // 启动模块插件运行时。
                Console.ReadLine();
            }
            </code>
            </example>
        </member>
        <member name="M:UIShell.OSGi.BundleRuntime.#ctor(System.String[])">
            <summary>
            创建一个指定插件文件夹的Bundle运行时。
            </summary>
            <param name="pluginsPathList">插件位置列表。</param>
            <example>
            <para>
            以下是该构造器的用法，它将从D:\UIOSP\MyShell\plugins和当前执行程序目录下的plugins2子目录这两个位置加载插件。
            </para>
            <code>
            using(BundleRuntime bundleRuntime = new BundleRuntime(new string[] { @"D:\UIOSP\MyShell\plugins", "plugins2"}))
            {
                Console.WriteLine("Enter 'exit' key to exit...");
                bundleRuntime.Start(); // 启动模块插件运行时。
                Console.ReadLine();
            }
            </code>
            </example>
        </member>
        <member name="F:UIShell.OSGi.BundleRuntime._started">
            <summary>
            记录Framework是否已经启动
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleRuntime._state">
            <summary>
            BundleRuntime状态。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.BundleRuntime.GetFirstOrDefaultService``1">
            <summary>
            获取第一个或者默认服务。
            </summary>
            <typeparam name="T">服务接口。</typeparam>
            <returns>如果存在则返回一个服务对象，否则返回null。</returns>
            <example>
            <para>这个方法用于从插件运行时获取一个指定类型的默认或者第一个服务，示例如下。</para>
            <code>
            using(BundleRuntime bundleRuntime = new BundleRuntime(@"D:\UIOSP\MyShell\plugins"))
            {
                Console.WriteLine("Enter 'exit' key to exit...");
                bundleRuntime.Start(); // 启动模块插件运行时。
                // 获取一个ILogService。
                ILogService logService = bundleRuntime.GetFirstOrDefaultService<![CDATA[<ILogService>]]>();
                if(logService != null) // 如果不为空，则调用其Inform方法来记录一条信息。
                {
                    logService.Inform("Bundle runtime is started.");
                }
                Console.ReadLine();
            }
            </code>
            </example>
        </member>
        <member name="M:UIShell.OSGi.BundleRuntime.GetFirstOrDefaultService(System.Type)">
            <summary>
            获取第一个或者默认的服务。
            </summary>
            <param name="serviceType">服务接口。</param>
            <returns>与服务契约匹配的服务。</returns>
            <example>
            <para>这个方法用于从插件运行时获取一个指定类型的默认或者第一个服务，示例如下。</para>
            <code>
            using(BundleRuntime bundleRuntime = new BundleRuntime(@"D:\UIOSP\MyShell\plugins"))
            {
                Console.WriteLine("Enter 'exit' key to exit...");
                bundleRuntime.Start(); // 启动模块插件运行时。
                // 获取一个ILogService。
                object logService = bundleRuntime.GetFirstOrDefaultService(typeof(ILogService));
                if(logService != null) // 如果不为空，则调用其Inform方法来记录一条信息。
                {
                    (logService as ILogService).Inform("Bundle runtime is started.");
                }
                Console.ReadLine();
            }
            </code>
            </example>
        </member>
        <member name="M:UIShell.OSGi.BundleRuntime.GetFirstOrDefaultService(System.String)">
            <summary>
            获取第一个或者默认的服务。
            </summary>
            <param name="serviceTypeName">服务接口名称。</param>
            <returns>与服务契约匹配的服务。</returns>
        </member>
        <member name="M:UIShell.OSGi.BundleRuntime.GetService``1">
            <summary>
            获取实现指定接口的所有服务。
            </summary>
            <typeparam name="T">服务接口。</typeparam>
            <returns>返回服务集合，如果不存在则返回null。</returns>
            <example>
            <para>这个方法用于从插件运行时获取所有，示例如下。</para>
            <code>
            using(BundleRuntime bundleRuntime = new BundleRuntime(@"D:\UIOSP\MyShell\plugins"))
            {
                Console.WriteLine("Enter 'exit' key to exit...");
                bundleRuntime.Start(); // 启动模块插件运行时。
                // 获取一个ILogService。
                List<![CDATA[<ILogService>]]> logServices = bundleRuntime.GetService<![CDATA[<ILogService>]]>();
                if(logServices != null) // 如果不为空，则调用其Inform方法来记录一条信息。
                {
                    foreach(ILogService logService in logServices)
                    {
                        if(logService.GetType().FullName.Contains("UIShell.OSGi.Core.Service"))
                        {
                            logService.Inform("Bundle runtime is started.");
                            break;
                        }
                    }
                }
                Console.ReadLine();
            }
            </code>
            </example>
        </member>
        <member name="M:UIShell.OSGi.BundleRuntime.GetService(System.Type)">
            <summary>
            获取指定服务接口类型的所有服务。
            </summary>
            <param name="serviceType">服务接口。</param>
            <returns>返回服务集合，如果不存在则返回null。</returns>
            <remarks>这个方法是<![CDATA[List<T> GetService<T>()]]>方法的非泛型方法。</remarks>
        </member>
        <member name="M:UIShell.OSGi.BundleRuntime.GetService(System.String)">
            <summary>
            获取指定服务接口类型的所有服务。
            </summary>
            <param name="serviceTypeName">服务接口名称。</param>
            <returns>返回服务集合，如果不存在则返回null。</returns>
            <remarks>这个方法是<![CDATA[List<T> GetService<T>()]]>方法的非泛型方法。</remarks>
        </member>
        <member name="M:UIShell.OSGi.BundleRuntime.AddService``1(System.Object)">
            <summary>
            添加一个全局服务。
            </summary>
            <typeparam name="ServiceInterface">服务接口。</typeparam>
            <param name="serviceInstance">服务实现。</param>
            <example>
            <para>该方法可以在BundleRuntime启动之前添加一个全局服务，从而所有的插件都可以获取并使用。以下是其用法。</para>
            <code>
            using(BundleRuntime bundleRuntime = new BundleRuntime(@"D:\UIOSP\MyShell\plugins"))
            {
                Console.WriteLine("Enter 'exit' key to exit...");
                // 添加一个全局服务。
                bundleRuntime.AddService<![CDATA[<ILogService>]]>(new MyLogService());
                bundleRuntime.Start(); // 启动模块插件运行时。
                Console.ReadLine();
            }
            </code>
            </example>
        </member>
        <member name="M:UIShell.OSGi.BundleRuntime.RemoveService``1(System.Object)">
            <summary>
            删除一个服务。
            </summary>
            <typeparam name="ServiceInterface">服务接口。</typeparam>
            <param name="serviceInstance">服务实例。</param>
            <remarks>该方法与<![CDATA[void AddService<ServiceInterface>(object serviceInstance)]]>方法相对，用于删除一个注册的服务。</remarks>
        </member>
        <member name="M:UIShell.OSGi.BundleRuntime.AddService(System.Type,System.Object)">
            <summary>
            添加一个全局服务。
            </summary>
            <param name="serviceInterface">服务接口。</param>
            <param name="serviceInstance">服务实例。</param>
            <example>
            <para>该方法可以在BundleRuntime启动之前添加一个全局服务，从而所有的插件都可以获取并使用。以下是其用法。</para>
            <code>
            using(BundleRuntime bundleRuntime = new BundleRuntime(@"D:\UIOSP\MyShell\plugins"))
            {
                Console.WriteLine("Enter 'exit' key to exit...");
                // 添加一个全局服务。
                bundleRuntime.AddService(typeof(ILogService), new MyLogService());
                bundleRuntime.Start(); // 启动模块插件运行时。
                Console.ReadLine();
            }
            </code>
            </example>
        </member>
        <member name="M:UIShell.OSGi.BundleRuntime.RemoveService(System.Type,System.Object)">
            <summary>
            删除一个服务。
            </summary>
            <param name="serviceInterface">服务接口。</param>
            <param name="serviceInstance">服务实例。</param>
            <remarks>该方法与<![CDATA[public void AddService(Type serviceInterface, object serviceInstance)]]>相对，用于删除一个服务。</remarks>
        </member>
        <member name="M:UIShell.OSGi.BundleRuntime.Start">
            <summary>
            启动模块运行时。此时，模块运行时将会从插件所在文件夹加载所有插件并启动需要启动的插件。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.BundleRuntime.Start(System.String[])">
            <summary>
            启动模块运行时。此时，模块运行时将会从插件所在文件夹加载所有插件并启动需要启动的插件。
            </summary>
            <param name="args">传递的参数。</param>
        </member>
        <member name="M:UIShell.OSGi.BundleRuntime.Stop">
            <summary>
            停止模块运行时，所有的插件会被停止。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.BundleRuntime.Instance">
            <summary>
            运行时实例。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.BundleRuntime.StartArgs">
            <summary>
            启动Bundle运行时的参数。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.BundleRuntime.Framework">
            <summary>
            内核框架实例。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.BundleRuntime.State">
            <summary>
            Bundle运行时状态。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.BundleRuntime.EnableGlobalAssemblyFeature">
            <summary>
            <para>
            是否启用全局程序集支持，默认为false。如果为true的话，会对类型加载性能产生
            影响且会对类型空间隔离性产生特殊的影响。
            </para>
            <para>
            全局程序集是指在CLR类加载默认加载行为下能够加载的程序集。比如，在ASP.NET应用
            程序的bin目录下的所有程序集都可以被CLR类加载器直接加载。
            </para>
            <para>
            引入全局程序集，允许所有Bundle可以不声明对程序集的依赖或者声明为本地程序集
            的情况下通过Bundle.LoadClass或直接类型引用方式加载到该类型。
            </para>
            <remarks>
            需要注意的是：如果在Bundle中声明了相同的本地程序集，则会被忽略。最佳实践为：
            （1）所有Bundle都不声明全局程序集为本地程序集或声明对其的依赖；（2）所有Bundle
            都直接通过程序集引用，并且直接使用类型定义来使用全局程序集的类型。
            </remarks>
            </summary>
        </member>
        <member name="P:UIShell.OSGi.BundleRuntime.EnableBundleClassLoaderCache">
            <summary>
            是否将Bundle加载的类型缓存，从而提高类型加载性能。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.BundleRuntime.EnableAssemblyShadowCopy">
            <summary>
            设置程序集加载是否使用影子拷贝，即不加载原始文件，保证文件不被锁定，一旦原始文件出现变更，将发出通知。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.BundleRuntime.BundleClassLoaderCacheSize">
            <summary>
            Bundle类加载缓存的大小。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.BundleRuntime.ServiceManager">
            <summary>
            服务总线实例。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.BundleRuntime.SupportMultipleVersionsByDefault">
            <summary>
            如果本地程序集没有指定是否支持多版本，如果当前属性设置为true，则本地程序集支持多版本；
            否则不支持多版本。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Core.Service.IBundleManager">
            <summary>
            模块管理服务。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IBundleManager.InstallBundle(System.String)">
            <summary>
            从指定目录安装一个模块。
            </summary>
            <param name="location">模块位置，即Manifest.xml所在的目录。</param>
            <returns>模块对应的IBundle对象。</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IBundleManager.InstallBundle(System.String,System.IO.Stream)">
            <summary>
            从Manifest.xml文件流中安装一个模块。
            </summary>
            <param name="location">模块位置，即Manifest.xml所在的目录。</param>
            <param name="stream">Manifest.xml文件流。</param>
            <returns>模块对应的IBundle对象。</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IBundleManager.Uninstall(System.String)">
            <summary>
            卸载指定特征名称的模块。
            </summary>
            <param name="bundleSymbolicName">模块特征名称。</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IBundleManager.Update(System.String)">
            <summary>
            更新指定特征名称的模块。
            </summary>
            <param name="bundleSymbolicName">模块特征名称。</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IBundleManager.Start(System.String)">
            <summary>
            使用General方式启动指定模块。
            </summary>
            <param name="bundleSymbolicName">模块特征名称。</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IBundleManager.Stop(System.String)">
            <summary>
            使用General方式停止指定模块。
            </summary>
            <param name="bundleSymbolicName">模块特征名称。</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IBundleManager.Start(System.String,UIShell.OSGi.BundleStartOptions)">
            <summary>
            使用指定模式来启动指定模块。
            </summary>
            <param name="bundleSymbolicName">模块特征名称。</param>
            <param name="option">启动选项。</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IBundleManager.Stop(System.String,UIShell.OSGi.BundleStopOptions)">
            <summary>
            使用指定模式来停止指定模块。
            </summary>
            <param name="bundleSymbolicName">模块特征名称。</param>
            <param name="option">停止选项。</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IBundleManager.GetAllBundles">
            <summary>
            获取所有模块。
            </summary>
            <returns>模块列表。</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IBundleInstallerService.FindBundleContainPath(System.String)">
            <summary>
            查找包含指定path的Bundle
            </summary>
            <param name="path">要查找的Path</param>
            <returns>查找到满足条件的第一个BundleData</returns>
        </member>
        <member name="P:UIShell.OSGi.Core.Service.IBundleInstallerService.UpdateFolder">
            <summary>
            获取更新文件的下载路径
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.BundleManager.InstallBundle(System.String)">
            <summary>
            安装一个Bundle。
            1 检查是否存在指定location的Bundle，若存在，直接返回。
            2 读取Bundle内容，验证Bundle，若失败，则抛出异常。
            3 分配Bundle需要的最小资源——ID和持久存储。
            4 设置为Install状态。
            5 触发Install事件。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Core.Service.Impl.ExtensionManager.Extensions">
            <summary>
            所有扩展的信息，key是扩展点，value是扩展点的扩展集合。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Core.Service.Impl.ExtensionManager.ExtensionPoints">
            <summary>
            所有扩展点信息。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Core.Service.IStartLevelManager">
            <summary>
            启动级别管理器服务，用于控制模块的启动顺序和级别。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IStartLevelManager.ChangeBundleStartLevel(UIShell.OSGi.IBundle,System.Int32)">
            <summary>
            变更某一个模块的启动级别。
            </summary>
            <param name="bundle">指定模块。</param>
            <param name="startLevel">启动级别。</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.IStartLevelManager.ChangeStartLevel(System.Int32)">
            <summary>
            变更系统的启动级别。
            </summary>
            <param name="startLevel">启动级别。</param>
        </member>
        <member name="P:UIShell.OSGi.Core.Service.IStartLevelManager.InitialBundleStartLevel">
            <summary>
            模块默认启动级别，即模块没有指定启动级别的默认值。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Core.Service.IStartLevelManager.StartLevel">
            <summary>
            内核启动基本，只有低于或等于此级别的Bundle才能启动。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.BundleInstallerService.CreateBundleData(System.String,System.IO.Stream)">
            <summary>
            Registers the bundle from stream.
            </summary>
            <param name="bundleDir">The bundle dir.</param>
            <param name="stream">The stream of Bundle Manifest.</param>
            <returns></returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.BundleInstallerService.GetBundlePath(System.String)">
            <summary>
            获取一个BundleData拷贝模板后的目录。
            </summary>
            <param name="symbolicName">要查询的bundle的symbolicName。</param>
            <returns>BundleData拷贝模板后的目录。</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.BundleInstallerService.FindBundleContainPath(System.String)">
            <summary>
            查找包含指定path的Bundle
            </summary>
            <param name="path">要查找的Path</param>
            <returns>查找到满足条件的第一个BundleData</returns>
        </member>
        <member name="P:UIShell.OSGi.Core.Service.Impl.BundleInstallerService.BundleDatas">
            <summary>
            保存解析后的所有BundleData（包含片段bundle），Key是Bundle的SymbolicName。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.AddService(UIShell.OSGi.IBundle,UIShell.OSGi.Configuration.BundleManifest.ServiceData,UIShell.OSGi.Utility.Func{System.String,System.Type})">
            <summary>
            将serviceData中的Service定义注册到ServiceManager中
            </summary>
            <param name="owner"></param>
            <param name="serviceData"></param>
            <param name="loadClass"></param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.RemoveServiceByOwner(UIShell.OSGi.IBundle)">
            <summary>
            删除所有Owner 注册的Service instances
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.GetOrCreateInstanceCollection(System.Type)">
            <summary>
            根据指定的serviceType查找注册的service instance集合。
            </summary>
            <param name="serviceType">service的类型</param>
            <returns>注册的service instance集合</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.GetOrCreateInstanceCollection(System.String,UIShell.OSGi.Utility.Func{System.String,System.Type})">
            <summary>
            根据指定的serviceType查找注册的service instance集合。
            </summary>
            <param name="serviceType">service的类型</param>
            <param name="classLoader">serviceType的类加载器。</param>
            <returns>注册的service instance集合</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.ObjectCreator`1.#ctor(UIShell.OSGi.IBundle,System.String,UIShell.OSGi.Utility.Func{System.String,`0})">
            <summary>
            指定创建对象所需的class type，和创建器
            </summary>
            <param name="owner"></param>
            <param name="classType"></param>
            <param name="creator"></param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.ObjectCreator`1.#ctor(UIShell.OSGi.IBundle,`0)">
            <summary>
            指定对象，不需要再次创建了
            </summary>
            <param name="owner"></param>
            <param name="instance"></param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.ObjectCreator`1.GetOrCreateInstance">
            <summary>
            获取或尝试创建对象,如果对象不存在，则尝试创建
            </summary>
            <returns></returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.ObjectCreator`1.GetOrCreateInstance(System.Boolean)">
            <summary>
            获取或尝试创建对象
            </summary>
            <returns></returns>
        </member>
        <member name="T:UIShell.OSGi.Core.Service.Impl.ServiceManager.InterfaceHolder">
            <summary>
            Service类型的包装类，可以接受原始的Type类型，在通过代码方式注册Service时需要；
            也可以接受string 类型的service接口，当第一次获取service时会尝试创建。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.InterfaceHolder.Match(System.String)">
            <summary>
            检查是否和当前Service类型匹配
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.InterfaceHolder.GetServiceType">
            <summary>
            创建或获取Service Interface类型，如果Interface没有创建，则会尝试创建
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.InterfaceHolder.GetServiceType(System.Boolean)">
            <summary>
            创建或获取Service Interface类型
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Core.Service.Impl.ServiceManager.ServiceInstancesHolder">
            <summary>
            Service Interfaces对应的instance 集合的包装类
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.ServiceInstancesHolder.RemoveAll(UIShell.OSGi.IBundle)">
            <summary>
            删除所有Owner为 owner的对象
            </summary>
            <returns>删除的Instance</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.ServiceInstancesHolder.Add(UIShell.OSGi.IBundle,System.Object)">
            <summary>
            注册Service的Instance
            </summary>
            <param name="owner"></param>
            <param name="serviceInstance"></param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.ServiceInstancesHolder.AddRange(UIShell.OSGi.IBundle,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            注册Service的Instance
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.ServiceInstancesHolder.AddClass(UIShell.OSGi.IBundle,System.String,UIShell.OSGi.Utility.Func{System.String,System.Object})">
            <summary>
            注册Service的Instance的class type和instance的创建器
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.ServiceInstancesHolder.GetServiceInstances(System.Boolean)">
            <summary>
            获取所有保存的Service Instances，并会根据allowCreate的设置确定是否尝试创建没有构建出来的instance。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.ServiceInstancesHolder.GetServiceInstances">
            <summary>
            获取所有保存的Service Instances，并尝试创建没有构建出来的instance。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Core.Service.Impl.ServiceManager.FindServiceResult">
            <summary>
            Service查找结果的包装
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.FindServiceResult.#ctor(System.Collections.Generic.Dictionary{UIShell.OSGi.Core.Service.Impl.ServiceManager.InterfaceHolder,UIShell.OSGi.Core.Service.Impl.ServiceManager.ServiceInstancesHolder},UIShell.OSGi.Core.Service.Impl.ServiceManager.InterfaceHolder)">
            <summary>
            构造一个FindServiceResult对象。
            </summary>
            <param name="container">原始的service容器，对本容器的操作都是线程安全的。</param>
            <param name="key">查找到的Key</param>
        </member>
        <member name="P:UIShell.OSGi.Core.Service.Impl.ServiceManager.FindServiceResult.Container">
            <summary>
            原始的service容器，对本容器的操作都是线程安全的。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Core.Service.Impl.ServiceManager.FindServiceResult.Key">
            <summary>
            查找到的Key
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Core.Service.Impl.ServiceManager.FindServiceResult.Value">
            <summary>
            查找到的值
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.ServiceCollection.RemoveServiceInstance(UIShell.OSGi.IBundle,System.Object)">
            <summary>
            删除所有的service instance
            </summary>
            <returns>此instance所注册的service interfaces集合</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.ServiceCollection.RemoveServiceInstance(UIShell.OSGi.IBundle,System.Type,System.Object)">
            <summary>
            从ServiceType为serviceType的instance 列表删除所有的service instance
            </summary>
            <returns>删除的次数</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.ServiceCollection.RemoveServiceInstance(UIShell.OSGi.IBundle,System.Type)">
            <summary>
            从ServiceType为serviceType的instance 列表删除所有的service instance
            </summary>
            <returns>删除的次数</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.ServiceCollection.Find``1(System.String,UIShell.OSGi.Utility.Func{UIShell.OSGi.Core.Service.Impl.ServiceManager.InterfaceHolder},UIShell.OSGi.Utility.Func{UIShell.OSGi.Core.Service.Impl.ServiceManager.FindServiceResult,``0})">
            <summary>
            查找serviceType注册的Key,如果没有找到，并且creator不为null，则会用creator创建一个Key-Value保存本集合中
            </summary>
            <param name="serviceType">要查找的serviceType</param>
            <param name="creator">如果没有找到serviceType注册的Key,并且creator不为null，则会用creator创建一个Key-Value保存本集合中，可以为null</param>
            <param name="func">如果查找到对应的Service，则会以线程安全的方式调用func函数进行处理。</param>
            <returns>如果根据serviceType没有找到，并且creator为null，则返回null，否则返回找到或创建的Key</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.ServiceCollection.Find``1(System.Type,System.Boolean,UIShell.OSGi.Utility.Func{UIShell.OSGi.Core.Service.Impl.ServiceManager.FindServiceResult,``0})">
            <summary>
            查找serviceType注册的Key,如果没有找到，并且createIfNotFound==true，则会创建一个Key-Value保存本集合中
            </summary>
            <param name="serviceType">要查找的serviceType</param>
            <param name="createIfNotFound">指定当没有找到Key时，是否需要创建一个</param>
            <param name="func">如果查找到对应的Service，则会以线程安全的方式调用func函数进行处理。</param>
            <returns>如果根据serviceType没有找到，并且createIfNotFound==false，则返回null，否则返回找到或创建的Key</returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.ServiceManager.ServiceCollection.Find``1(UIShell.OSGi.Utility.Func{UIShell.OSGi.Core.Service.Impl.ServiceManager.InterfaceHolder,System.Boolean},UIShell.OSGi.Utility.Func{UIShell.OSGi.Core.Service.Impl.ServiceManager.InterfaceHolder},UIShell.OSGi.Utility.Func{UIShell.OSGi.Core.Service.Impl.ServiceManager.FindServiceResult,``0})">
            <summary>
            根据comparer查找指定Key
            </summary>
            <param name="comparer">条件比较器</param>
            <param name="creator">可以为null，如果没有查到，并且creator不为null，则创建一个新的Key-Value到本集合</param>
            <param name="func">如果查找到对应的Service，则会以线程安全的方式调用func函数进行处理。</param>
        </member>
        <member name="P:UIShell.OSGi.Core.Service.Impl.StartLevelManager.StartLevel">
            <summary>
            Framework启动基本，只有低于或等于此级别的Bundle才能启动
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.Impl.BundleDelta">
            <summary>
            Bundle的变更记录。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.IBundleDelta">
            <summary>
            Bundle变更记录。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.IBundleDelta.Bundle">
            <summary>
            发生变更的Bundle。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.IBundleDelta.Type">
            <summary>
            变更类型。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Dependency.Impl.BundleDelta.#ctor(UIShell.OSGi.Dependency.Metadata.IBundleMetadata,UIShell.OSGi.Dependency.BundleDeltaType)">
            <summary>
            构建一个Bundle变更记录。
            </summary>
            <param name="bundleMetadata">Bundle元数据。</param>
            <param name="deltaType">变更类型。</param>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Impl.BundleDelta.Bundle">
            <summary>
            发生变更的Bundle。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Impl.BundleDelta.Type">
            <summary>
            变更类型。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.Impl.StateDelta">
            <summary>
            系统解析状态的变更。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.IStateDelta">
            <summary>
            解析状态变更情况。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Dependency.IStateDelta.RecordBundleAdded(UIShell.OSGi.Dependency.Metadata.IBundleMetadata)">
            <summary>
            记录添加一个Bundle。
            </summary>
            <param name="bundle">添加的Bundle。</param>
        </member>
        <member name="M:UIShell.OSGi.Dependency.IStateDelta.RecordBundleResolved(UIShell.OSGi.Dependency.Metadata.IBundleMetadata)">
            <summary>
            记录解析一个Bundle。
            </summary>
            <param name="bundle">解析的Bundle。</param>
        </member>
        <member name="M:UIShell.OSGi.Dependency.IStateDelta.RecordBundleUnresolved(UIShell.OSGi.Dependency.Metadata.IBundleMetadata)">
            <summary>
            记录反解析一个Bundle。
            </summary>
            <param name="bundle">反解析的Bundle。</param>
        </member>
        <member name="M:UIShell.OSGi.Dependency.IStateDelta.RecordBundleRemovalPending(UIShell.OSGi.Dependency.Metadata.IBundleMetadata)">
            <summary>
            记录挂起删除一个Bundle。
            </summary>
            <param name="bundle">删除挂起的Bundle。</param>
        </member>
        <member name="M:UIShell.OSGi.Dependency.IStateDelta.RecordBundleRemoved(UIShell.OSGi.Dependency.Metadata.IBundleMetadata)">
            <summary>
            记录一个Bundle删除完成。
            </summary>
            <param name="bundle">删除完成的Bundle。</param>
        </member>
        <member name="P:UIShell.OSGi.Dependency.IStateDelta.State">
            <summary>
            发生变更的解析状态。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.IStateDelta.Changes">
            <summary>
            Bundle变更集合。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Impl.StateDelta.State">
            <summary>
            解析状态。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Impl.StateDelta.Changes">
            <summary>
            变更情况。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Dependency.Resolver.IResolvable.Resolve">
            <summary>
            尝试解析约束
            </summary>
            <returns>解析成功或者可解析的（即没有解析失败）</returns>
        </member>
        <member name="M:UIShell.OSGi.Dependency.Resolver.IResolvable.Unresolve">
            <summary>
            反解析约束
            </summary>
            <returns>是否反解析成功</returns>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Resolver.Impl.ConstraintNode.ResolveNodeSource">
            <summary>
            指定尝试解析一个约束时，应该从哪里获取满足约束的节点，比如对于DependentBundleConstraintNode，
            应该仅仅从ResolvedNodes中获取，也就是说，满足约束的节点，必须是已经解析的，
            而对于DependentAssemblyConstraintNode，能够满足约束的集合应该是：UnResolverNodes+ResolvedNodes，
            这样做是因为对于Assembly而言，只要Assembly本身能满足，我们就认为可以满足约束，这是为了尽量能够容错，并让系统更加健壮。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Resolver.Impl.DependentBundleConstraintNode.ResolveNodeSource">
            <summary>
            指定尝试解析一个约束时，应该从哪里获取满足约束的节点，比如对于DependentBundleConstraintNode，
            应该仅仅从ResolvedNodes中获取，也就是说，满足约束的节点，必须是已经解析的，
            而对于DependentAssemblyConstraintNode，能够满足约束的集合应该是：UnResolverNodes+ResolvedNodes，
            这样做是因为对于Assembly而言，只要Assembly本身能满足，我们就认为可以满足约束，这是为了尽量能够容错，并让系统更加健壮。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.Resolver.Impl.HostConstraintNode">
            <summary>
            todo:对于FragementBundle，即时找不到Host，也没有关系，所以这个HostConstraintNode仍然需要吗？？？
            另外FramgementBundle不需要Resolve。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.IState">
            <summary>
            表示整个OSGi内核解析的状态。它记录了所有的Bundle以及它们的解析结果。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Dependency.IState.AddBundle(UIShell.OSGi.Dependency.Metadata.IBundleMetadata)">
            <summary>
            添加一个Bundle元数据到解析状态。
            </summary>
            <param name="bundle">Bundle元数据。</param>
        </member>
        <member name="M:UIShell.OSGi.Dependency.IState.GetBundleByID(System.Int64)">
            <summary>
            使用ID获取Bundle。
            </summary>
            <param name="bundleID">BundleID。</param>
            <returns>返回指定ID的Bundle。</returns>
        </member>
        <member name="M:UIShell.OSGi.Dependency.IState.GetBundleByLocation(System.String)">
            <summary>
            使用Location获取Bundle。
            </summary>
            <param name="location">指定的Location。</param>
            <returns>返回指定Location的Bundle。</returns>
        </member>
        <member name="M:UIShell.OSGi.Dependency.IState.GetBundleBySymbolicName(System.String)">
            <summary>
            返回指定特征名称的Bundle。
            </summary>
            <param name="symbolicName">特征名称。</param>
            <returns>返回指定特征名称的Bundle集合。</returns>
        </member>
        <member name="M:UIShell.OSGi.Dependency.IState.RemoveBundle(UIShell.OSGi.Dependency.Metadata.IBundleMetadata)">
            <summary>
            删除一个Bundle元数据。
            </summary>
            <param name="bundleMetadata">待删除的Bundle。</param>
        </member>
        <member name="M:UIShell.OSGi.Dependency.IState.AddResolverError(UIShell.OSGi.Dependency.IResolverError)">
            <summary>
            添加解析错误。
            </summary>
            <param name="error">错误。</param>
        </member>
        <member name="M:UIShell.OSGi.Dependency.IState.RemoveResolverError(UIShell.OSGi.Dependency.IResolverError)">
            <summary>
            删除一个错误。
            </summary>
            <param name="error">指定的错误。</param>
        </member>
        <member name="M:UIShell.OSGi.Dependency.IState.Resolve">
            <summary>
            对当前解析状态进行解析。
            </summary>
            <returns>返回解析的变更。</returns>
        </member>
        <member name="M:UIShell.OSGi.Dependency.IState.ResolveBundle(UIShell.OSGi.Dependency.Metadata.IBundleMetadata,System.Boolean,UIShell.OSGi.Utility.Tuple{UIShell.OSGi.Dependency.Metadata.IHostConstraint,UIShell.OSGi.Dependency.Metadata.IHostBundleMetadata}[],UIShell.OSGi.Utility.Tuple{UIShell.OSGi.Dependency.Metadata.IDependentBundleConstraint,UIShell.OSGi.Dependency.Metadata.IHostBundleMetadata}[],UIShell.OSGi.Utility.Tuple{UIShell.OSGi.Dependency.Metadata.IDependentAssemblyConstraint,UIShell.OSGi.Dependency.Metadata.IAssemblyMetadata})">
            <summary>
            记录一个Bundle的解析结果。
            </summary>
            <param name="bundle">指定Bundle。</param>
            <param name="isResolved">记录解析结果还是删除解析结果。</param>
            <param name="resolvedHosts">当前Bundle的Host二元组集合。</param>
            <param name="resolvedDependentBundles">解析的Requires二元组集合。</param>
            <param name="resolvedDependentAssemblies">解析的Imports二元组集合。</param>
        </member>
        <member name="P:UIShell.OSGi.Dependency.IState.Changes">
            <summary>
            从上次时间戳开始，解析状态的变更情况。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.IState.SharedAssemblies">
            <summary>
            所有Export元数据。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.IState.IsEmpty">
            <summary>
            解析状态是否包含Bundle。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.IState.IsResolved">
            <summary>
            从上次变更到现在，是否被解析了。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.IState.Resolver">
            <summary>
            解析器。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.IState.MetadataBuilder">
            <summary>
            元数据生成器。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.IState.Bundles">
            <summary>
            当前状态所有Bundle。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.IState.TimeStamp">
            <summary>
            解析状态时间戳。
            </summary>
        </member>
        <member name="E:UIShell.OSGi.Dependency.IState.BundleAdded">
            <summary>
            向解析状态添加一个Bundle时触发的事件。
            </summary>
        </member>
        <member name="E:UIShell.OSGi.Dependency.IState.BundleRemoved">
            <summary>
            从解析状态删除一个Bundle时触发的事件。
            </summary>
        </member>
        <member name="E:UIShell.OSGi.Dependency.IState.BundleRemovalPending">
            <summary>
            从解析状态删除一个具有依赖关系的Bundle，本次删除仅是做一个标记，只有在下次解析时，才会执行真正的删除。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.IResolver">
            <summary>
            Bundle解析器，用于解析Bundle间设计时的依赖关系。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Dependency.IResolver.SortResolvedAssemblyMetadataNodes">
            <summary>
            每次添加了节点到ResolvedAssemblyMetadataNodes都需要进行排序，它用于确保：
            程序集加载时，先使用低版本匹配，如果没有匹配到，再继续匹配。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Dependency.Impl.Resolver.TryResolveBundles(System.Collections.Generic.List{UIShell.OSGi.Dependency.Resolver.IBundleMetadataNode})">
             <summary>
             在下面图标的解析中，假如在队列bundles中的保存顺序是A、B、C、D、E，
             解析算法：
             1，先标志所有节点为Resolvable
             2，解析第一个Bundle节点，
                 a）当发现它解析失败，则标记此节点解析失败，并把所有依赖它的节点递归标记失败,如果是FragementNode，则从HostNode中Detach，
                 b）当发现它解析成功时，解析下一个节点
             3,当所有节点都尝试解析后，解析结束
             A           ->D
               -     -    
                 ->C 
              -     -
            B            ->E
             </summary>
             <param name="bundles"></param>
        </member>
        <member name="M:UIShell.OSGi.Dependency.Impl.Resolver.MarkAsResolvable(UIShell.OSGi.Dependency.Resolver.IBundleMetadataNode)">
            <summary>
            标志一个Bundle是可解析的
            </summary>
            <param name="bundle"></param>
        </member>
        <member name="M:UIShell.OSGi.Dependency.Impl.Resolver.MarkUnResolvable(System.Collections.Generic.List{UIShell.OSGi.Dependency.Resolver.IBundleMetadataNode},UIShell.OSGi.Dependency.Resolver.IBundleMetadataNode[])">
            <summary>
            递归标记此BundleNode及依赖此Bundle的所有Node为IsResovable = false
            </summary>
            <param name="bundles">查找依赖nodes的bundes的范围</param>
            <param name="unresolvedNodes">要标记的BundleNodes</param>
        </member>
        <member name="M:UIShell.OSGi.Dependency.Impl.Resolver.LogUnresolvedNode(UIShell.OSGi.Dependency.Resolver.IFragmentBundleMetadataNode)">
            <summary>
            记录日志：由于dependentNode解析失败，而导致unresolvedNode解析失败
            </summary>
            <param name="unresolvedNode"></param>
        </member>
        <member name="M:UIShell.OSGi.Dependency.Impl.Resolver.LogUnresolvedNode(UIShell.OSGi.Dependency.Resolver.IBundleMetadataNode,UIShell.OSGi.Dependency.Resolver.IBundleMetadataNode)">
            <summary>
            记录日志：由于dependentNode解析失败，而导致unresolvedNode解析失败
            </summary>
            <param name="unresolvedNode"></param>
            <param name="dependentNode"></param>
        </member>
        <member name="M:UIShell.OSGi.Dependency.Impl.Resolver.GetReferencedBundles(System.Collections.Generic.List{UIShell.OSGi.Dependency.Resolver.IBundleMetadataNode},UIShell.OSGi.Dependency.Resolver.IBundleMetadataNode)">
            <summary>
            从指定的bundles集合，获取依赖bundleNode依赖的集合
            </summary>
            <param name="bundles"></param>
            <param name="bundleNode"></param>
            <returns></returns>
        </member>
        <member name="M:UIShell.OSGi.Dependency.Impl.Resolver.GetDependentBundles(System.Collections.Generic.List{UIShell.OSGi.Dependency.Resolver.IBundleMetadataNode},UIShell.OSGi.Dependency.Resolver.IBundleMetadataNode)">
            <summary>
            从指定的bundles集合获取bundleNode依赖的Bundle集合
            </summary>
        </member>
        <member name="T:UIShell.OSGi.LicenseType">
            <summary>
            Framework License 的类型。License文件路径先从AppDomain.CurrentDomain.BaseDirectory查找，
            查找不到，再尝试从程序安装目录查找，如果查找失败，抛出异常。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.LicenseType.AppStoreSDK">
            <summary>
            Developer的SDK,不绑定机器码，一年试用期，不检查Bundle license。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.LicenseType.AppStoreRuntime">
            <summary>
            End user的运行时，不和license绑定，只要有一个有license 的bundle就可以使用。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.LicenseType.UIOSP">
            <summary>
            UIOSP,暂时和SDK策略相同
            </summary>
        </member>
        <member name="F:UIShell.OSGi.LicenseType.iOpenWorksSDK">
            <summary>
            开放工厂SDK许可证，完全免费
            </summary>
        </member>
        <member name="T:UIShell.OSGi.LicenseStatus">
            <summary>
            license的状态
            </summary>
        </member>
        <member name="F:UIShell.OSGi.LicenseStatus.None">
            <summary>
            没有找到合法的license,机器码不匹配等约束不能满足
            </summary>
        </member>
        <member name="F:UIShell.OSGi.LicenseStatus.Trial">
            <summary>
            试用版的license
            </summary>
        </member>
        <member name="F:UIShell.OSGi.LicenseStatus.Valid">
            <summary>
            合法的license
            </summary>
        </member>
        <member name="F:UIShell.OSGi.LicenseStatus.Expried">
             <summary>
            license已过期，但其它约束满足。按照OpenLicense的规范，任意一个Constraint验证失败，GetLicense都返回null，
            但DayTimeConstraint在OSGi中是个特殊的约束，当用户的使用时间过期时，可以允许用户重新购买、激活。
            因此这里把None和Expried分开处理，这样让外部程序可以区分出是否允许用户激活一个过期的License。
             </summary>
        </member>
        <member name="T:UIShell.OSGi.ResourceLoadMode">
            <summary>
            资源加载模式。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.ResourceLoadMode.Local">
            <summary>
            在Bundle本地的Export中搜索资源。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.ResourceLoadMode.LocalAndFragment">
            <summary>
            在Bundle本地和片段的Export中搜索资源。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.ResourceLoadMode.ClassSpace">
            <summary>
            在Bundle的类型空间中搜索资源，此搜索方式与类搜索方式一样。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.BundleStartOptions">
            <summary>
            Bundle启动选项。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleStartOptions.Transient">
            <summary>
            启动后，Bundle运行时重启后不会启动该插件。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleStartOptions.General">
            <summary>
            启动后，Bundle运行时重启后会自动启动该插件。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.BundleStopOptions">
            <summary>
            Bundle停止选项。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleStopOptions.Transient">
            <summary>
            停止后，Bundle运行时重启后不发生变化。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleStopOptions.General">
            <summary>
            停止后，Bundle运行时重启后不再启动该插件。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.BundleState">
            <summary>
            Bundle生命周期状态。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleState.Installed">
            <summary>
            已安装。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleState.Resolved">
            <summary>
            成功解析所有依赖。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleState.Starting">
            <summary>
            正在启动。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleState.Active">
            <summary>
            处于运行状态。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleState.Stopping">
            <summary>
            正在停止。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleState.Uninstalled">
            <summary>
            已经卸载，Bundle运行时重启后该插件将被彻底卸载。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.DefaultBundleState">
            <summary>
            Bundle的默认状态，
            Bundle被加载后，是否立即启动取决于：
            1 如果Bundle的持久存储中已经指定，则采用此设置；
            2 如果Bundle的Manifest中指定了InitializedState，则采用此设置；
            3 如果以上都没有指定，则采用此设置，并且BundleStartOptions，BundleStopOptions为Transient。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.DefaultBundleState.Active">
            <summary>
            默认为激活。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.DefaultBundleState.Installed">
            <summary>
            默认只安装。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleInitializedState.Installed">
            <summary>
            安装状态。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleInitializedState.Active">
            <summary>
            激活状态。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.CollectionChangedAction">
            <summary>
            集合变更活动。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.CollectionChangedAction.Add">
            <summary>
            添加一个项。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.CollectionChangedAction.Remove">
            <summary>
            删除一个项。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.BundleType">
            <summary>
            Bundle类型。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleType.Fragment">
            <summary>
            这是一个片段插件。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.BundleType.Host">
            <summary>
            这是一个宿主插件。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Configuration.BundleManifest.ActivatorData">
            <summary>
            Bundle清单文件的Activator节点定义。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.ActivatorData.Type">
            <summary>
            激活器类型全称。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.ActivatorData.Policy">
            <summary>
            激活策略。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Configuration.BundleManifest.ActivatorPolicy">
            <summary>
            Bundle激活策略。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Configuration.BundleManifest.ActivatorPolicy.Immediate">
            <summary>
            立即激活，即当Bundle被Start后，直接运行激活器执行激活。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Configuration.BundleManifest.ActivatorPolicy.Lazy">
            <summary>
            晚激活，即Bundle被Start后，并不激活，直到从该Bundle加载资源。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Configuration.BundleManifest.AssemblyData">
            <summary>
            表示一个Assembly配置。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.AssemblyData.Path">
            <summary>
            指定程序集的路径。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.AssemblyData.Share">
            <summary>
            是否向其它Bundle共享程序集。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.AssemblyData.MultipleVersions">
            <summary>
            该程序集是否启用多版本支持。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Configuration.BundleManifest.BundleData">
            <summary>
            Bundle配置信息节点。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Configuration.BundleManifest.BundleData.AddService(UIShell.OSGi.Configuration.BundleManifest.ServiceData)">
            <summary>
            添加一个服务定义。
            </summary>
            <param name="newItem">服务定义。</param>
        </member>
        <member name="M:UIShell.OSGi.Configuration.BundleManifest.BundleData.AddExtension(UIShell.OSGi.Configuration.BundleManifest.ExtensionData)">
            <summary>
            添加一个可扩展点。
            </summary>
            <param name="newItem">可扩展点。</param>
        </member>
        <member name="M:UIShell.OSGi.Configuration.BundleManifest.BundleData.AddExtensionPoint(UIShell.OSGi.Configuration.BundleManifest.ExtensionPointData)">
            <summary>
            添加一个扩展点。
            </summary>
            <param name="newItem">扩展点。</param>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleData.Name">
            <summary>
            Bundle名称。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleData.StartLevel">
            <summary>
            启动级别。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleData.SymbolicName">
            <summary>
            特征名称。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleData.Version">
            <summary>
            Bundle版本。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleData.InitializedState">
            <summary>
            初始状态。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleData.HostBundleSymbolicName">
            <summary>
            宿主Bundle的特征名称。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleData.HostBundleVersion">
            <summary>
            宿主Bundle所在版本范围。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleData.BundleInfo">
            <summary>
            Bundle基本信息。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleData.Activator">
            <summary>
            Bundle激活器。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleData.Runtime">
            <summary>
            Runtime定义。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleData.Services">
            <summary>
            Bundle服务。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleData.Path">
            <summary>
            Bundle所在的目录
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Configuration.BundleManifest.BundleInfoData">
            <summary>
            Bundle基本信息节点。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleInfoData.Category">
            <summary>
            Bundle分类。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleInfoData.Description">
            <summary>
            Bundle描述。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleInfoData.Author">
            <summary>
            Bundle作者。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleInfoData.ContactAddress">
            <summary>
            Bundle作者联系地址。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleInfoData.Copyright">
            <summary>
            Bundle的版权信息。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleInfoData.ManifestVersion">
            <summary>
            Bundle配置清单版本。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleInfoData.DocumentLocation">
            <summary>
            Bundle文档的位置。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.BundleInfoData.UpdateLocation">
            <summary>
            Bundle更新包所在的位置。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Configuration.BundleManifest.DependencyData">
            <summary>
            表示一个Dependency。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.DependencyData.BundleSymbolicName">
            <summary>
            依赖的Bundle的特征名称。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.DependencyData.BundleVersion">
            <summary>
            依赖的Bundle的版本范围。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.DependencyData.AssemblyName">
            <summary>
            依赖指定Bundle的特定名称的程序集。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.DependencyData.AssemblyVersion">
            <summary>
            依赖指定Bundle的特定版本的程序集。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.DependencyData.Resolution">
            <summary>
            依赖的解析类型，即该依赖必须解析成功或者是可选的。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Configuration.BundleManifest.ExtensionData">
            <summary>
            可扩展点定义。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.ExtensionData.Point">
            <summary>
            可扩展点名称，一般用路径名称或者URL方式定义。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Configuration.BundleManifest.ExtensionPointData">
            <summary>
            扩展点定义。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Configuration.BundleManifest.ResolutionType">
            <summary>
            解析方式。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Configuration.BundleManifest.ResolutionType.Mandatory">
            <summary>
            强制的。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Configuration.BundleManifest.ResolutionType.Optional">
            <summary>
            可选。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Configuration.BundleManifest.RuntimeData">
            <summary>
            Runtime配置节点数据。它定义了本地程序集和依赖的程序集。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Configuration.BundleManifest.RuntimeData.AddAssembly(UIShell.OSGi.Configuration.BundleManifest.AssemblyData)">
            <summary>
            添加一个Assembly节点。
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="M:UIShell.OSGi.Configuration.BundleManifest.RuntimeData.AddDependency(UIShell.OSGi.Configuration.BundleManifest.DependencyData)">
            <summary>
            添加Dependency节点。
            </summary>
            <param name="newItem">新的Dependency节点。</param>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.RuntimeData.Dependencies">
            <summary>
            所有依赖定义。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.RuntimeData.Assemblies">
            <summary>
            所有本地程序集配置。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Configuration.BundleManifest.ServiceData">
            <summary>
            服务定义。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.ServiceData.Interfaces">
            <summary>
            服务接口。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Configuration.BundleManifest.ServiceData.Type">
            <summary>
            服务的全类型。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Configuration.DigesterRule.NextPropertySetterRule">
            <summary>
            把栈顶元素设置为next的属性.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Configuration.DigesterRule.NextPropertySetterRule.#ctor(System.String)">
            <summary>
            Initializes a new PropertySetterRule class with the specified property name.
            </summary>
            <param name="propertyName">The name of the property to set.</param>
        </member>
        <member name="M:UIShell.OSGi.Configuration.DigesterRule.NextPropertySetterRule.ToString">
            <summary>
            Renders a printable version of this Rule.
            </summary>
            <returns>The string that contains a printable version of this Rule.</returns>
        </member>
        <member name="M:UIShell.OSGi.Configuration.DigesterRule.SetServicePropertiesRule.ToString">
            <summary>
            Renders a printable version of this Rule.
            </summary>
            <returns>The string that contains a printable version 
            of this Rule.</returns>
        </member>
        <member name="T:UIShell.OSGi.Configuration.ManifestParser">
            <summary>
            清单解析器，解析每一个Bundle的Manifest文件，返回一个BundleData对象。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Configuration.ManifestParser._bundleDataDigester">
            <summary>
            解析Bundle清单文件的Digester对象。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Configuration.ManifestParser.CreateBundleData(System.String)">
            <summary>
            执行清单文件解析。
            </summary>
            <param name="manifestFile">清单文件位置。</param>
            <returns>对应的BundleData对象。</returns>
        </member>
        <member name="M:UIShell.OSGi.Configuration.ManifestParser.CreateBundleDataDigester">
            <summary>
            创建解析Bundle清单的Digester对象，并注册相应的解析规则。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.BundleMetadataEventArgs">
            <summary>
            Bundle时间参数。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Dependency.BundleMetadataEventArgs.#ctor(UIShell.OSGi.Dependency.Metadata.IBundleMetadata)">
            <summary>
            构建一个参数。
            </summary>
            <param name="bundle">关联的Bundle。</param>
        </member>
        <member name="P:UIShell.OSGi.Dependency.BundleMetadataEventArgs.Metadata">
            <summary>
            关联的Bundle。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.BundleDeltaType">
            <summary>
            Bundle的变更类型。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Dependency.BundleDeltaType.Added">
            <summary>
            新增。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Dependency.BundleDeltaType.Removed">
            <summary>
            删除完成。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Dependency.BundleDeltaType.Resolved">
            <summary>
            解析。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Dependency.BundleDeltaType.Unresolved">
            <summary>
            反解析。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Dependency.BundleDeltaType.RemovalPending">
            <summary>
            删除挂起。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.ResolverErrorType">
            <summary>
            解析错误类型。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Dependency.ResolverErrorType.MissingImportNamespace">
            <summary>
            Import解析失败。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Dependency.ResolverErrorType.MissingRequireBundle">
            <summary>
            Require解析失败。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Dependency.ResolverErrorType.MissingFragmentHost">
            <summary>
            FragmentHost解析失败。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Dependency.ResolverErrorType.FragmentConflict">
            <summary>
            片段冲突。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Dependency.ResolverErrorType.SingletonSelection">
            <summary>
            单件Bundle冲突。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.IResolverError">
            <summary>
            解析Bundle过程发生的错误。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.IResolverError.Bundle">
            <summary>
            发生异常的Bundle。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.IResolverError.Data">
            <summary>
            异常相关数据。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.IResolverError.Type">
            <summary>
            解析错误类型。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.IResolverError.UnsatisfiedConstraint">
            <summary>
            解析失败的约束。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.Metadata.IAssemblyMetadata">
            <summary>
            表示Bundle一个本地程序集元数据。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.Metadata.IMetadata">
            <summary>
            运行时元数据。元数据与约束相对，约束表示依赖的约束，元数据则是满足约束的对象。
            Bundle有3类运行时元数据，即AssemblyPath、Export和Bundle本身；有4类约束，即
            Import、DynamicImport、Require和Host约束。元数据用于满足约束的解析。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IMetadata.Owner">
            <summary>
            拥有该元数据的Bundle。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IMetadata.Version">
            <summary>
            元数据版本。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IAssemblyMetadata.MultipleVersions">
            <summary>
            本地程序集是否启用多版本。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IAssemblyMetadata.Share">
            <summary>
            该程序集是否共享。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IAssemblyMetadata.AssemblyName">
            <summary>
            此Assembly的AssemblyName
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IAssemblyMetadata.ShadowCopyPath">
            <summary>
            路径。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IAssemblyMetadata.IsDuplicatedWithGlobalAssembly">
            <summary>
            如果CLR Loader能够直接加载相同名称的程序集，则使用CLR加载的程序集替换。
            这避免在ASP.NET环境中出现程序集冲突。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.Metadata.IBundleMetadata">
            <summary>
            表示一个Bundle依赖的元数据。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Dependency.Metadata.IBundleMetadata.GetResolvedDependentAssemblies">
            <summary>
            获取成功解析的程序集依赖约束。
            </summary>
            <returns>成功解析的程序集依赖约束。</returns>
        </member>
        <member name="M:UIShell.OSGi.Dependency.Metadata.IBundleMetadata.GetResolvedDependentBundles">
            <summary>
            获取成功解析的Bundle依赖约束。
            </summary>
            <returns>成功解析的Bundle依赖约束。</returns>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IBundleMetadata.SymbolicName">
            <summary>
            Bundle唯一特征名称。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IBundleMetadata.BundleID">
            <summary>
            Bundle的唯一ID。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IBundleMetadata.PrivateAssemblies">
            <summary>
            Bundle的私有程序集集合。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IBundleMetadata.DependentAssemblies">
            <summary>
            Bundle依赖的程序集约束集合。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IBundleMetadata.DependentBundles">
            <summary>
            Bundle依赖的Bundle集合。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IBundleMetadata.IsResolved">
            <summary>
            Bundle的约束是否解析。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IBundleMetadata.SharedAssemblies">
            <summary>
            Bundle的共享程序集。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IBundleMetadata.Location">
            <summary>
            Bundle安装的位置。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.Metadata.IConstraint">
            <summary>
            表示一个约束。约束与元数据相对。约束声明一个Bundle对另一个Bundle的依赖，元数据则是满足
            这个约束的对象。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Dependency.Metadata.IConstraint.IsSatisfiedBy(UIShell.OSGi.Dependency.Metadata.IMetadata)">
            <summary>
            判断一个元数据是否满足约束。
            </summary>
            <param name="metadata">元数据。</param>
            <returns>如果满足，则返回为true；否则返回false。</returns>
        </member>
        <member name="M:UIShell.OSGi.Dependency.Metadata.IConstraint.Reset">
            <summary>
            清空依赖。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IConstraint.Owner">
            <summary>
            所在Bundle。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IConstraint.IsResolved">
            <summary>
            是否解析。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IConstraint.DependentMetadata">
            <summary>
            依赖的元数据,即满足此约束的Metadata。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.Metadata.IDependentAssemblyConstraint">
            <summary>
            一个Bundle依赖另一个Bundle的程序集的约束描述。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IDependentAssemblyConstraint.BundleSymbolicName">
            <summary>
            依赖的Bundle特征名称。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IDependentAssemblyConstraint.BundleVersion">
            <summary>
            Bundle版本范围。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IDependentAssemblyConstraint.AssemblyName">
            <summary>
            依赖的程序集。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IDependentAssemblyConstraint.AssemblyVersion">
            <summary>
            依赖的程序集的版本范围。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IDependentAssemblyConstraint.Resolution">
            <summary>
            是否必须强制解析。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.Metadata.IFragmentBundleMetadata">
            <summary>
            片段Bundle元数据。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IFragmentBundleMetadata.HostConstraint">
            <summary>
            宿主Bundle约束。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.Metadata.IHostBundleMetadata">
            <summary>
            表示一个HostBundle元数据。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IHostBundleMetadata.PostDependents">
            <summary>
            获取依赖这个Bundle的所有Bundle。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IHostBundleMetadata.Fragments">
            <summary>
            包含的片段。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.Metadata.IHostConstraint">
            <summary>
            Host约束，表示一个片段Bundle的宿主约束。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IHostConstraint.BundleSymbolicName">
            <summary>
            宿主Bundle的特征名称。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IHostConstraint.BundleVersion">
            <summary>
            宿主Host的版本范围。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.Impl.BundleMetadata.BundleID">
            <summary>
            BundleID，需要注意的是，Bundle没有安装的时候是没有ID的。
            因此，需要考虑先创建Bundle，然后再建立Metadata，这样ID就可以获取到了。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.Impl.BundleMetadata.SymbolicName">
            <summary>
            Bundle特征名称，该名称必须与其它Bundle区分开来。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.Impl.BundleMetadata.Location">
            <summary>
            Bundle的物理位置。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.Impl.BundleMetadata.IsResolved">
            <summary>
            是否已经解析成功。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.Impl.BundleMetadata.PrivateAssemblies">
            <summary>
            私有本地程序集集合。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.Impl.BundleMetadata.SharedAssemblies">
            <summary>
            共享本地程序集集合。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.Impl.BundleMetadata.DependentAssemblies">
            <summary>
            DependentAssembly约束集合。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.Impl.BundleMetadata.DependentBundles">
            <summary>
            DependentBundle约束集合。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.Impl.Constraint.DependentMetadata">
            <summary>
            依赖的元数据,即满足此约束的Metadata。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.Metadata.IDependentBundleConstraint">
            <summary>
            依赖一个Bundle的约束。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IDependentBundleConstraint.BundleSymbolicName">
            <summary>
            依赖的Bundle的唯一特征名称。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IDependentBundleConstraint.BundleVersion">
            <summary>
            依赖的Bundle的版本范围。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Metadata.IDependentBundleConstraint.Resolution">
            <summary>
            是否必须强制解析。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Dependency.Metadata.Impl.MetadataBuilder">
            <summary>
            元数据生成器。用于从一个BundleData生成相应的Metadata。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Dependency.Metadata.Impl.MetadataBuilder.BuildBundleMetadata(UIShell.OSGi.Configuration.BundleManifest.BundleData,System.Int64)">
            <summary>
            从一个BundleData构建相应的元数据。
            </summary>
            <param name="bundleData">指定的BundleData。</param>
            <param name="bundleID"></param>
            <returns>Bundle元数据。</returns>
        </member>
        <member name="T:UIShell.OSGi.Dependency.ResolvedResult">
             <summary>
             在下面图标的解析中，假如在队列bundles中的保存顺序是A、B、C、D、E，
             那么理论上会Step1解析A；Step2解析B；Step3解析C；Step4解析D；Step5解析E...
             但是在进行Step1解析A时，会先递归解析它依赖的节点C，递归到C时又会递归到D、E节点，
             所以当解析A（Step1）时，实际上会先解析的是D和E，所以一旦发现D解析失败，那么C也必然失败，
             因此就需要把D、E都标志为“已经解析过，但解析失败了”，这样就避免了以后没有必要的尝试解析，因为对于D、E等，无论如何解析都必然失败，
             所以引入ResolvedFailed概念，
             因此对于Resovle动作而言，只有当状态为UnResolved时才会进行
             A           ->D
               -     -    
                 ->C 
              -     -
            B            ->E
             </summary>
        </member>
        <member name="F:UIShell.OSGi.Dependency.ResolvedResult.UnResolved">
            <summary>
            未解析的或者已经成功反解析，并不代表解析失败，仅仅是没有尝试解析过
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Dependency.ResolvedResult.Resolved">
            <summary>
            解析成功。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Dependency.ResolvedResult.ResolvedFailed">
            <summary>
            解析失败
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Dependency.ResolvedResult.ResolvingPendent">
            <summary>
            正在解析中
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Resolver.Impl.DependentAssemblyConstraintNode.ResolveNodeSource">
            <summary>
            对于IDependentAssemblyConstraintNode，能够满足它的只有IAssemblyMetadataNode，
            获取所有
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Resolver.IReferencable.ReferencedConstraints">
            <summary>
            被引用的ConstraintNodes,
            如果A依赖B，则A会保存在B的ReferencedConstraints集合中
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Resolver.IFragmentBundleMetadataNode.HostNode">
            <summary>
            Attach 后，所在的HostNode
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Dependency.Resolver.IHostBundleMetadataNode.IsReferenced">
            <summary>
            是否仍被其它非Fragement bundle引用
            </summary>
            <returns></returns>
        </member>
        <member name="P:UIShell.OSGi.Dependency.Resolver.Impl.FragmentBundleMetadataNode.HostNode">
            <summary>
            Attach 后，所在的HostNode
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Dependency.Resolver.Impl.HostBundleMetadataNode.IsReferenced">
            <summary>
             判断一个IHostBundleNode是否它本身仍被别的Host节点引用，比如作为RequireNode节点的Preference
            </summary>
            <returns></returns>
        </member>
        <member name="T:UIShell.OSGi.NDigester.CallMethodRule">
            <summary>
            Rule implementation that calls a method on the top (parent)
            object, passing arguments collected from subsequent
            <c>CallParamRule</c> rules or from the body of this
            element.
            By using <c>CallMethodRule(String methodName)</c> 
            a method call can be made to a method which accepts no arguments.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.CallMethodRule.#ctor(System.String)">
            <summary>
            Initializes a new instance of the CallMethodRule class with a specified mathod name.
            </summary>
            <param name="methodName">The name of the method to be called.</param>
            <remarks>When only a single methodName specified rule will try to find
            a method without parameters in case of many overloads of the specified method.</remarks>
        </member>
        <member name="M:UIShell.OSGi.NDigester.CallMethodRule.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of the CallMethodRule class with a specified
            mathod name and a number of parameters to be used.
            </summary>
            <param name="methodName">The name of the method to be called.</param>
            <param name="paramCount">The number of parameters used in method invoking.</param>
            <remarks>If a target object contains several overloaded versions of one method 
            the number of parameters helps to define an appropiate overloaded method to call.</remarks>
        </member>
        <member name="M:UIShell.OSGi.NDigester.CallMethodRule.#ctor(System.String,System.Int32,System.Object[])">
            <summary>
            Initializes a new instance of the CallMethodRule class with a specified
            mathod name and a number of parameters to be used.
            </summary>
            <param name="methodName">The name of the method to be called.</param>
            <param name="paramCount">The number of parameters used in method invoking.</param>
            <param name="paramTypes">The mixed array of objects any of type <c>System.Type</c>
            or <c>System.String</c> that describes the types of the input parameters and helps to find
            method with an appropriate signature in case of miltiple overloads.</param>
            <remarks>If a target object contains several overloaded versions of one method 
            the number of parameters helps to define an appropiate overloaded method to call.</remarks>
        </member>
        <member name="M:UIShell.OSGi.NDigester.CallMethodRule.OnBegin">
            <summary>
            Process the start of this element.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.CallMethodRule.OnBody">
            <summary>
            Process the body text of this element.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.CallMethodRule.OnEnd">
            <summary>
            Process the end of this element.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.CallMethodRule.OnFinish">
            <summary>
            Cleans up after parsing is complete.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.CallMethodRule.ToString">
            <summary>
            Renders a printable version of this Rule.
            </summary>
            <returns>The string that contains a printable version of this Rule.</returns>
        </member>
        <member name="T:UIShell.OSGi.NDigester.CallParamRule">
            <summary>
            Rule implementation that saves a parameter from either an attribute of
            this element, or from the element body, to be used in a call generated
            by a surrounding <c>CallMethodRule</c> rule.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.CallParamRule.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the CallParamRule class with the specified
            parameter index.
            </summary>
            <param name="paramIndex">The zero-relative parameter number.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.CallParamRule.#ctor(System.Int32,System.String)">
            <summary>
            Initializes a new instance of the CallParamRule class with the specified
            parameter index and attribute name.
            </summary>
            <param name="paramIndex">The zero-relative parameter number.</param>
            <param name="attribute">The name of the attribute to save.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.CallParamRule.OnBegin">
            <summary>
            Process the start of this element.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.CallParamRule.OnBody">
            <summary>
            Process the body text of this element.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.CallParamRule.OnEnd">
            <summary>
            Process the end of this element.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.CallParamRule.OnFinish">
            <summary>
            Cleans up after parsing is complete.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.CallParamRule.ToString">
            <summary>
            Renders a printable version of this Rule.
            </summary>
            <returns>The string that contains a printable version of this Rule.</returns>
        </member>
        <member name="T:UIShell.OSGi.NDigester.Digester">
            <summary>
            A <strong>Digester</strong> processes an XML input stream by matching a
            series of element nesting patterns to execute Rules that have been added
            prior to the start of parsing.
              
            <p>See the &quot;/doc/manual.htm&quot; for more information.</p>
            <p><strong>IMPLEMENTATION NOTE</strong> - A single Digester instance may
            only be used within the context of a single thread at a time, and a call
            to <c>Parse()</c> must be completed before another can be initiated
            even from the same thread.</p>
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.#ctor">
            <summary>
            Initializes a new instance of the Digester class.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.Parse(System.IO.TextReader)">
            <summary>
            Parse the content of the specified <c>TextReader</c> using this Digester.
            Returns the root element from the object stack (if any).
            </summary>
            <param name="reader"><c>TextReader</c> containing XML data beeing parsed.</param>
            <returns>The root object of the Object Stack.</returns>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.Parse(System.String)">
            <summary>
            Parse the content of the specified <b>file</b> using this Digester.
            Returns the root element from the object stack (if any).
            </summary>
            <param name="path">A path to the file containing XML data beeing parsed.</param>
            <returns>The root object of the Object Stack.</returns>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.Parse(System.Xml.XmlNode)">
            <summary>
            Parse the content of the specified <c>XmlNode</c> using this Digester.
            Returns the root element from the object stack (if any).
            </summary>
            <param name="node"><c>XmlNode</c> containing XML data beeing parsed.</param>
            <returns>The root object of the Object Stack.</returns>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.Parse(System.Xml.XmlReader)">
            <summary>
            Parse the content of the specified <c>XmlReader</c> using this Digester.
            Returns the root element from the object stack (if any).
            </summary>
            <param name="reader"><c>XmlReader</c> containing XML data beeing parsed.</param>
            <returns>The root object of the Object Stack.</returns>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.Clear">
            <summary>
            Cleares the current content of the Object Stack.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.Peek">
            <summary>
            Gets the top object on the Object Stack without removing it.
            If there no object on the Object Stack returns null.
            </summary>
            <returns>The top object on the Object Stack.</returns>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.Pop">
            <summary>
            Pop the top object off of the stack, and return it.
            If there are no objects on the stack, return <c>null</c>.
            </summary>
            <returns>The top object of the Object Stack.</returns>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.Push(System.Object)">
            <summary>
            Push a new object onto the top of the Object Stack.
            </summary>
            <param name="value">The new object to push.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.PeekParameters">
            <summary>
            Gets the parameters on the top of the Parameters Stack without removing it.
            </summary>
            <returns>The top object of the Object Stack.</returns>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.PopParameters">
            <summary>
            Pop the top object representing parameters off of the Parameters Stack, and return it.
            </summary>
            <returns>The object representing parameters.</returns>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.PushParameters(System.String[])">
            <summary>
            Pushes object representing parameters to the Parameters Stack.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddRule(System.String,UIShell.OSGi.NDigester.Rule)">
            <summary>
            Register a new Rule matching the specified pattern.
            This method sets the <c>Digester</c> property on the rule.
            </summary>
            <param name="pattern">The element matching pattern.</param>
            <param name="rule">The rule to be registered.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddRuleSet(System.Type)">
            <summary>
            Register a rule set with specified rule set type.
            </summary>
            <param name="ruleSetType">Specified rule set.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddRuleSet(UIShell.OSGi.NDigester.RuleSet)">
            <summary>
            Register a rule set.
            </summary>
            <param name="ruleSet">Specified RuleSet.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddPropertySetter(System.String)">
            <summary>
            Adds an "object property setter" rule for the specified parameters.
            </summary>
            <param name="pattern">The element matching pattern.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddPropertySetter(System.String,System.String)">
            <summary>
            Adds an "object property setter" rule for the specified parameters.
            </summary>
            <param name="pattern">The element matching pattern.</param>
            <param name="propertyName">The name of the property to set.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddCallMethod(System.String,System.String)">
            <summary>
            Adds a "call method" rule for the specified parameters.
            </summary>
            <param name="pattern">The element matching pattern.</param>
            <param name="methodName">The name of the method to be called.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddCallMethod(System.String,System.String,System.Int32)">
            <summary>
            Adds a "call method" rule for the specified parameters.
            </summary>
            <param name="pattern">The element matching pattern.</param>
            <param name="methodName">The name of the method to be called.</param>
            <param name="paramCount">The number of expected parameters (or zero for a single parameter from the body of this element).</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddCallMethod(System.String,System.String,System.Int32,System.Object[])">
            <summary>
            Adds a "call method" rule for the specified parameters.
            </summary>
            <param name="pattern">The element matching pattern.</param>
            <param name="methodName">The name of the method to be called.</param>
            <param name="paramCount">The number of expected parameters (or zero for a single parameter from the body of this element).</param>
            <param name="paramTypes">The array of types describing method parameters.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddCallParam(System.String,System.Int32)">
            <summary>
            Adds a "call parameter" rule for the specified parameters.
            </summary>
            <param name="pattern">The element matching pattern.</param>
            <param name="paramIndex">The zero-relative parameter index to set
            (from the specified attribute).</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddCallParam(System.String,System.Int32,System.String)">
            <summary>
            Adds a "call parameter" rule for the specified parameters.
            </summary>
            <param name="pattern">The element matching pattern.</param>
            <param name="paramIndex">The zero-relative parameter index to set
            (from the specified attribute).</param>
            <param name="attribute">The attribute whose value is used as the
            parameter value.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddObjectCreate(System.String,System.Type)">
            <summary>
            Adds an "create object" rule for the specified parameters.
            </summary>
            <param name="pattern">The element matching pattern.</param>
            <param name="type">The <c>Type</c> of the object to create.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddObjectCreate(System.String,System.String)">
            <summary>
            Adds an "create object" rule for the specified parameters.
            </summary>
            <param name="pattern">The element matching pattern.</param>
            <param name="typeName">The value of type <c>System.String</c>
            that specifies the type of the object to create.</param>
            <remarks>The <c>typeName</c> of the object to create must be a fully qualified type name
            in the format &quot;MyCompany.MyProduct.MyType, MyAssembly&quot;.</remarks>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddObjectCreate(System.String,System.Type,System.String)">
            <summary>
            Adds an "create object" rule for the specified parameters.
            </summary>
            <param name="pattern">The element matching pattern.</param>
            <param name="type">The <c>Type</c> of the object to create.</param>
            <param name="attribute">The element's attribute name that optionally overrides
            the default type to be created.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddObjectCreate(System.String,System.String,System.String)">
            <summary>
            Adds an "create object" rule for the specified parameters.
            </summary>
            <param name="pattern">The element matching pattern.</param>
            <param name="typeName">The value of type <c>System.String</c>
            that specifies the type of the object to create.</param>
            <param name="attribute">The element's attribute name that optionally overrides
            the default type to be created.</param>
            <remarks>The <c>typeName</c> of the object to create must be a fully qualified type name
            in the format &quot;MyCompany.MyProduct.MyType, MyAssembly&quot;.</remarks>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddSetNext(System.String,System.String)">
            <summary>
            Adds a "set next" rule for the specified parameters.
            </summary>
            <param name="pattern">The element matching pattern.</param>
            <param name="methodName">The method name to call on the parent object.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddSetTop(System.String,System.String)">
            <summary>
            Adds a "set top" rule for the specified parameters.
            </summary>
            <param name="pattern">The element matching pattern.</param>
            <param name="methodName">The method name to call on the parent object.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddSetRoot(System.String,System.String)">
            <summary>
            Adds a "set root" rule for the specified parameters.
            </summary>
            <param name="pattern">The element matching pattern.</param>
            <param name="methodName">The method name to call on the root object.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddSetProperties(System.String)">
            <summary>
            Adds a "set properties" rule for the specified parameters.
            </summary>
            <param name="pattern">The element matching pattern.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.AddSetProperty(System.String,System.String,System.String)">
            <summary>
            Adds a "set property" rule for the specified parameters.
            </summary>
            <param name="pattern">The element matching pattern.</param>
            <param name="name">The attribute name containing the property name to be set.</param>
            <param name="value">The attribute name containing the property value to set.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.Configure(System.String)">
            <summary>
            Configure the current instance of the Digester with a configuration data
            stored in the specified XML-file.
            </summary>
            <param name="path">A path to the XML-file containing configuration data.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.Configure(System.Xml.XmlNode)">
            <summary>
            Configure the current instance of the Digester with a configuration data
            stored in the specified <c>XmlNode</c>.
            </summary>
            <param name="node">A <c>XmlNode</c> containing configuration data.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.Configure(System.IO.TextReader)">
            <summary>
            Configure the current instance of the Digester with a configuration data
            stored in the specified <c>TextReader</c>.
            </summary>
            <param name="reader">A <c>TextReader</c> containing configuration data.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Digester.Configure(System.Xml.XmlReader)">
            <summary>
            Configure the current instance of the Digester with a configuration data
            stored in the specified <c>XmlReader</c>.
            </summary>
            <param name="reader">A <c>XmlReader</c> containing configuration data.</param>
        </member>
        <member name="P:UIShell.OSGi.NDigester.Digester.Attributes">
            <summary>
            Gets attributes of the current element.
            Primarily used inside of the <c>OnBegin()</c> method of rules.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.NDigester.Digester.Body">
            <summary>
            Gets the collected body of the current element.
            Primarily used inside of the <c>OnBody()</c> method of rules.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.NDigester.Digester.ElementName">
            <summary>
            Gets the name of the current element. Primarily used in the rules logic.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.NDigester.Digester.Match">
            <summary>
            Gets the current <b>match</b> string.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.NDigester.Digester.Rules">
            <summary>
            Gets the collection of rules defined in the current <b>Digester</b>.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.NDigester.Digester.Root">
            <summary>
            Gets the root object of the Object Stack.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.NDigester.Digester.Depth">
            <summary>
            Gets the current depth of the Object Stack.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.NDigester.IRules">
            <summary>
            Public interface defining a collection of Rule instances (and corresponding
            matching patterns) plus an implementation of a matching policy that selects
            the rules that match a particular pattern of nested elements discovered
            during parsing.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.IRules.Add(System.String,UIShell.OSGi.NDigester.Rule)">
            <summary>
            Registeres a new Rule instance matching the specified pattern.
            </summary>
            <param name="pattern">The nesting pattern to be matched for this Rule.</param>
            <param name="rule">The rule instance to be registered.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.IRules.Clear">
            <summary>
            Clears all existing Rule instance registrations.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.IRules.Match(System.String)">
            <summary>
            Returns a List of all registered Rule instances that match the specified
            nesting pattern, or a zero-length List if there are no matches.  If more
            than one Rule instance matches, they <strong>must</strong> be returned
            in the order originally registered through the <c>add()</c>
            method.
            </summary>
            <param name="pattern">The nesting pattern to be matched.</param>
            <returns>The list of all registered Rule instances that match the specified
            nesting pattern</returns>
        </member>
        <member name="M:UIShell.OSGi.NDigester.IRules.Match(System.String,System.String)">
            <summary>
            Returns an IList of all registered Rule instances that match the specified
            nesting pattern, or a zero-length List if there are no matches.  If more
            than one Rule instance matches, they <strong>must</strong> be returned
            in the order originally registered through the <c>add()</c>
            method.
            </summary>
            <param name="namespaceURI">The nesting pattern to be matched.</param>
            <param name="pattern">AssemblyName URI for which to select matching rules, 
            or <c>null</c> to match regardless of namespace URI.</param>
            <returns>The list of all registered Rule instances that match the specified
            nesting pattern</returns>
        </member>
        <member name="M:UIShell.OSGi.NDigester.IRules.GetRules">
            <summary>
            Returns an IList of all registered Rule instances, or a zero-length List
            if there are no registered Rule instances.  If more than one Rule
            instance has been registered, they <strong>must</strong> be returned
            in the order originally registered through the <c>add()</c>
            method.
            </summary>
            <returns>The list of all registered Rule instances.</returns>
        </member>
        <member name="P:UIShell.OSGi.NDigester.IRules.Digester">
            <summary>
            Gets or sets the Digester instance with which this IRules instance is
            associated.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.NDigester.IRules.NamespaceURI">
            <summary>
            Gets or sets the namespace URI that will be applied to all subsequently
            added <c>Rule</c> objects.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.NDigester.IRuleSet">
            <summary>
            <p>Public interface defining a shorthand means of configuring a complete
            set of related <c>Rule</c> definitions, possibly associated with
            a particular namespace URI, in one operation.  To use an instance of a
            class that imlements this interface:</p>
            <ul>
            <li>Create a concrete implementation of this interface.</li>
            <li>Optionally, you can configure a <c>IRuleSet</c> to be relevant
                only for a particular namespace URI by configuring the value to be
                returned by <c>NamespaceURI()</c> property.</li>
            <li>As you are configuring your Digester instance, call
                <c>digester.AddRuleSet()</c> and pass the IRuleSet instance.</li>
            <li>Digester will call the <c>AddRules()</c> method of
                your IRuleSet to configure the necessary rules.</li>
            </ul>
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.IRuleSet.AddRules(UIShell.OSGi.NDigester.Digester)">
            <summary>
            Add the set of Rule instances defined in this IRuleSet to the
            specified <c>Digester</c> instance, associating them with
            our namespace URI (if any).  This method should only be called
            by a Digester instance.
            </summary>
            <param name="digester">The Digester instance to which the new Rule instances
             should be added.</param>
        </member>
        <member name="P:UIShell.OSGi.NDigester.IRuleSet.NamespaceURI">
            <summary>
            Gets the namespace URI that will be applied to all Rule instances
            created from this IRuleSet.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.NDigester.ObjectCreateRule">
            <summary>
            Rule implementation that creates a new object and pushes it
            onto the <b>Object Stack</b>.  When the element is complete, the
            object will be popped.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.ObjectCreateRule.#ctor(System.String)">
            <summary>
            Initializes a new instance of the ObjectCreateRule class with a specified
            name of the object's type to be created.
            </summary>
            <param name="typeName">The name of the object type to be created.</param>
            <remarks>The <c>typeName</c> of the object to create must be a fully qualified type name
            in the format &quot;MyCompany.MyProduct.MyType, MyAssembly&quot;.</remarks>
        </member>
        <member name="M:UIShell.OSGi.NDigester.ObjectCreateRule.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the ObjectCreateRule class with a specified
            type of the object to be created.
            </summary>
            <param name="type">The type of the object to be created.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.ObjectCreateRule.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the ObjectCreateRule class with a specified
            name of the object's type to be created and attribute name that can override the
            specified type name.
            </summary>
            <param name="typeName">The name of the object type to be created.</param>
            <param name="attribute">The element's attribute name that optionally overrides
            the default type to be created.</param>
            <remarks>The <c>typeName</c> of the object to create must be a fully qualified type name
            in the format &quot;MyCompany.MyProduct.MyType, MyAssembly&quot;.</remarks>
        </member>
        <member name="M:UIShell.OSGi.NDigester.ObjectCreateRule.#ctor(System.Type,System.String)">
            <summary>
            Initializes a new instance of the ObjectCreateRule class with a specified
            type of the object to be created and attribute name that can override the
            specified type.
            </summary>
            <param name="type">The type of the object to be created.</param>
            <param name="attribute">The element's attribute name that optionally overrides
            the default type to be created.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.ObjectCreateRule.OnBegin">
            <summary>
            Process the start of this element.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.ObjectCreateRule.OnEnd">
            <summary>
            Process the end of this element.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.ObjectCreateRule.ToString">
            <summary>
            Renders a printable version of this Rule.
            </summary>
            <returns>The string that contains a printable version of this Rule.</returns>
        </member>
        <member name="T:UIShell.OSGi.NDigester.PatternRule">
            <summary>
            Rule implementation that tracks a <b>pattern</b> in case of
            Digester's self-configuring.<br/>
            This rule is always binded to the <b>&lt;pattern value=&quot;pattern_part&quot;&gt;</b> tag
            of the configuration file.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.PatternRule.#ctor(System.String)">
            <summary>
            Initializes a new instance of the PatternRule class
            with the specified attribute name.
            </summary>
            <param name="attribute">The name of the attribute that stores pattern value.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.PatternRule.OnBegin">
            <summary>
            Process the start of this element.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.PatternRule.OnEnd">
            <summary>
            Process the end of this element.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.PatternRule.OnFinish">
            <summary>
            Cleans up after parsing is complete.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.NDigester.PatternRule.Pattern">
            <summary>
            Gets the string representing current pattern.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.NDigester.PropertySetterRule">
             <summary>
             <p>Rule implements sets an object property on the top object of the Object Stack
             to the body text.</p>
            
             <p> The property set:</p>
             <ul><li>can be specified when the rule is created</li>
             <li>or can match the current element when the rule is called.</li></ul>
             </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.PropertySetterRule.#ctor">
            <summary>
            Initializes a new PropertySetterRule class.
            </summary>
            <remarks>When using this constructor rule will set a property with
            a corresponding current element name.</remarks>
        </member>
        <member name="M:UIShell.OSGi.NDigester.PropertySetterRule.#ctor(System.String)">
            <summary>
            Initializes a new PropertySetterRule class with the specified property name.
            </summary>
            <param name="propertyName">The name of the property to set.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.PropertySetterRule.OnBody">
            <summary>
            Process the body text of this element.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.PropertySetterRule.OnEnd">
            <summary>
            Process the end of this element.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.PropertySetterRule.ToString">
            <summary>
            Renders a printable version of this Rule.
            </summary>
            <returns>The string that contains a printable version of this Rule.</returns>
        </member>
        <member name="T:UIShell.OSGi.NDigester.RuleFactoryRule">
            <summary>
            Rule implementation that creates a new instance of the Rule class
            depending of the current element of the configuration info.
            <p>
            This class is used internally by Digester configurator.
            </p>
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.RuleFactoryRule.#ctor(UIShell.OSGi.NDigester.Digester,System.Type,System.Object[])">
            <summary>
            Creates a new instance of the RuleFactoryRule with specified parameters.
            </summary>
            <param name="configDigester">Digester instance beeing configured.</param>
            <param name="ruleType">The type of the Rule instance to create.</param>
            <param name="prms">The array that describes on order, types of the constructor parameters.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.RuleFactoryRule.OnBegin">
            <summary>
            Process the start of this element.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.NDigester.Rules">
             <summary>
             <p>Default implementation of the <c>IRules</c> interface that supports
             the standard rule matching behavior.  This class can also be used as a
             base class for specialized <c>IRules</c> implementations.</p>
            
             <p>The matching policies implemented by this class support two different
             types of pattern matching rules:</p>
             <ul>
             <li><em>Exact Match</em> - A pattern "a/b/c" exactly matches a
                 <c>&lt;c&gt;</c> element, nested inside a <c>&lt;b&gt;</c>
                 element, which is nested inside an <c>&lt;a&gt;</c> element.</li>
             <li><em>Tail Match</em> - A pattern "///\/a/b" matches a
                 <c>&lt;b&gt;</c> element, nested inside an <c>&lt;a&gt;</c>
                  element, no matter how deeply the pair is nested.</li>
             </ul>
             </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Rules.#ctor">
            <summary>
            Initializes a new instance of the Rules class.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Rules.Add(System.String,UIShell.OSGi.NDigester.Rule)">
            <summary>
            Registeres a new Rule instance matching the specified pattern.
            </summary>
            <param name="pattern">The nesting pattern to be matched for this Rule.</param>
            <param name="rule">The rule instance to be registered.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Rules.Clear">
            <summary>
            Clears all existing Rule instance registrations.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Rules.Match(System.String)">
            <summary>
            Returns a List of all registered Rule instances that match the specified
            nesting pattern, or a zero-length List if there are no matches.  If more
            than one Rule instance matches, they <strong>must</strong> be returned
            in the order originally registered through the <c>add()</c>
            method.
            </summary>
            <param name="pattern">The nesting pattern to be matched.</param>
            <returns>The list of all registered Rule instances that match the specified
            nesting pattern</returns>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Rules.Match(System.String,System.String)">
            <summary>
            Returns an IList of all registered Rule instances that match the specified
            nesting pattern, or a zero-length List if there are no matches.  If more
            than one Rule instance matches, they <strong>must</strong> be returned
            in the order originally registered through the <c>add()</c>
            method.
            </summary>
            <param name="namespaceURI">The nesting pattern to be matched.</param>
            <param name="pattern">AssemblyName URI for which to select matching rules, 
            or <c>null</c> to match regardless of namespace URI.</param>
            <returns>The list of all registered Rule instances that match the specified
            nesting pattern</returns>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Rules.GetRules">
            <summary>
            Returns an IList of all registered Rule instances, or a zero-length List
            if there are no registered Rule instances.  If more than one Rule
            instance has been registered, they <strong>must</strong> be returned
            in the order originally registered through the <c>add()</c>
            method.
            </summary>
            <returns>The list of all registered Rule instances.</returns>
        </member>
        <member name="M:UIShell.OSGi.NDigester.Rules.Lookup(System.String,System.String)">
            <summary>
            Return a IList of Rule instances for the specified pattern that also
            match the specified namespace URI (if any).  If there are no such
            rules, return <c>null</c>.
            </summary>
            <param name="namespaceURI">The namespace URI to match, or <c>null</c> to
             select matching rules regardless of namespace URI.</param>
            <param name="pattern">The pattern to be matched.</param>
            <returns>The list of matched rules.</returns>
        </member>
        <member name="P:UIShell.OSGi.NDigester.Rules.Digester">
            <summary>
            Gets or sets the Digester instance with which this Rules instance is associated.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.NDigester.Rules.NamespaceURI">
            <summary>
            Gets or sets the namespace URI for which subsequently added <c>Rule</c>
            objects are relevant, or <c>null</c> for matching independent
            of namespaces.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.NDigester.RuleSet">
            <summary>
            <p>Convenience base class that implements the <c>IRuleSet</c> interface.
            Concrete implementations should list all of their actual rule creation
            logic in the <c>AddRuleSet()</c> implementation.</p>
            </summary>
        </member>
        <member name="F:UIShell.OSGi.NDigester.RuleSet.namespaceURI">
            <summary>
            Holds the namespace URI that all Rule instances created by this RuleSet
            will be associated with.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.RuleSet.AddRules(UIShell.OSGi.NDigester.Digester)">
            <summary>
            Add the set of Rule instances defined in this IRuleSet to the
            specified <c>Digester</c> instance, associating them with
            our namespace URI (if any). This method should only be called
            by a Digester instance.
            </summary>
            <param name="digester">The Digester instance to which the new Rule instances
            should be added.</param>
        </member>
        <member name="P:UIShell.OSGi.NDigester.RuleSet.NamespaceURI">
            <summary>
            Gets or sets the namespace URI that all Rule instances created by this RuleSet
            will be associated with.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.NDigester.SetNextRule">
            <summary>
            <p>Rule implementation that calls a method on the (top-1) (parent)
            object, passing the top object (child) as an argument.  It is
            commonly used to establish parent-child relationships.</p>
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.SetNextRule.#ctor(System.String)">
            <summary>
            Initializes a new instance of the SetNextRule class with the specified
            method name.
            </summary>
            <param name="methodName">The name of the method to be called.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.SetNextRule.OnEnd">
            <summary>
            Process the end of this element.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.SetNextRule.ToString">
            <summary>
            Renders a printable version of this Rule.
            </summary>
            <returns>The string that contains a printable version of this Rule.</returns>
        </member>
        <member name="T:UIShell.OSGi.NDigester.SetPropertyRule">
            <summary>
            Rule implementation that sets an individual property on the object at the
            top of the stack, based on attributes with specified names.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.SetPropertyRule.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the SetPropertyRule class
            with the specified attribute name and attribute value.
            </summary>
            <param name="name">The name of the attribute that will contain the name of the property to be set.</param>
            <param name="value">The name of the attribute that will contain the value to which the property should be set.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.SetPropertyRule.OnBegin">
            <summary>
            Process the start of this element.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.SetPropertyRule.ToString">
            <summary>
            Renders a printable version of this Rule.
            </summary>
            <returns>The string that contains a printable version 
            of this Rule.</returns>
        </member>
        <member name="T:UIShell.OSGi.NDigester.SetRootRule">
            <summary>
            <p>Rule implementation that calls a method on the root object on the stack,
            passing the top object (child) as an argument.
            It is important to remember that this rule acts on <c>end</c>.</p>
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.SetRootRule.#ctor(System.String)">
            <summary>
            Initializes a new instance of the SetRootRule class with the specified
            method name.
            </summary>
            <param name="methodName">The name of the method to be called.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.SetRootRule.OnEnd">
            <summary>
            Process the end of this element.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.SetRootRule.ToString">
            <summary>
            Renders a printable version of this Rule.
            </summary>
            <returns>The string that contains a printable version of this Rule.</returns>
        </member>
        <member name="T:UIShell.OSGi.NDigester.SetTopRule">
            <summary>
            <p>Rule implementation that calls a "set parent" method on the top (child)
            object, passing the (top-1) (parent) object as an argument.</p>
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.SetTopRule.#ctor(System.String)">
            <summary>
            Initializes a new instance of the SetTopRule class with the specified
            method name.
            </summary>
            <param name="methodName">The name of the method to be called.</param>
        </member>
        <member name="M:UIShell.OSGi.NDigester.SetTopRule.OnEnd">
            <summary>
            Process the end of this element.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.NDigester.SetTopRule.ToString">
            <summary>
            Renders a printable version of this Rule.
            </summary>
            <returns>The string that contains a printable version of this Rule.</returns>
        </member>
        <member name="T:UIShell.OSGi.FrameworkEventArgs">
            <summary>
            内核事件。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.FrameworkEventArgs.EventType">
            <summary>
            事件类型。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.FrameworkEventArgs.Target">
            <summary>
            发生事件的对象。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.FrameworkEventArgs.Data">
            <summary>
            事件相关数据。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.FrameworkEventType">
            <summary>
            内核事件类型。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkEventType.Starting">
            <summary>
            正在启动。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkEventType.Started">
            <summary>
            已经启动。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkEventType.Error">
            <summary>
            发生错误。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkEventType.Warning">
            <summary>
            提示警告。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkEventType.Info">
            <summary>
            提示普通信息。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkEventType.Stopping">
            <summary>
            正在停止。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkEventType.Stopped">
            <summary>
            已经停止。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkEventType.ShadowAssemblyChanged">
            <summary>
            加载的程序集原始文件发生变更。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Loader.AssemblyEntry.AssemblyPath">
            <summary>
            Specified the path in ProvidedBy.Paths.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Loader.UseDefaultClrLoaderBehavior">
            <summary>
            Be used to indicate that current thread is using the default class 
            loading behaviors of CLR Loader to load a type/assembly.
            </summary>
            <example>
            using (var loader = new UseDefaultClrLoaderBehavior())
            {
                loader.AssemblyResolve += CustomizedAssemblyResolveHandler;
                return Assembly.Load(Import.AssemblyName);
            }
            </example>
        </member>
        <member name="F:UIShell.OSGi.Loader.UseDefaultClrLoaderBehavior.IsStopClrExtensionLoader">
            <summary>
            The tag is to indicate that current thread will use the default
            CLR loader to load class or not. It is a thread local storage variable.
            <para>
            If IsStopClrExtensionLoader is true, it means that current thread only
            want to load type/assembly by the default behavior of CLR Loader. 
            </para>
            <para>
            When you set AssemblyResolvingProvider.IsStopClrExtensionLoader to true,
            you must reset the value to false after type/assembly loaded. Otherwise
            current thread will always use the default behavior of CLR Loader and can
            not find the type/assembly in bundles.
            </para>
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Loader.UseDefaultClrLoaderBehavior.InternalAssemblyResolve">
            <summary>
            Customized AssemblyResolve event handling.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Loader.UseDefaultClrLoaderBehavior.#ctor">
            <summary>
            Create a UseDefaultClrLoaderBehavior instance and indicate current thread using
            the class loading behaviors of CLR Loader.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Loader.UseDefaultClrLoaderBehavior.Dispose">
            <summary>
            Restore the class loading behavior of current thread to OSGi class loading mech.
            </summary>
        </member>
        <member name="E:UIShell.OSGi.Loader.UseDefaultClrLoaderBehavior.AssemblyResolve">
            <summary>
            Customized AssemblyResolve event handling.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Loader.IRuntimeService.LoadBundleAssembly(System.String)">
            <summary>
            Load 一个Bundle所有的ShareAssembly和PrivateAssembly
            </summary>
            <param name="bundleSymbolicName"></param>
            <returns></returns>
        </member>
        <member name="M:UIShell.OSGi.Loader.IAssemblyResolvingProvider.ResolveAssembly(UIShell.OSGi.Dependency.Metadata.IAssemblyMetadata,System.Reflection.AssemblyName)">
            <summary>
            尝试从IAssemblyMetadata定义的Assembly列表中查找匹配指定AssemblyName 的Assembly
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Loader.IAssemblyResolvingProvider.ResolveAssembly(System.Reflection.AssemblyName)">
            <summary>
            尝试从所有Bundle中查找匹配指定AssemblyName 的Assembly
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Loader.AssemblyResolvingProvider.TryToLoadCoreAssemblies(System.Reflection.AssemblyName)">
            <summary>
            Bundle具备了程序集加载重定向功能，此外，OSGi内核的程序集
            也需要具备该功能，即内核的加载忽略版本、忽略兼容性。
            </summary>
            <param name="assemblyName"></param>
            <returns></returns>
        </member>
        <member name="M:UIShell.OSGi.Loader.AssemblyResolvingProvider.ResolveAssembly(System.Reflection.AssemblyName)">
            <summary>
            Resolve assembly fullname from all resolved assembly metadata nodes.
            </summary>
            <param name="assebmlyFullName">assembly fullname</param>
            <returns></returns>
        </member>
        <member name="M:UIShell.OSGi.Loader.AssemblyResolvingProvider.ResolveAssembly(UIShell.OSGi.Dependency.Metadata.IAssemblyMetadata,System.Reflection.AssemblyName)">
            <summary>
            尝试从IAssemblyMetadata定义的Assembly列表中查找匹配指定AssemblyName 的Assembly
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Loader.AssemblyResolvingProvider.ResolveAssembly(UIShell.OSGi.Dependency.Metadata.IAssemblyMetadata,UIShell.OSGi.Utility.Func{System.Reflection.AssemblyName,System.Boolean},System.Boolean)">
            <summary>
            尝试从IAssemblyMetadata定义的Assembly列表中查找匹配指定条件的Assembly
            注意：当调用LoadBundleAssemblies时，stopWhen为null，此时，需要直接返回cacheEntry.Assembly，即
            加载的本地程序集。
            </summary>
            <param name="metadata"></param>
            <param name="stopWhen"></param>
            <param name="tryCache"></param>
            <returns></returns>
        </member>
        <member name="M:UIShell.OSGi.Loader.AssemblyResolvingProvider.LoadBundleAssembly(System.String)">
            <summary>
            Load 一个Bundle所有的ShareAssembly和PrivateAssembly
            </summary>
            <param name="bundleSymbolicName"></param>
            <returns></returns>
        </member>
        <member name="T:UIShell.OSGi.Loader.IBundleLoader">
            <summary>
            BundleLoader将利用Bundle的元数据来创建对应的加载器，然后利用Import、Export、Require、DynamicImport加载器来加载对应的类和资源。
            类型和资源加载在Framework关闭的时候不允许返回任何值。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Core.Service.Impl.BundlePersistent">
            <summary>
            用来保存安装、卸载了哪些Bundle
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.BundlePersistent.Load(System.String)">
            <summary>
            Loads storage data from the specified file.
            </summary>
            <param name="file">The file.</param>
            <returns></returns>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.BundlePersistent.SaveUnInstallLocation(System.String,System.String)">
            <summary>
            Saves the un install location.
            </summary>
            <param name="path">The path.</param>
        </member>
        <member name="M:UIShell.OSGi.Core.Service.Impl.BundlePersistent.SaveInstallLocation(System.String)">
            <summary>
            当插件不在默认搜索目录时，将插件目录保存到持久文件。
            </summary>
            <param name="bundleLocation">插件所在的目录。</param>
        </member>
        <member name="P:UIShell.OSGi.Core.Service.Impl.BundlePersistent.InstalledBundleLocation">
            <summary>
            用来保存用户“额外”安装了那些Bundle，“额外”指的是并没有在LogicDirectory.xml中指定的那些Bundle列表，
            而是用户后来安装的，对于这种情况，有两种处理方式：
            1，每次用户安装新的Bundle后，把安装的路径添加到LogicDirectory.xml
            2，单独建立一个配置文件记录这些安装
            我们采用了第二种策略，这个属性就是保存安装插件的位置的
            </summary>
            <value>The installed bundle location.</value>
        </member>
        <member name="P:UIShell.OSGi.Core.Service.Impl.BundlePersistent.UnInstalledBundleLocation">
            <summary>
            用来保存出现在LogicDirectory.xml中的Bundle，但被用户明确卸载了
            </summary>
            <value>The un installed bundle location.</value>
        </member>
        <member name="T:UIShell.OSGi.FrameworkConstants">
            <summary>
            框架常量。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkConstants.ASSEMBLY_SEARCH_FOLDERS">
            <summary>
            查找assembly的范围,用';'分隔多个folder
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkConstants.DEFAULT_MILLISECONDS_TIMEOUT_ONLOCK">
            <summary>
            线程安全时加锁等待的超时时间默认为10秒。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkConstants.SYSTEM_BUNDLE_SYMBOLICNAME">
            <summary>
            系统Bundle的特征名称。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkConstants.SYSTEM_BUNDLE_NAME">
            <summary>
            系统Bundle名称。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkConstants.MANIFEST_FILE_NAME">
            <summary>
            清单文件名称。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkConstants.BUNDLE_UPDATE_FOLDER">
            <summary>
            插件更新目录名称。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkConstants.RECYCLE_FOLDERNAME">
            <summary>
            更新时与卸载时的回收站文件夹名称。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkConstants.PERSISTENT_FILE_NAME">
            <summary>
            持久文件名称。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkConstants.DEFAULT_PLUGINS_FOLDER">
            <summary>
            默认的插件集目录。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkConstants.CONSTANT_NAME_BUNDLELOCATION">
            <summary>
            在Manifest.xml的{BundleLocation}参数。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkConstants.CONSTANT_NAME_BUNDLEABSOLUTEPATH">
            <summary>
            在Manifest.xml的{BundleAbsolutePath}参数，同{BundleLocation}参数。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkConstants.CONSTANT_NAME_BUNDLERELATIVEPATH">
            <summary>
            在Manifest.xml的{BundleRelativePath}参数。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkConstants.CONSTANT_NAME_BASEDIRECTORY">
            <summary>
            在Manifest.xml的{BaseDirectory}参数。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkConstants.ASSEMBLY_SEARCH_FOLDERS_FOR_DEBUGANDRELEASE">
            <summary>
            继续查找Debug/Release目录，查找assembly的范围,用';'分隔多个folder
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkConstants.LOG_NAME">
            <summary>
            Log Config file loaction related to this assembly
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkConstants.DEFAULT_VERSION">
            <summary>
            Default version.
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkConstants.DEFAULT_CULTURE">
            <summary>
            Neutral culture.
            </summary>
        </member>
        <member name="F:UIShell.OSGi.FrameworkConstants.DEFAULT_LICENSE_FILE">
            <summary>
            默认的Framework、Bundle license文件名
            </summary>
        </member>
        <member name="P:UIShell.OSGi.FrameworkConstants.MULTIPLE_VERSIONS_SUPPORT">
            <summary>
            默认不启动多版本支持。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Logging.DefaultFormatters">
            <summary>
            Contains the default formatters
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Logging.DefaultFormatters.#cctor">
            <summary>
            Initializes static members of the DefaultFormatters class.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Logging.DefaultFormatters.Reset">
            <summary>
            Resets the message formatters to the values from construction
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Logging.DefaultFormatters.Message">
            <summary>
            Gets or sets the default formatter to use for user messages
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Logging.DefaultFormatters.Exception">
            <summary>
            Gets or sets the default formatter to use for exceptions.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Logging.MessageFormatter">
            <summary>
            Used by Logger to format a user supplied message.
            </summary>
            <param name="userMessage">The user's message</param>
            <param name="name">The name of the Logger formatting the message</param>
            <param name="level">The level of the message</param>
            <returns>A formatted string to be written to a Log</returns>
            <remarks>
            Implementations of this delegate should be forgiving of null or empty
            <paramref name="userMessage">user messages</paramref>.  <paramref name="name"/> 
            will never be null.  <paramref name="level"/> will always be a valid
            <see cref="T:UIShell.OSGi.Logging.LogLevel"/>.
            </remarks>
        </member>
        <member name="T:UIShell.OSGi.Logging.ExceptionFormatter">
            <summary>
            User by Logger to format a user supplied Exception.
            </summary>
            <param name="ex">The user's exception</param>
            <param name="name">The name of the Logger formatting the exception</param>
            <param name="level">The level of the exception</param>
            <returns>A formatted string to be written to a log</returns>
            <remarks>
            Implementations of this delegate should be forgiving of null 
            <paramref name="ex">exceptions</paramref>.  <paramref name="name"/> will never be
            null.  <paramref name="level"/> will always be a valid <see cref="T:UIShell.OSGi.Logging.LogLevel"/>.
            </remarks>
        </member>
        <member name="T:UIShell.OSGi.Logging.ILogger">
            <summary>
            日志服务接口。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Logging.Logger">
            <summary>
            Used by applications to write messages and/or exceptions to a <see cref="T:UIShell.OSGi.Logging.Log"/>.
            </summary>
            <remarks>
            <para>In the most simple form, a Logger is created as a static field of a class.</para>
            <example>
            public class MyClass
            {
                private static readonly Logger logger = new Logger(typeof(MyClass));
            }
            </example>
            <para>Then it is used to write messages to a <see cref="T:UIShell.OSGi.Logging.Log"/></para>
            <example>
            logger.Inform("Processing customer order");
            try
            {
                // some operation that goes horribly wrong
            }
            catch(Exception ex)
            {
                logger.Fatal("Visa Processing informed us that no more processing can be done");
                logger.Fatal(ex);
            }
            </example>
            <para>
            <see cref="P:UIShell.OSGi.Logging.Logger.Level"/>, message formatters, and <see cref="T:UIShell.OSGi.Logging.Log"/> are
            retrieved from an instance of <see cref="T:UIShell.OSGi.Logging.Settings"/>.  This instance can be
            passed in via the constructor.  If not, the default for the current AppDomain 
            will be used.
            </para>
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.#ctor(System.String)">
            <summary>
            Initializes a new instance of the Logger class.
            </summary>
            <param name="name">The name of the logger</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="name"/> is empty or null.
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the Logger class.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the name of the logger is derived.</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="type"/> is null.
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.#ctor(System.String,UIShell.OSGi.Logging.Log)">
            <summary>
            Initializes a new instance of the Logger class.
            </summary>
            <param name="name">The name of the logger</param>
            <param name="log">The <see cref="T:UIShell.OSGi.Logging.Log"/> to write to.</param>
            <exception cref="T:System.ArgumentNullException">
            <para>If <paramref name="name"/> is empty or null</para>
            <para>-*-OR-*-</para>
            <para>If <paramref name="log"/> is null</para>
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.#ctor(System.Type,UIShell.OSGi.Logging.Log)">
            <summary>
            Initializes a new instance of the Logger class.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the name of the logger is derived.</param>
            <param name="log">The <see cref="T:UIShell.OSGi.Logging.Log"/> to write to.</param>
            <exception cref="T:System.ArgumentNullException">
            <para>If <paramref name="type"/> is null</para>
            <para>-*-OR-*-</para>
            <para>If <paramref name="log"/> is null</para>
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.#ctor(System.String,UIShell.OSGi.Logging.Settings)">
            <summary>
            Initializes a new instance of the Logger class.
            </summary>
            <param name="name">The name of the logger</param>
            <param name="settings">The <see cref="T:UIShell.OSGi.Logging.Settings"/> to initialize the logger from</param>
            <exception cref="T:System.ArgumentNullException">
            <para>If <paramref name="name"/> is empty or null</para>
            <para>-*-OR-*-</para>
            <para>If <paramref name="settings"/> is null</para>
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.#ctor(System.Type,UIShell.OSGi.Logging.Settings)">
            <summary>
            Initializes a new instance of the Logger class.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the name of the logger is derived.</param>
            <param name="settings">The <see cref="T:UIShell.OSGi.Logging.Settings"/> to initialize the logger from</param>
            <exception cref="T:System.ArgumentNullException">
            <para>If <paramref name="type"/> is null</para>
            <para>-*-OR-*-</para>
            <para>If <paramref name="settings"/> is null</para>
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.#ctor(System.String,UIShell.OSGi.Logging.Log,UIShell.OSGi.Logging.Settings)">
            <summary>
            Initializes a new instance of the Logger class.
            </summary>
            <param name="name">The name of the logger</param>
            <param name="log">The <see cref="T:UIShell.OSGi.Logging.Log"/> to write to.</param>
            <param name="settings">The <see cref="T:UIShell.OSGi.Logging.Settings"/> to initialize the logger from</param>
            <exception cref="T:System.ArgumentNullException">
            <para>If <paramref name="name"/> is empty or null</para>
            <para>-*-OR-*-</para>
            <para>If <paramref name="log"/> is null</para>
            <para>-*-OR-*-</para>
            <para>If <paramref name="settings"/> is null</para>
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.#ctor(System.Type,UIShell.OSGi.Logging.Log,UIShell.OSGi.Logging.Settings)">
            <summary>
            Initializes a new instance of the Logger class.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the name of the logger is derived.</param>
            <param name="log">The <see cref="T:UIShell.OSGi.Logging.Log"/> to write to.</param>
            <param name="settings">The <see cref="T:UIShell.OSGi.Logging.Settings"/> to initialize the logger from</param>
            <exception cref="T:System.ArgumentNullException">
            <para>If <paramref name="type"/> is null</para>
            <para>-*-OR-*-</para>
            <para>If <paramref name="log"/> is null</para>
            <para>-*-OR-*-</para>
            <para>If <paramref name="settings"/> is null</para>
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.WillLogAt(UIShell.OSGi.Logging.LogLevel)">
            <summary>
            Indicates whether the Logger will log at a particular level
            </summary>
            <param name="queryLevel">The <see cref="T:UIShell.OSGi.Logging.LogLevel"/> to check</param>
            <returns>
            True if the current logger will log at <paramref name="level"/>, 
            false otherwise.
            </returns>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Log(System.String,UIShell.OSGi.Logging.LogLevel)">
            <summary>
            Logs the <paramref name="message"/> at the specified <paramref name="level"/>
            </summary>
            <param name="message">The message to log</param>
            <param name="messageLevel">The level to log the message</param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Log(UIShell.OSGi.Logging.MessageGenerator,UIShell.OSGi.Logging.LogLevel)">
            <summary>
            Logs the <paramref name="message">generated message</paramref> at the
            specified <paramref name="messageLevel"/>
            </summary>
            <param name="message">The <see cref="T:UIShell.OSGi.Logging.MessageGenerator">message</see> to log</param>
            <param name="messageLevel">The level to log the message</param>
            <remarks>
            <para>
            The delegate will only be called if this Logger's <see cref="T:UIShell.OSGi.Logging.LogLevel"/> is
            greater than or equal to <paramref name="messageLevel"/>
            </para>
            <para>
            If the delegate is null, <see cref="F:System.String.Empty"/> is passed in its place.
            </para>
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Log(System.Exception,UIShell.OSGi.Logging.LogLevel)">
            <summary>
            Logs the exception at the specified <paramref name="exceptionLevel"/>
            </summary>
            <param name="ex">The exception to log</param>
            <param name="exceptionLevel">The level to log the exception</param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Verbose(System.String)">
            <summary>
            Logs the message at the <see cref="F:UIShell.OSGi.Logging.LogLevel.Verbose"/> level.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Verbose(UIShell.OSGi.Logging.MessageGenerator)">
            <summary>
            Logs the generated message at the <see cref="F:UIShell.OSGi.Logging.LogLevel.Verbose"/> level.
            </summary>
            <param name="message">The delegate that generates the message to log</param>
            <remarks>
            <para>
            The delegate will only be called if this Logger's <see cref="T:UIShell.OSGi.Logging.LogLevel"/> is
            greater than or equal to <see cref="F:UIShell.OSGi.Logging.LogLevel.Verbose"/>
            </para>
            <para>
            If the delegate is null, <see cref="F:System.String.Empty"/> is passed in its place.
            </para>
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Verbose(System.Exception)">
            <summary>
            Logs the exception at the <see cref="F:UIShell.OSGi.Logging.LogLevel.Verbose"/> level.
            </summary>
            <param name="ex">The exception to log</param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Debug(System.String)">
            <summary>
            Logs the message at the <see cref="F:UIShell.OSGi.Logging.LogLevel.Debug"/> level.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Debug(UIShell.OSGi.Logging.MessageGenerator)">
            <summary>
            Logs the generated message at the <see cref="F:UIShell.OSGi.Logging.LogLevel.Debug"/> level.
            </summary>
            <param name="message">The delegate that generates the message to log</param>
            <remarks>
            <para>
            The delegate will only be called if this Logger's <see cref="T:UIShell.OSGi.Logging.LogLevel"/> is
            greater than or equal to <see cref="F:UIShell.OSGi.Logging.LogLevel.Debug"/>
            </para>
            <para>
            If the delegate is null, <see cref="F:System.String.Empty"/> is passed in its place.
            </para>
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Debug(System.Exception)">
            <summary>
            Logs the exception at the <see cref="F:UIShell.OSGi.Logging.LogLevel.Debug"/> level.
            </summary>
            <param name="ex">The exception to log</param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Inform(System.String)">
            <summary>
            Logs the message at the <see cref="F:UIShell.OSGi.Logging.LogLevel.Inform"/> level.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Inform(UIShell.OSGi.Logging.MessageGenerator)">
            <summary>
            Logs the generated message at the <see cref="F:UIShell.OSGi.Logging.LogLevel.Inform"/> level.
            </summary>
            <param name="message">The delegate that generates the message to log</param>
            <remarks>
            <para>
            The delegate will only be called if this Logger's <see cref="T:UIShell.OSGi.Logging.LogLevel"/> is
            greater than or equal to <see cref="F:UIShell.OSGi.Logging.LogLevel.Inform"/>
            </para>
            <para>
            If the delegate is null, <see cref="F:System.String.Empty"/> is passed in its place.
            </para>
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Inform(System.Exception)">
            <summary>
            Logs the exception at the <see cref="F:UIShell.OSGi.Logging.LogLevel.Inform"/> level.
            </summary>
            <param name="ex">The exception to log</param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Warn(System.String)">
            <summary>
            Logs the message at the <see cref="F:UIShell.OSGi.Logging.LogLevel.Warn"/> level.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Warn(UIShell.OSGi.Logging.MessageGenerator)">
            <summary>
            Logs the generated message at the <see cref="F:UIShell.OSGi.Logging.LogLevel.Warn"/> level.
            </summary>
            <param name="message">The delegate that generates the message to log</param>
            <remarks>
            <para>
            The delegate will only be called if this Logger's <see cref="T:UIShell.OSGi.Logging.LogLevel"/> is
            greater than or equal to <see cref="F:UIShell.OSGi.Logging.LogLevel.Warn"/>
            </para>
            <para>
            If the delegate is null, <see cref="F:System.String.Empty"/> is passed in its place.
            </para>
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Warn(System.Exception)">
            <summary>
            Logs the exception at the <see cref="F:UIShell.OSGi.Logging.LogLevel.Warn"/> level.
            </summary>
            <param name="ex">The exception to log</param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Error(System.String)">
            <summary>
            Logs the message at the <see cref="F:UIShell.OSGi.Logging.LogLevel.Error"/> level.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Error(UIShell.OSGi.Logging.MessageGenerator)">
            <summary>
            Logs the generated message at the <see cref="F:UIShell.OSGi.Logging.LogLevel.Error"/> level.
            </summary>
            <param name="message">The delegate that generates the message to log</param>
            <remarks>
            <para>
            The delegate will only be called if this Logger's <see cref="T:UIShell.OSGi.Logging.LogLevel"/> is
            greater than or equal to <see cref="F:UIShell.OSGi.Logging.LogLevel.Error"/>
            </para>
            <para>
            If the delegate is null, <see cref="F:System.String.Empty"/> is passed in its place.
            </para>
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Error(System.Exception)">
            <summary>
            Logs the exception at the <see cref="F:UIShell.OSGi.Logging.LogLevel.Error"/> level.
            </summary>
            <param name="ex">The exception to log</param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Fatal(System.String)">
            <summary>
            Logs the message at the <see cref="F:UIShell.OSGi.Logging.LogLevel.Fatal"/> level.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Fatal(UIShell.OSGi.Logging.MessageGenerator)">
            <summary>
            Logs the generated message at the <see cref="F:UIShell.OSGi.Logging.LogLevel.Fatal"/> level.
            </summary>
            <param name="message">The delegate that generates the message to log</param>
            <remarks>
            <para>
            The delegate will only be called if this Logger's <see cref="T:UIShell.OSGi.Logging.LogLevel"/> is
            greater than or equal to <see cref="F:UIShell.OSGi.Logging.LogLevel.Fatal"/>
            </para>
            <para>
            If the delegate is null, <see cref="F:System.String.Empty"/> is passed in its place.
            </para>
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logger.Fatal(System.Exception)">
            <summary>
            Logs the exception at the <see cref="F:UIShell.OSGi.Logging.LogLevel.Fatal"/> level.
            </summary>
            <param name="ex">The exception to log</param>
        </member>
        <member name="P:UIShell.OSGi.Logging.Logger.DestinationLog">
            <summary>
            Gets or sets the <see cref="T:UIShell.OSGi.Logging.Log"/> this Logger will write to
            </summary>
            <remarks>
            When setting the <see cref="T:UIShell.OSGi.Logging.Log"/> if you use <code>null</code>, 
            the <see cref="T:UIShell.OSGi.Logging.Log"/> will revert to what is contained in the <see cref="T:UIShell.OSGi.Logging.Settings"/>
            this Logger was created from.
            </remarks>
        </member>
        <member name="P:UIShell.OSGi.Logging.Logger.Level">
            <summary>
            Gets or sets the <see cref="T:UIShell.OSGi.Logging.LogLevel"/> this Logger uses
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If value is not a valid <see cref="T:UIShell.OSGi.Logging.LogLevel"/>
            </exception>
        </member>
        <member name="P:UIShell.OSGi.Logging.Logger.MessageFormatter">
            <summary>
            Gets or sets the <see cref="P:UIShell.OSGi.Logging.Logger.MessageFormatter"/> this Logger uses
            </summary>
            <remarks>
            When setting the <see cref="P:UIShell.OSGi.Logging.Logger.MessageFormatter"/> if you use <code>null</code>,
            the <see cref="P:UIShell.OSGi.Logging.Logger.MessageFormatter"/> will revert to what is contained in
            the <see cref="T:UIShell.OSGi.Logging.Settings"/> this Logger was created from.
            </remarks>
        </member>
        <member name="P:UIShell.OSGi.Logging.Logger.ExceptionFormatter">
            <summary>
            Gets or sets the <see cref="P:UIShell.OSGi.Logging.Logger.ExceptionFormatter"/> this Logger uses
            </summary>
            <remarks>
            When setting the <see cref="P:UIShell.OSGi.Logging.Logger.ExceptionFormatter"/> if you use <code>null</code>,
            the <see cref="P:UIShell.OSGi.Logging.Logger.ExceptionFormatter"/> will revert to what is contained in
            the <see cref="T:UIShell.OSGi.Logging.Settings"/> this Logger was created from.
            </remarks>
        </member>
        <member name="T:UIShell.OSGi.Logging.LoggerName">
            <summary>
            Class that makes working with names of Loggers easier.
            </summary>
            <remarks>
            <para>
            This class maintains all the rules for the names of Loggers, such
            as case insensitive equality and comparison, and normalization of
            names derived from <see cref="T:System.Type"/>.
            </para>
            <para>
            In addition, a LoggerName knows how to enumerate the hierarchy it
            belongs to.  For example, if you have a LoggerName a.b.c.d.e, the
            instance would be able to return an IEnumerable
            consisting of LoggerNames a, a.b, a.b.c, a.b.c.d, and a.b.c.d.e.
            <see cref="P:UIShell.OSGi.Logging.LoggerName.Hierarchy"/> for more details.
            </para>
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.LoggerName.#ctor(System.String)">
            <summary>
            Initializes a new instance of the LoggerName class. 
            </summary>
            <param name="name">The name to use</param>
            <exception cref="T:System.ArgumentNullException">If name is null or empty</exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.LoggerName.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the LoggerName class.
            </summary>
            <param name="type">The type to use</param>
            <remarks>
            <para>
            If the <paramref name="type"/> <see cref="P:System.Type.IsNested"/>,
            the default delimiter is a '+' character.  We normalize this into a dot.
            </para>
            <para>
            If the <paramref name="type"/> <see cref="P:System.Type.IsGenericType"/>,
            the default string representation is to `N where N is the number of
            generic types.  A list of the types is contained in an array ([]) on the
            inner most type.  The `N is turned into _N.
            </para>
            <para>
            <code>
            public class Foo&lt;T1,T2&gt;
            {
                public class Inner&lt;T3&gt;
                {
                }
            }
            string name = typeof(Foo&lt;string,int&gt;.Inner&lt;DateTime&gt;).FullName;
            </code>
            name is Foo`2+Inner`1[[System.String, assembly info],[System.Int32, assembly info],[System.DateTime, assembly info]]
            after normalization name is foo_2.inner_1
            </para>
            <para>
            If you access pass in the true generic type (i.e. Foo&lt;,&gt;.Inner&lt;&gt;), the bracketed types are not present.  The
            normalization result is the same though.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">If type is null</exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.LoggerName.op_Equality(UIShell.OSGi.Logging.LoggerName,UIShell.OSGi.Logging.LoggerName)">
            <summary>
            The equal operator
            </summary>
            <param name="left">The left hand side</param>
            <param name="right">The right hand side</param>
            <returns>True if left is equal to right, otherwise false</returns>
        </member>
        <member name="M:UIShell.OSGi.Logging.LoggerName.op_Inequality(UIShell.OSGi.Logging.LoggerName,UIShell.OSGi.Logging.LoggerName)">
            <summary>
            The not equal operator
            </summary>
            <param name="left">The left hand side</param>
            <param name="right">The right hand side</param>
            <returns>True if left is not equal to right, otherwise false</returns>
        </member>
        <member name="M:UIShell.OSGi.Logging.LoggerName.op_LessThan(UIShell.OSGi.Logging.LoggerName,UIShell.OSGi.Logging.LoggerName)">
            <summary>
            The less than operator
            </summary>
            <param name="left">The left hand side</param>
            <param name="right">The right hand side</param>
            <returns>True if left is less than right, false otherwise</returns>
        </member>
        <member name="M:UIShell.OSGi.Logging.LoggerName.op_LessThanOrEqual(UIShell.OSGi.Logging.LoggerName,UIShell.OSGi.Logging.LoggerName)">
            <summary>
            The less than or equal to operator
            </summary>
            <param name="left">The left hand side</param>
            <param name="right">The right hand side</param>
            <returns>True if left is less than or equal to right, false otherwise</returns>
        </member>
        <member name="M:UIShell.OSGi.Logging.LoggerName.op_GreaterThan(UIShell.OSGi.Logging.LoggerName,UIShell.OSGi.Logging.LoggerName)">
            <summary>
            The greater than operator
            </summary>
            <param name="left">The left hand side</param>
            <param name="right">The right hand side</param>
            <returns>True if left is greater than right, false otherwise</returns>
        </member>
        <member name="M:UIShell.OSGi.Logging.LoggerName.op_GreaterThanOrEqual(UIShell.OSGi.Logging.LoggerName,UIShell.OSGi.Logging.LoggerName)">
            <summary>
            The greater than or equal to operator
            </summary>
            <param name="left">The left hand side</param>
            <param name="right">The right hand side</param>
            <returns>True if left greater than or equal to right, false otherwise</returns>
        </member>
        <member name="M:UIShell.OSGi.Logging.LoggerName.Equals(System.Object)">
            <summary>
            Checks this instance for equality to passed in obj
            </summary>
            <param name="obj">The object to check for equality</param>
            <returns>True if equal, false otherwise</returns>
        </member>
        <member name="M:UIShell.OSGi.Logging.LoggerName.GetHashCode">
            <summary>
            Get a hashcode from this instance
            </summary>
            <returns>An integer value to use as our hash code</returns>
        </member>
        <member name="M:UIShell.OSGi.Logging.LoggerName.ToString">
            <summary>
            Get a string representation of this instance
            </summary>
            <returns>A string representation of this instance</returns>
        </member>
        <member name="M:UIShell.OSGi.Logging.LoggerName.Equals(UIShell.OSGi.Logging.LoggerName)">
            <summary>
            Checks this instance for equality to passed in obj
            </summary>
            <param name="other">The object to check for equality</param>
            <returns>True if equal, false otherwise</returns>
        </member>
        <member name="M:UIShell.OSGi.Logging.LoggerName.CompareTo(UIShell.OSGi.Logging.LoggerName)">
            <summary>
            Compares this instance to another.
            </summary>
            <param name="other">The object to compare to</param>
            <returns>-1 if less than, 0 if equal, and 1 if greater than</returns>
        </member>
        <member name="P:UIShell.OSGi.Logging.LoggerName.FullName">
            <summary>
            Gets the FullName of the LoggerName
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Logging.LoggerName.BaseName">
            <summary>
            Gets the BaseName of the LoggerName.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Logging.LoggerName.Hierarchy">
            <summary>
            Gets the hierarchy of LoggerNames this instance belongs to
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Logging.LogLevel">
            <summary>
            Enumeration of levels that can be logged to
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Logging.LogLevel.Fatal">
            <summary>
            The Fatal Level
            </summary>
            <remarks>
            This level should be used when an unexpected error occurs that cannot be 
            recovered from, requires immediate human intervention, and the application
            will most likely shutdown.
            </remarks>
        </member>
        <member name="F:UIShell.OSGi.Logging.LogLevel.Error">
            <summary>
            The Error Level 
            </summary>
            <remarks>
            This level should be used when an unexpected error occurs that cannot be
            recovered from and likely requires human intervention.  But the application
            may not shutdown if the error is transitive (i.e. database down).
            </remarks>
        </member>
        <member name="F:UIShell.OSGi.Logging.LogLevel.Warn">
            <summary>
            The Warning Level 
            </summary>
            <remarks>
            This level should be used when an unexpected error occurs that can
            be recovered from and a human should look at the issue at their earliest
            possible convenience.
            </remarks>
        </member>
        <member name="F:UIShell.OSGi.Logging.LogLevel.Inform">
            <summary>
            The Inform Level 
            </summary>
            <remarks>
            This level should be used for reporting normal running information to the end user.
            This can include order ids being processed, RSS urls being parsed, etc.
            </remarks>
        </member>
        <member name="F:UIShell.OSGi.Logging.LogLevel.Debug">
            <summary>
            The Debug Level 
            </summary>
            <remarks>
            This level should be used for basic, high level debugging statements.  Such as,
            entering and leaving a method, direction taking in conditional statements, 
            events sent or received, and important objects.
            </remarks>
        </member>
        <member name="F:UIShell.OSGi.Logging.LogLevel.Verbose">
            <summary>
            The Verbose Level
            </summary>
            <remarks>
            This level should be used for debugging that generates large amounts of output.
            Such as, mouse events, state of a loop (i.e. current index), method parameters,
            etc.
            </remarks>
        </member>
        <member name="T:UIShell.OSGi.Logging.LogLevelUtils">
            <summary>
            Simple utilities for working with <see cref="T:UIShell.OSGi.Logging.LogLevel"/> enumeration.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Logging.Logs.FileLog">
            <summary>
            Implementation of <see cref="T:UIShell.OSGi.Logging.Log"/> that writes to a file.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Logging.Logs.TextWriterLog">
            <summary>
            Implementation of <see cref="T:UIShell.OSGi.Logging.Log"/> that writes to any <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <remarks>
            <para>
            Since the TextWriter can be fronting any source (File, Socket, etc.), all exceptions
            are caught and traced out as warnings.
            </para>
            <para>
            This implementation is NOT thread safe.  Only 1 thread at a time may write.  See 
            <see cref="T:UIShell.OSGi.Logging.Logs.LockingLog"/> as a way to make a TextWriterLog thread safe.
            </para>
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logs.TextWriterLog.#ctor(System.IO.TextWriter)">
            <summary>
            Initializes a new instance of the TextWriterLog class.
            </summary>
            <param name="writer">The <see cref="T:System.IO.TextWriter"/> to write to.</param>
            <remarks>
            This constructor implies the <paramref name="writer"/> is not owned by the instance.
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logs.TextWriterLog.#ctor(System.IO.TextWriter,UIShell.OSGi.Logging.Logs.TextWriterResponsibility)">
            <summary>
            Initializes a new instance of the TextWriterLog class.
            </summary>
            <param name="writer">The <see cref="T:System.IO.TextWriter"/> to write to.</param>
            <param name="responsibility">The responbility level this instance has over the <paramref name="writer"/></param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logs.TextWriterLog.WriteLine(System.String,UIShell.OSGi.Logging.LogLevel)">
            <summary>
            Writes the message to the underlying <see cref="T:System.IO.TextWriter"/> 
            </summary>
            <param name="message">The message to write</param>
            <param name="level">The level of the message.  Ignored.</param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logs.TextWriterLog.Dispose">
            <summary>
            Disposes of resources this instance holds onto.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logs.TextWriterLog.Dispose(System.Boolean)">
            <summary>
            Called to dispose of any resources this instance holds.
            </summary>
            <param name="disposing">True if being called from Dispose, false otherwise.</param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logs.FileLog.#ctor(System.String)">
            <summary>
            Initializes a new instance of the FileLog class.
            </summary>
            <param name="filePath">The path to the file to log to</param>
            <remarks>Appends to the file at <paramref name="filePath"/></remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logs.FileLog.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the FileLog class.
            </summary>
            <param name="filePath">The path to the file to log to</param>
            <param name="append">True if you want to append to the file, false to truncate</param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logs.FileLog.#ctor(System.IO.FileInfo)">
            <summary>
            Initializes a new instance of the FileLog class.
            </summary>
            <param name="info">The <see cref="T:System.IO.FileInfo"/> of the file to log to</param>
            <remarks>Appends to the file identified by <paramref name="info"/>.</remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logs.FileLog.#ctor(System.IO.FileInfo,System.Boolean)">
            <summary>
            Initializes a new instance of the FileLog class.
            </summary>
            <param name="info">The <see cref="T:System.IO.FileInfo"/> of the file to log to</param>
            <param name="append">True if you want to append to the file, false to truncate</param>
        </member>
        <member name="T:UIShell.OSGi.Logging.Logs.LockingLog">
            <summary>
            Implementation of <see cref="T:UIShell.OSGi.Logging.Log"/> that wraps other <see cref="T:UIShell.OSGi.Logging.Log"/> implementations
            to make them thread safe.
            </summary>
            <remarks>
            LockingLog does not wait infinitely for the lock to become available.  It will wait for
            a user configurable time before giving up.  This will ensure that deadlocks do not occur
            becaues of poorly written <see cref="T:UIShell.OSGi.Logging.Log"/> implementations.
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logs.LockingLog.#ctor(UIShell.OSGi.Logging.Log)">
            <summary>
            Initializes a new instance of the LockingLog class.
            </summary>
            <param name="toWrap">The <see cref="T:UIShell.OSGi.Logging.Log"/> to wrap with locking</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="toWrap"/> is null</exception>
            <remarks>
            Defaults the maximum wait time for lock to 2 seconds.
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logs.LockingLog.#ctor(UIShell.OSGi.Logging.Log,System.TimeSpan)">
            <summary>
            Initializes a new instance of the LockingLog class.
            </summary>
            <param name="toWrap">The <see cref="T:UIShell.OSGi.Logging.Log"/> to wrap with locking</param>
            <param name="maxWaitTime">The maximum amount of time to wait for the lock before giving up.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="toWrap"/> is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="maxWaitTime"/>is less than half a second or greater than 5 minutes.
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logs.LockingLog.WriteLine(System.String,UIShell.OSGi.Logging.LogLevel)">
            <summary>
            Writes the message to the wrapped <see cref="T:UIShell.OSGi.Logging.Log"/> inside of a lock.
            </summary>
            <param name="message">The message to write to the log.</param>
            <param name="level">The <see cref="T:UIShell.OSGi.Logging.LogLevel"/> of the message.</param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logs.LockingLog.ToString">
            <summary>
            Returns a string representation of this instance.
            </summary>
            <returns>a string representation of this instance</returns>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logs.LockingLog.Dispose">
            <summary>
            Disposes of any resources that we might be holding
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Logging.Logs.NullLog">
            <summary>
            An implementation of <see cref="T:UIShell.OSGi.Logging.Log"/> that does not log, and cannot be
            made to log.
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Logging.Logs.NullLog.Instance">
            <summary>
            Singleton instance of the no operation log
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logs.NullLog.WriteLine(System.String,UIShell.OSGi.Logging.LogLevel)">
            <summary>
            Does nothing.  No operation.
            </summary>
            <param name="message">The message to log</param>
            <param name="level">The <see cref="T:UIShell.OSGi.Logging.LogLevel"/> of the message.</param>
        </member>
        <member name="P:UIShell.OSGi.Logging.Logs.NullLog.IsLogging">
            <summary>
            Gets or sets a value indicating whether not this Log should log.
            </summary>
            <remarks>
            This implementation of <see cref="T:UIShell.OSGi.Logging.Log"/> ignores setting this property and always returns false.
            </remarks>
        </member>
        <member name="T:UIShell.OSGi.Logging.Logs.StdErrLog">
            <summary>
            Implementation of <see cref="T:UIShell.OSGi.Logging.Log"/> that writes to standard error.
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Logging.Logs.StdErrLog.Instance">
            <summary>
            The singleton instance of StdErrLog
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Logging.Logs.StdErrLog.WriteLine(System.String,UIShell.OSGi.Logging.LogLevel)">
            <summary>
            Writes the message to <see cref="P:System.Console.Error"/>.
            </summary>
            <param name="message">The message to write to standard error</param>
            <param name="level">The level of the message.  Ignored.</param>
        </member>
        <member name="T:UIShell.OSGi.Logging.Logs.TextWriterResponsibility">
            <summary>
            Defines the responsibility for a <see cref="T:System.IO.TextWriter"/> aggregator.
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Logging.Logs.TextWriterResponsibility.Owns">
            <summary>
            The aggregator owns the <see cref="T:System.IO.TextWriter"/> and will close it.
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Logging.Logs.TextWriterResponsibility.DoesNotOwn">
            <summary>
            The aggregator does not own the <see cref="T:System.IO.TextWriter"/> and will not close it.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Logging.MessageGenerator">
            <summary>
            Supplied by users to generate a message for logging.
            </summary>
            <returns>A string to log</returns>
            <seealso cref="T:UIShell.OSGi.Logging.Logger"/>
        </member>
        <member name="T:UIShell.OSGi.Logging.Settings">
            <summary>
            Maintains settings for a group of Loggers
            </summary>
            <remarks>
            <para>
            Maintains LogLevels, formatters, and a default Log implementation.  Unless the method 
            documentation says differently, all settings are hierarchical.  For example, if you
            set the LogLevel of a logger name "a.b.c" to Fatal, all children of "a.b.c" will use that
            LogLevel.  Children include any logger name that starts with "a.b.c".  So "a.b.c.d",
            "a.b.c.e", etc. would pick up the Fatal level.  But "a.b.f", would not.
            </para>
            <para>This class is thread safe for multiple readers, but not multiple writers.</para>
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.FindLogLevelFor(System.String)">
            <summary>
            Finds a <see cref="T:UIShell.OSGi.Logging.LogLevel"/> for a logger with the specified name. 
            </summary>
            <remarks>
            <see cref="P:UIShell.OSGi.Logging.Settings.DefaultLogLevel"/> is returned if the logger name is not registered with this instance.
            </remarks>
            <param name="name">The name of the logger to find a <see cref="T:UIShell.OSGi.Logging.LogLevel"/> for.</param>
            <returns>The registered <see cref="T:UIShell.OSGi.Logging.LogLevel"/>, or the <see cref="P:UIShell.OSGi.Logging.Settings.DefaultLogLevel"/></returns>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.FindLogLevelFor(System.Type)">
            <summary>
            Finds a <see cref="T:UIShell.OSGi.Logging.LogLevel"/> for the specified type. 
            </summary>
            <remarks>
            <see cref="P:UIShell.OSGi.Logging.Settings.DefaultLogLevel"/> is returned if the type is not registered with this instance.
            </remarks>
            <param name="type">The Type to find a <see cref="T:UIShell.OSGi.Logging.LogLevel"/> for.</param>
            <returns>The registered <see cref="T:UIShell.OSGi.Logging.LogLevel"/>, or the <see cref="P:UIShell.OSGi.Logging.Settings.DefaultLogLevel"/></returns>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.FindLogLevelFor``1">
            <summary>
            Finds a <see cref="T:UIShell.OSGi.Logging.LogLevel"/> for the specified type. 
            </summary>
            <remarks>
            <see cref="P:UIShell.OSGi.Logging.Settings.DefaultLogLevel"/> is returned if the type is not registered with this instance.
            </remarks>
            <typeparam name="T">The Type to find a <see cref="T:UIShell.OSGi.Logging.LogLevel"/> for.</typeparam>
            <returns>The registered <see cref="T:UIShell.OSGi.Logging.LogLevel"/>, or the <see cref="P:UIShell.OSGi.Logging.Settings.DefaultLogLevel"/></returns>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.RegisterLogLevelFor(System.String,UIShell.OSGi.Logging.LogLevel)">
            <summary>
            Registers a <see cref="T:UIShell.OSGi.Logging.LogLevel"/> for a logger with the specified name.
            </summary>
            <param name="name">The name of the logger to register</param>
            <param name="logLevel">The level to give the logger</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="name"/> is null or empty</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="logLevel"/> is not a valid value.</exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.RegisterLogLevelFor(System.Type,UIShell.OSGi.Logging.LogLevel)">
            <summary>
            Registers a <see cref="T:UIShell.OSGi.Logging.LogLevel"/> for the specified type. 
            </summary>
            <param name="type">The type to register</param>
            <param name="logLevel">The level to give the logger</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="type"/> is null or empty</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="logLevel"/> is not a valid value.</exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.RegisterLogLevelFor``1(UIShell.OSGi.Logging.LogLevel)">
            <summary>
            Registers a <see cref="T:UIShell.OSGi.Logging.LogLevel"/> for the specified type. 
            </summary>
            <typeparam name="T">The type to register</typeparam>
            <param name="logLevel">The level to give the logger</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="logLevel"/> is not a valid value.</exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.FindMessageFormatterFor(System.String)">
            <summary>
            Finds a <see cref="T:UIShell.OSGi.Logging.MessageFormatter"/> for a logger of the specified name
            </summary>
            <param name="name">The name of the logger to find the formatter for</param>
            <returns>
            The registered <see cref="T:UIShell.OSGi.Logging.MessageFormatter"/> or the <see cref="P:UIShell.OSGi.Logging.DefaultFormatters.Message"/>
            </returns>
            <seealso cref="T:UIShell.OSGi.Logging.DefaultFormatters"/>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.FindMessageFormatterFor(System.Type)">
            <summary>
            Finds a <see cref="T:UIShell.OSGi.Logging.MessageFormatter"/> for a logger for the specified type
            </summary>
            <param name="type">The type for a logger to find the formatter for</param>
            <returns>
            The registered <see cref="T:UIShell.OSGi.Logging.MessageFormatter"/> or the <see cref="P:UIShell.OSGi.Logging.DefaultFormatters.Message"/>
            </returns>
            <seealso cref="T:UIShell.OSGi.Logging.DefaultFormatters"/>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.FindMessageFormatterFor``1">
            <summary>
            Finds a <see cref="T:UIShell.OSGi.Logging.MessageFormatter"/> for a logger for the specified type
            </summary>
            <typeparam name="T">The type for a logger to find the formatter for</typeparam>
            <returns>
            The registered <see cref="T:UIShell.OSGi.Logging.MessageFormatter"/> or the <see cref="P:UIShell.OSGi.Logging.DefaultFormatters.Message"/>
            </returns>
            <seealso cref="T:UIShell.OSGi.Logging.DefaultFormatters"/>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.RegisterMessageFormatterFor(System.String,UIShell.OSGi.Logging.MessageFormatter)">
            <summary>
            Registers a <see cref="T:UIShell.OSGi.Logging.MessageFormatter"/> for a logger with the specified name.
            </summary>
            <param name="name">The name of the logger</param>
            <param name="formatter">The <see cref="T:UIShell.OSGi.Logging.MessageFormatter"/> to register</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="name"/> is null or empty, or if <paramref name="formatter"/> is null.
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.RegisterMessageFormatterFor(System.Type,UIShell.OSGi.Logging.MessageFormatter)">
            <summary>
            Registers a <see cref="T:UIShell.OSGi.Logging.MessageFormatter"/> for a logger for the specified type.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the logger was created for</param>
            <param name="formatter">The <see cref="T:UIShell.OSGi.Logging.MessageFormatter"/> to register</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="type"/> is null or empty, or if <paramref name="formatter"/> is null.
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.RegisterMessageFormatterFor``1(UIShell.OSGi.Logging.MessageFormatter)">
            <summary>
            Registers a <see cref="T:UIShell.OSGi.Logging.MessageFormatter"/> for a logger for the specified type.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> the logger was created for</typeparam>
            <param name="formatter">The <see cref="T:UIShell.OSGi.Logging.MessageFormatter"/> to register</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="formatter"/> is null.
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.FindExceptionFormatterFor(System.String)">
            <summary>
            Finds an <see cref="T:UIShell.OSGi.Logging.ExceptionFormatter"/> for a logger of the specified name
            </summary>
            <param name="name">The name of the logger to find the formatter for</param>
            <returns>
            The registered <see cref="T:UIShell.OSGi.Logging.ExceptionFormatter"/> or the <see cref="P:UIShell.OSGi.Logging.DefaultFormatters.Exception"/>
            </returns>
            <seealso cref="T:UIShell.OSGi.Logging.DefaultFormatters"/>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.FindExceptionFormatterFor(System.Type)">
            <summary>
            Finds a <see cref="T:UIShell.OSGi.Logging.ExceptionFormatter"/> for a logger for the specified type
            </summary>
            <param name="type">The type for a logger to find the formatter for</param>
            <returns>
            The registered <see cref="T:UIShell.OSGi.Logging.ExceptionFormatter"/> or the <see cref="P:UIShell.OSGi.Logging.DefaultFormatters.Exception"/>
            </returns>
            <seealso cref="T:UIShell.OSGi.Logging.DefaultFormatters"/>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.FindExceptionFormatterFor``1">
            <summary>
            Finds a <see cref="T:UIShell.OSGi.Logging.ExceptionFormatter"/> for a logger for the specified type
            </summary>
            <typeparam name="T">The type for a logger to find the formatter for</typeparam>
            <returns>
            The registered <see cref="T:UIShell.OSGi.Logging.ExceptionFormatter"/> or the <see cref="P:UIShell.OSGi.Logging.DefaultFormatters.Exception"/>
            </returns>
            <seealso cref="T:UIShell.OSGi.Logging.DefaultFormatters"/>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.RegisterExceptionFormatterFor(System.String,UIShell.OSGi.Logging.ExceptionFormatter)">
            <summary>
            Registers a <see cref="T:UIShell.OSGi.Logging.ExceptionFormatter"/> for a logger with the specified name.
            </summary>
            <param name="name">The name of the logger</param>
            <param name="formatter">The <see cref="T:UIShell.OSGi.Logging.ExceptionFormatter"/> to register</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="name"/> is null or empty, or if <paramref name="formatter"/> is null.
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.RegisterExceptionFormatterFor(System.Type,UIShell.OSGi.Logging.ExceptionFormatter)">
            <summary>
            Registers a <see cref="T:UIShell.OSGi.Logging.ExceptionFormatter"/> for a logger for the specified type.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the logger was created for</param>
            <param name="formatter">The <see cref="T:UIShell.OSGi.Logging.ExceptionFormatter"/> to register</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="type"/> is null or empty, or if <paramref name="formatter"/> is null.
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.RegisterExceptionFormatterFor``1(UIShell.OSGi.Logging.ExceptionFormatter)">
            <summary>
            Registers a <see cref="T:UIShell.OSGi.Logging.ExceptionFormatter"/> for a logger for the specified type.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> the logger was created for</typeparam>
            <param name="formatter">The <see cref="T:UIShell.OSGi.Logging.ExceptionFormatter"/> to register</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="formatter"/> is null.
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.FindLogFor(System.String)">
            <summary>
            Finds a <see cref="T:UIShell.OSGi.Logging.Log"/> implementation for the logger with the specified name.
            </summary>
            <param name="name">The name of the logger to find a <see cref="T:UIShell.OSGi.Logging.Log"/> for.</param>
            <returns>A registered <see cref="T:UIShell.OSGi.Logging.Log"/> or the <see cref="P:UIShell.OSGi.Logging.Settings.DefaultLog"/>.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="name"/> is null or empty.</exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.FindLogFor(System.Type)">
            <summary>
            Finds a <see cref="T:UIShell.OSGi.Logging.Log"/> implementation for a logger for the specified type.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the logger was created for.</param>
            <returns>A registered <see cref="T:UIShell.OSGi.Logging.Log"/> or the <see cref="P:UIShell.OSGi.Logging.Settings.DefaultLog"/>.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="type"/> is null.</exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.FindLogFor``1">
            <summary>
            Finds a <see cref="T:UIShell.OSGi.Logging.Log"/> implementation for a logger for the specified type.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> the logger was created for.</typeparam>
            <returns>A registered <see cref="T:UIShell.OSGi.Logging.Log"/> or the <see cref="P:UIShell.OSGi.Logging.Settings.DefaultLog"/>.</returns>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.RegisterLogFor(System.String,UIShell.OSGi.Logging.Log)">
            <summary>
            Registers a <see cref="T:UIShell.OSGi.Logging.Log"/> for a logger with the specified name.
            </summary>
            <param name="name">The name of the logger to register for.</param>
            <param name="log">The <see cref="T:UIShell.OSGi.Logging.Log"/> to register</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="name"/> is null or empty.  Or if <paramref name="log"/> is null.
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.RegisterLogFor(System.Type,UIShell.OSGi.Logging.Log)">
            <summary>
            Registers a <see cref="T:UIShell.OSGi.Logging.Log"/> for a logger for the specified type.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the logger was created from.</param>
            <param name="log">The <see cref="T:UIShell.OSGi.Logging.Log"/> to register</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="type"/> is null.  Or if <paramref name="log"/> is null.
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Logging.Settings.RegisterLogFor``1(UIShell.OSGi.Logging.Log)">
            <summary>
            Registers a <see cref="T:UIShell.OSGi.Logging.Log"/> for a logger for the specified type.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> the logger was created from.</typeparam>
            <param name="log">The <see cref="T:UIShell.OSGi.Logging.Log"/> to register</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="log"/> is null.
            </exception>
        </member>
        <member name="P:UIShell.OSGi.Logging.Settings.Default">
            <summary>
            Gets or sets the default <see cref="T:UIShell.OSGi.Logging.Settings"/> instance for the current AppDomain
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Logging.Settings.DefaultLogLevel">
            <summary>
            Gets or sets the default <see cref="T:UIShell.OSGi.Logging.LogLevel"/>
            </summary>
            <remarks>
            This <see cref="T:UIShell.OSGi.Logging.LogLevel"/> is used when no specific level is registered for a log name.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">If value is not a valid LogLevel</exception>
            <seealso cref="T:UIShell.OSGi.Logging.LogLevel"/>
        </member>
        <member name="P:UIShell.OSGi.Logging.Settings.DefaultLog">
            <summary>
            Gets or sets the default <see cref="T:UIShell.OSGi.Logging.Log"/>.
            </summary>
            <remarks>
            <para>
            This <see cref="T:UIShell.OSGi.Logging.Log"/> is used when no specific level is registered for a log name.
            </para>
            <para>
            This property will always be set.  If you try to set to null, it will reset
            itself to the <see cref="T:UIShell.OSGi.Logging.Logs.StdErrLog"/>.
            </para>
            </remarks>
            <seealso cref="T:UIShell.OSGi.Logging.Log"/>
        </member>
        <member name="T:UIShell.OSGi.Logging.Settings.DefaultSettingsHolder">
            <summary>
            Holds our default Settings instance
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Logging.Util.Clock">
            <summary>
            Simple Clock abstraction to make unit testing deterministic
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Logging.Util.Clock.#cctor">
            <summary>
            Initializes static members of the Clock class.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Logging.Util.Clock.Reset">
            <summary>
            Resets the clock to use <see cref="P:System.DateTime.Now"/> and <see cref="P:System.DateTime.UtcNow"/>
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Logging.Util.Clock.SetNow(System.DateTime)">
            <summary>
            Sets the Clock to always return <paramref name="now"/> when <see cref="P:UIShell.OSGi.Logging.Util.Clock.Now"/> called.
            </summary>
            <param name="now">The Local <see cref="T:System.DateTime"/> to return</param>
            <remarks>
            If <paramref name="now"/> is not <see cref="F:System.DateTimeKind.Local"/>, it will
            be converted to <see cref="F:System.DateTimeKind.Local"/>.
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.Util.Clock.SetUtcNow(System.DateTime)">
            <summary>
            Sets the Clock to always return <paramref name="now"/> when <see cref="P:UIShell.OSGi.Logging.Util.Clock.UtcNow"/> called.
            </summary>
            <param name="now">The UTC <see cref="T:System.DateTime"/> to return</param>
            <remarks>
            If <paramref name="now"/> is not <see cref="F:System.DateTimeKind.Utc"/>, it will
            be converted to <see cref="F:System.DateTimeKind.Utc"/>.
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Logging.Util.Clock.SetNowProvider(UIShell.OSGi.Logging.Util.FuncDelegate{System.DateTime})">
            <summary>
            Sets the Clock to use the <paramref name="nowProvider"/> when <see cref="P:UIShell.OSGi.Logging.Util.Clock.Now"/> is called.
            </summary>
            <param name="nowProvider">The function to call to get a DateTime</param>
        </member>
        <member name="M:UIShell.OSGi.Logging.Util.Clock.SetUtcNowProvider(UIShell.OSGi.Logging.Util.FuncDelegate{System.DateTime})">
            <summary>
            Sets the Clock to use the <paramref name="utcNowProvider"/> when <see cref="P:UIShell.OSGi.Logging.Util.Clock.UtcNow"/> is called.
            </summary>
            <param name="utcNowProvider">The function to call to get a DateTime</param>
        </member>
        <member name="P:UIShell.OSGi.Logging.Util.Clock.Now">
            <summary>
            Gets the current Local <see cref="T:System.DateTime"/>
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Logging.Util.Clock.UtcNow">
            <summary>
            Gets the current UTC <see cref="T:System.DateTime"/>
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Logging.Util.ExceptionExtensions">
            <summary>
            Simple extensions to the Exception class
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Persistent.BundlePersistentData.Load(System.String)">
            <summary>
            Loads storage data from the specified file.
            </summary>
            <param name="file">The file.</param>
            <returns></returns>
        </member>
        <member name="T:UIShell.OSGi.ServiceEventArgs">
            <summary>
            服务注册、卸载和更改事件。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.ServiceEventArgs.ServiceEventType">
            <summary>
            服务事件类型。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.ServiceEventArgs.ServiceType">
            <summary>
            注册服务使用的接口类型的FullName
            </summary>
        </member>
        <member name="P:UIShell.OSGi.ServiceEventArgs.ServiceInstances">
            <summary>
            服务对象。
            </summary>
        </member>
        <member name="T:UIShell.OSGi.ServiceEventType">
            <summary>
            服务事件类型。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.ServiceEventType.Add">
            <summary>
            注册。
            </summary>
        </member>
        <member name="F:UIShell.OSGi.ServiceEventType.Remove">
            <summary>
            卸载。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Utility.BundleUtility.BuildFragments(UIShell.OSGi.Dependency.Resolver.IHostBundleMetadataNode)">
            <summary>
            为一个HostBundleNode创建片段Bundle节点（原有的所有节点都会被清除）
            </summary>
            <param name="hostNode">The host node.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.BundleUtility.FindAssemblyFullPath(System.String,System.String)">
            <summary>
            尝试从bundlePath目录下查找searchFile文件
            </summary>
            <returns>如果成功，则返回文件全路径，否则返回string.Empty</returns>
        </member>
        <member name="T:UIShell.OSGi.Utility.ExceptionFormatter">
            <summary>
            Represents the base class from which all implementations of exception formatters must derive. The formatter provides functionality for formatting <see cref="P:UIShell.OSGi.Utility.ExceptionFormatter.Exception"/> objects.
            </summary>	
        </member>
        <member name="M:UIShell.OSGi.Utility.ExceptionFormatter.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:UIShell.OSGi.Utility.ExceptionFormatter"/> class with an <see cref="P:UIShell.OSGi.Utility.ExceptionFormatter.Exception"/> to format.
            </summary>
            <param name="exception">The <see cref="P:UIShell.OSGi.Utility.ExceptionFormatter.Exception"/> object to format.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.ExceptionFormatter.Format">
            <summary>
            Formats the <see cref="P:UIShell.OSGi.Utility.ExceptionFormatter.Exception"/> into the underlying stream.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Utility.ExceptionFormatter.WriteException(System.Exception,System.Exception)">
            <summary>
            Formats the exception and all nested inner exceptions.
            </summary>
            <param name="exceptionToFormat">The exception to format.</param>
            <param name="outerException">The outer exception. This 
            value will be null when writing the outer-most exception.</param>
            <remarks>
            <para>This method calls itself recursively until it reaches
            an exception that does not have an inner exception.</para>
            <para>
            This is a template method which calls the following
            methods in order
            <list type="number">
            <item>
            <description><see cref="M:UIShell.OSGi.Utility.ExceptionFormatter.WriteExceptionType(System.Type)"/></description>
            </item>
            <item>
            <description><see cref="M:UIShell.OSGi.Utility.ExceptionFormatter.WriteMessage(System.String)"/></description>
            </item>
            <item>
            <description><see cref="M:UIShell.OSGi.Utility.ExceptionFormatter.WriteSource(System.String)"/></description>
            </item>
            <item>
            <description><see cref="M:UIShell.OSGi.Utility.ExceptionFormatter.WriteHelpLink(System.String)"/></description>
            </item>
            <item>
            <description><see cref="M:UIShell.OSGi.Utility.ExceptionFormatter.WriteReflectionInfo(System.Exception)"/></description>
            </item>
            <item>
            <description><see cref="M:UIShell.OSGi.Utility.ExceptionFormatter.WriteStackTrace(System.String)"/></description>
            </item>
            <item>
            <description>If the specified exception has an inner exception
            then it makes a recursive call. <see cref="M:UIShell.OSGi.Utility.ExceptionFormatter.WriteException(System.Exception,System.Exception)"/></description>
            </item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Utility.ExceptionFormatter.WriteReflectionInfo(System.Exception)">
            <summary>
            Formats an <see cref="P:UIShell.OSGi.Utility.ExceptionFormatter.Exception"/> using reflection to get the information.
            </summary>
            <param name="exceptionToFormat">
            The <see cref="P:UIShell.OSGi.Utility.ExceptionFormatter.Exception"/> to be formatted.
            </param>
            <remarks>
            <para>This method reflects over the public, instance properties 
            and public, instance fields
            of the specified exception and prints them to the formatter.  
            Certain property names are ignored
            because they are handled explicitly in other places.</para>
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Utility.ExceptionFormatter.WriteDescription">
            <summary>
            When overridden by a class, writes a description of the caught exception.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Utility.ExceptionFormatter.WriteDateTime(System.DateTime)">
            <summary>
            When overridden by a class, writes the current time.
            </summary>
            <param name="utcNow">The current time.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.ExceptionFormatter.WriteExceptionType(System.Type)">
            <summary>
            When overridden by a class, writes the <see cref="T:System.Type"/> of the current exception.
            </summary>
            <param name="exceptionType">The <see cref="T:System.Type"/> of the exception.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.ExceptionFormatter.WriteMessage(System.String)">
            <summary>
            When overridden by a class, writes the <see cref="P:System.Exception.Message"/>.
            </summary>
            <param name="message">The message to write.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.ExceptionFormatter.WriteSource(System.String)">
            <summary>
            When overridden by a class, writes the value of the <see cref="P:System.Exception.Source"/> property.
            </summary>
            <param name="source">The source of the exception.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.ExceptionFormatter.WriteHelpLink(System.String)">
            <summary>
            When overridden by a class, writes the value of the <see cref="P:System.Exception.HelpLink"/> property.
            </summary>
            <param name="helpLink">The help link for the exception.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.ExceptionFormatter.WriteStackTrace(System.String)">
            <summary>
            When overridden by a class, writes the value of the <see cref="P:System.Exception.StackTrace"/> property.
            </summary>
            <param name="stackTrace">The stack trace of the exception.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.ExceptionFormatter.WritePropertyInfo(System.Reflection.PropertyInfo,System.Object)">
            <summary>
            When overridden by a class, writes the value of a <see cref="T:System.Reflection.PropertyInfo"/> object.
            </summary>
            <param name="propertyInfo">The reflected <see cref="T:System.Reflection.PropertyInfo"/> object.</param>
            <param name="value">The value of the <see cref="T:System.Reflection.PropertyInfo"/> object.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.ExceptionFormatter.WriteFieldInfo(System.Reflection.FieldInfo,System.Object)">
            <summary>
            When overridden by a class, writes the value of a <see cref="T:System.Reflection.FieldInfo"/> object.
            </summary>
            <param name="fieldInfo">The reflected <see cref="T:System.Reflection.FieldInfo"/> object.</param>
            <param name="value">The value of the <see cref="T:System.Reflection.FieldInfo"/> object.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.ExceptionFormatter.WriteAdditionalInfo(System.Collections.Specialized.NameValueCollection)">
            <summary>
            When overridden by a class, writes additional properties if available.
            </summary>
            <param name="additionalInformation">Additional information to be included with the exception report</param>
        </member>
        <member name="P:UIShell.OSGi.Utility.ExceptionFormatter.Exception">
            <summary>
            Gets the <see cref="P:UIShell.OSGi.Utility.ExceptionFormatter.Exception"/> to format.
            </summary>
            <value>
            The <see cref="P:UIShell.OSGi.Utility.ExceptionFormatter.Exception"/> to format.
            </value>
        </member>
        <member name="P:UIShell.OSGi.Utility.ExceptionFormatter.AdditionalInfo">
            <summary>
            Gets additional information related to the <see cref="P:UIShell.OSGi.Utility.ExceptionFormatter.Exception"/> but not
            stored in the exception (eg: the time in which the <see cref="P:UIShell.OSGi.Utility.ExceptionFormatter.Exception"/> was 
            thrown).
            </summary>
            <value>
            Additional information related to the <see cref="P:UIShell.OSGi.Utility.ExceptionFormatter.Exception"/> but not
            stored in the exception (for example, the time when the <see cref="P:UIShell.OSGi.Utility.ExceptionFormatter.Exception"/> was 
            thrown).
            </value>
        </member>
        <member name="T:UIShell.OSGi.Utility.FileData">
            <summary>
            Contains information about a file returned by the 
            <see cref="T:UIShell.OSGi.Utility.FastDirectoryEnumerator"/> class.
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Utility.FileData.Attributes">
            <summary>
            Attributes of the file.
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Utility.FileData.CreationTimeUtc">
            <summary>
            File creation time in UTC
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Utility.FileData.LastAccessTimeUtc">
            <summary>
            File last access time in UTC
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Utility.FileData.LastWriteTimeUtc">
            <summary>
            File last write time in UTC
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Utility.FileData.Size">
            <summary>
            Size of the file in bytes
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Utility.FileData.Name">
            <summary>
            Name of the file
            </summary>
        </member>
        <member name="F:UIShell.OSGi.Utility.FileData.Path">
            <summary>
            Full path to the file.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileData.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileData.#ctor(System.String,UIShell.OSGi.Utility.WIN32_FIND_DATA)">
            <summary>
            Initializes a new instance of the <see cref="T:UIShell.OSGi.Utility.FileData"/> class.
            </summary>
            <param name="dir">The directory that the file is stored at</param>
            <param name="findData">WIN32_FIND_DATA structure that this
            object wraps.</param>
        </member>
        <member name="P:UIShell.OSGi.Utility.FileData.LastAccesTime">
            <summary>
            Gets the last access time in local time.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.FileData.LastWriteTime">
            <summary>
            Gets the last access time in local time.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Utility.WIN32_FIND_DATA">
            <summary>
            Contains information about the file that is found 
            by the FindFirstFile or FindNextFile functions.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Utility.WIN32_FIND_DATA.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:UIShell.OSGi.Utility.FastDirectoryEnumerator">
            <summary>
            A fast enumerator of files in a directory.  Use this if you need to get attributes for 
            all files in a directory.
            </summary>
            <remarks>
            This enumerator is substantially faster than using <see cref="M:System.IO.Directory.GetFiles(System.String)"/>
            and then creating a new FileInfo object for each path.  Use this version when you 
            will need to look at the attibutes of each file returned (for example, you need
            to check each file in a directory to see if it was modified after a specific date).
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Utility.FastDirectoryEnumerator.EnumerateFiles(System.String)">
            <summary>
            Gets <see cref="T:UIShell.OSGi.Utility.FileData"/> for all the files in a directory.
            </summary>
            <param name="path">The path to search.</param>
            <returns>An object that implements <see cref="T:System.Collections.Generic.IEnumerable`1"/> and 
            allows you to enumerate the files in the given directory.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="path"/> is a null reference (Nothing in VB)
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Utility.FastDirectoryEnumerator.EnumerateFiles(System.String,System.String)">
            <summary>
            Gets <see cref="T:UIShell.OSGi.Utility.FileData"/> for all the files in a directory that match a 
            specific filter.
            </summary>
            <param name="path">The path to search.</param>
            <param name="searchPattern">The search string to match against files in the path.</param>
            <returns>An object that implements <see cref="T:System.Collections.Generic.IEnumerable`1"/> and 
            allows you to enumerate the files in the given directory.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="path"/> is a null reference (Nothing in VB)
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="filter"/> is a null reference (Nothing in VB)
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Utility.FastDirectoryEnumerator.EnumerateFiles(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Gets <see cref="T:UIShell.OSGi.Utility.FileData"/> for all the files in a directory that 
            match a specific filter, optionally including all sub directories.
            </summary>
            <param name="path">The path to search.</param>
            <param name="searchPattern">The search string to match against files in the path.</param>
            <param name="searchOption">
            One of the SearchOption values that specifies whether the search 
            operation should include all subdirectories or only the current directory.
            </param>
            <returns>An object that implements <see cref="T:System.Collections.Generic.IEnumerable`1"/> and 
            allows you to enumerate the files in the given directory.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="path"/> is a null reference (Nothing in VB)
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="filter"/> is a null reference (Nothing in VB)
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="searchOption"/> is not one of the valid values of the
            <see cref="T:System.IO.SearchOption"/> enumeration.
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Utility.FastDirectoryEnumerator.GetFiles(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Gets <see cref="T:UIShell.OSGi.Utility.FileData"/> for all the files in a directory that match a 
            specific filter.
            </summary>
            <param name="path">The path to search.</param>
            <param name="searchPattern">The search string to match against files in the path.</param>
            <returns>An object that implements <see cref="T:System.Collections.Generic.IEnumerable`1"/> and 
            allows you to enumerate the files in the given directory.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="path"/> is a null reference (Nothing in VB)
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="filter"/> is a null reference (Nothing in VB)
            </exception>
        </member>
        <member name="T:UIShell.OSGi.Utility.FastDirectoryEnumerator.FileEnumerable">
            <summary>
            Provides the implementation of the 
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Utility.FastDirectoryEnumerator.FileEnumerable.#ctor(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Initializes a new instance of the <see cref="T:UIShell.OSGi.Utility.FastDirectoryEnumerator.FileEnumerable"/> class.
            </summary>
            <param name="path">The path to search.</param>
            <param name="filter">The search string to match against files in the path.</param>
            <param name="searchOption">
            One of the SearchOption values that specifies whether the search 
            operation should include all subdirectories or only the current directory.
            </param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FastDirectoryEnumerator.FileEnumerable.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can 
            be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:UIShell.OSGi.Utility.FastDirectoryEnumerator.FileEnumerable.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be 
            used to iterate through the collection.
            </returns>
        </member>
        <member name="T:UIShell.OSGi.Utility.FastDirectoryEnumerator.SafeFindHandle">
            <summary>
            Wraps a FindFirstFile handle.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Utility.FastDirectoryEnumerator.SafeFindHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:UIShell.OSGi.Utility.FastDirectoryEnumerator.SafeFindHandle"/> class.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Utility.FastDirectoryEnumerator.SafeFindHandle.ReleaseHandle">
            <summary>
            When overridden in a derived class, executes the code required to free the handle.
            </summary>
            <returns>
            true if the handle is released successfully; otherwise, in the 
            event of a catastrophic failure, false. In this case, it 
            generates a releaseHandleFailed MDA Managed Debugging Assistant.
            </returns>
        </member>
        <member name="T:UIShell.OSGi.Utility.FastDirectoryEnumerator.FileEnumerator">
            <summary>
            Provides the implementation of the 
            <see cref="T:System.Collections.Generic.IEnumerator`1"/> interface
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Utility.FastDirectoryEnumerator.FileEnumerator.#ctor(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Initializes a new instance of the <see cref="T:UIShell.OSGi.Utility.FastDirectoryEnumerator.FileEnumerator"/> class.
            </summary>
            <param name="path">The path to search.</param>
            <param name="filter">The search string to match against files in the path.</param>
            <param name="searchOption">
            One of the SearchOption values that specifies whether the search 
            operation should include all subdirectories or only the current directory.
            </param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FastDirectoryEnumerator.FileEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, 
            or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Utility.FastDirectoryEnumerator.FileEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; 
            false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created.
            </exception>
        </member>
        <member name="M:UIShell.OSGi.Utility.FastDirectoryEnumerator.FileEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created.
            </exception>
        </member>
        <member name="P:UIShell.OSGi.Utility.FastDirectoryEnumerator.FileEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <value></value>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:UIShell.OSGi.Utility.FastDirectoryEnumerator.FileEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <value></value>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="T:UIShell.OSGi.Utility.FastDirectoryEnumerator.FileEnumerator.SearchContext">
            <summary>
            Hold context information about where we current are in the directory search.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Utility.FileLogUtility">
            <summary>
            文件日志辅助类。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Init">
            <summary>
            Init FileLogUtility Logger instance with specified name and location
            </summary>
            <param name="logName">Log name</param>
            <param name="logLocation">Log location</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.SetFileLogEnabled(System.Boolean)">
            <summary>
            设置是否启用日志。该方法必须最早来调用。
            </summary>
            <param name="enabled">是否启用日志。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.SetLogFileName(System.String)">
            <summary>
            设置日志文件名，默认是log.txt。该方法必须最早调用。
            </summary>
            <param name="fileName">方法文件名。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.SetLogDirectory(System.String)">
            <summary>
            设置日志文件名，默认是log.txt。该方法必须最早调用。
            </summary>
            <param name="fileName">方法文件名。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.SetLogLevel(UIShell.OSGi.Logging.LogLevel)">
            <summary>
            设置日志的级别。
            </summary>
            <param name="level"></param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.SetMaxFileSizeByMB(System.Int32)">
            <summary>
            Set the max size of log file.
            </summary>
            <param name="sizeMB">Size by MB unit.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.SetCreateNewFileOnMaxSize(System.Boolean)">
            <summary>
            Create a new log file on max size.
            </summary>
            <param name="createNew">Wether create a new one or not.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Debug(System.String)">
            <summary>
            记录一条Debug级别的消息，表示用于调试的信息，面向开发者的。
            </summary>
            <param name="message">字符串消息。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Debug(System.Exception)">
            <summary>
            记录一个Debug级别的异常，表示用于调试的信息，面向开发者的。
            </summary>
            <param name="ex">异常。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Debug(UIShell.OSGi.Logging.MessageGenerator)">
            <summary>
            通过消息生成器记录一条Debug级别消息，表示用于调试的信息，面向开发者的。
            </summary>
            <param name="message">消息生成器。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Error(System.String)">
            <summary>
            记录一条Error级别的消息，表示比较严重的错误消息，面向用户。
            </summary>
            <param name="message">字符串消息。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Error(System.Exception)">
            <summary>
            记录一个Error级别的异常，表示比较严重的错误消息，面向用户。
            </summary>
            <param name="ex">异常。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Error(UIShell.OSGi.Logging.MessageGenerator)">
            <summary>
            通过消息生成器记录一条Error级别消息，表示比较严重的错误消息，面向用户。
            </summary>
            <param name="message">消息生成器。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Fatal(System.Exception)">
            <summary>
            记录一个Fatal级别的异常，表示致命性的错误消息，面向用户。
            </summary>
            <param name="ex">异常。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Fatal(UIShell.OSGi.Logging.MessageGenerator)">
            <summary>
            通过消息生成器记录一条Fatal级别消息，表示致命性的错误消息，面向用户。
            </summary>
            <param name="message">消息生成器。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Fatal(System.String)">
            <summary>
            记录一条Fatal级别的消息，表示致命性的错误消息，面向用户。
            </summary>
            <param name="message">字符串消息。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Inform(System.String)">
            <summary>
            记录一条Inform级别的消息，表示一个程序运行中正常的信息，面向用户。
            </summary>
            <param name="message">字符串消息。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Inform(UIShell.OSGi.Logging.MessageGenerator)">
            <summary>
            通过消息生成器记录一条Inform级别消息，表示一个程序运行中正常的信息，面向用户。
            </summary>
            <param name="message">消息生成器。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Inform(System.Exception)">
            <summary>
            记录一个Inform级别的异常，表示一个程序运行中正常的信息，面向用户。
            </summary>
            <param name="ex">异常。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Verbose(System.String)">
            <summary>
            记录一条Verbose级别的消息，表示非常详细的调试信息，比如事件信息等，面向开发者。
            </summary>
            <param name="message">字符串消息。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Verbose(UIShell.OSGi.Logging.MessageGenerator)">
            <summary>
            通过消息生成器记录一条Verbose级别消息，表示非常详细的调试信息，比如事件信息等，面向开发者。
            </summary>
            <param name="message">消息生成器。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Verbose(System.Exception)">
            <summary>
            记录一个Verbose级别的异常，表示非常详细的调试信息，比如事件信息等，面向开发者。
            </summary>
            <param name="ex">异常。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Warn(System.String)">
            <summary>
            记录一条Warn级别的消息，表示异常警告的消息，面向用户。
            </summary>
            <param name="message">字符串消息。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Warn(UIShell.OSGi.Logging.MessageGenerator)">
            <summary>
            通过消息生成器记录一条Warn级别消息，表示异常警告的消息，面向用户。
            </summary>
            <param name="message">消息生成器。</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.FileLogUtility.Warn(System.Exception)">
            <summary>
            记录一个Warn级别的异常，表示异常警告的消息，面向用户。
            </summary>
            <param name="ex">异常。</param>
        </member>
        <member name="T:UIShell.OSGi.Utility.Messages">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.AccquireReaderLockFailed">
            <summary>
              Looks up a localized string similar to {0} accquires reader lock failed..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.AccquireReaderLockSuccessfully">
            <summary>
              Looks up a localized string similar to {0} accquires reader lock successfully..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.AccquireReaderLockTimeOut">
            <summary>
              Looks up a localized string similar to Accquire reader lock time out..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.AccquireWriterLockFailed">
            <summary>
              Looks up a localized string similar to {0} accquires writer lock failed..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.AccquireWriterLockSuccessfully">
            <summary>
              Looks up a localized string similar to {0} accquires writer lock successfully..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.AccquireWriterLockTimeOut">
            <summary>
              Looks up a localized string similar to Accquire writer lock time out..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.AcquireTheLockTimeout">
            <summary>
              Looks up a localized string similar to Acquire the lock timeout. The limited time is {0} milliseconds..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.AdditionalInfo">
            <summary>
              Looks up a localized string similar to Additional Info:.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.AssemblyFileUpdated">
            <summary>
              Looks up a localized string similar to The assembly file &apos;{0}&apos; is updated..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.AssemblyLoadedMessage">
            <summary>
              Looks up a localized string similar to Loaded assembly: &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.AssemblyLoadFailed">
            <summary>
              Looks up a localized string similar to Load assembly &apos;{0}&apos; failed. The exception will be shown as below..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.AtLeastOnePluginsPathMustBeSpecified">
            <summary>
              Looks up a localized string similar to At least one plugins path must be specified..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleActionTimeCounter">
            <summary>
              Looks up a localized string similar to Spend {0} ms to {1} bundle &apos;{2}, {3}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleActivatorFailedToStart">
            <summary>
              Looks up a localized string similar to The activator of bundle &apos;{0}&apos; start failed..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleActivatorNotImplementIBundleActivator">
            <summary>
              Looks up a localized string similar to Activator type &apos;{0}&apos; of bundle &apos;{1}&apos; does not inherit from IBundleActivator..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleActivatorTypeFailedToLoad">
            <summary>
              Looks up a localized string similar to Can not load the type activator &apos;{0}&apos; for bundle &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleAssemblyLoadFailed">
            <summary>
              Looks up a localized string similar to Can not load assembly &apos;{0}&apos; for bundle &apos;{1}, {2}&apos;, Exception: &apos;{3}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleAssemblyMultipleVersionsDefaultValue">
            <summary>
              Looks up a localized string similar to The OSGi.NET does not enable the multiple versions supporting by default. You can set the BundleRuntime.SupportMultipleVersionsByDefault to true to enable the multiple versions supporting..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleContextDisposed">
            <summary>
              Looks up a localized string similar to The bundle context of bundle &apos;{0}, {1}&apos; is disposed. You can use the bundle context only when the bundle is active..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleDependentAssemblyNotResolved">
            <summary>
              Looks up a localized string similar to The bundle &apos;{0}, {1}&apos; can not be resolved since the dependent assembly &apos;assembly: {2}, {3}, bundle: {4}, {5}&apos; can not be met. Make sure that the dependent assembly is existed and is a shared assembly..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleDependentBundleNotResolved">
            <summary>
              Looks up a localized string similar to The bundle &apos;{0}, {1}&apos; can not be resolved since the dependent bundle &apos;{2}, {3}&apos; can not be met..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleInState">
            <summary>
              Looks up a localized string similar to Bundle &apos;{0}, {1}&apos; is in state &apos;{2}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleLocalAssemblyResolvedFailed">
            <summary>
              Looks up a localized string similar to The bundle &apos;{0}, {1}&apos; can not be resolved since the local assembly &apos;{2}&apos; can not be loaded..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleMarkedUnresolved">
            <summary>
              Looks up a localized string similar to The bundle &apos;{0}, {1}&apos; is marked as unresolved since the dependent bundle &apos;{2}, {3}&apos; can not be resolved..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleNotExist">
            <summary>
              Looks up a localized string similar to Bundle &apos;{0}&apos; does not exist..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleNotResolved">
            <summary>
              Looks up a localized string similar to The bundle &apos;{0}, {1}&apos; can not be resolved..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleNotResolvedWithCause">
            <summary>
              Looks up a localized string similar to The bundle &apos;{0}, {1}&apos; is started failed since it can not be resolved..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundlePersistentFileFailedToLoad">
            <summary>
              Looks up a localized string similar to Load persistent file &apos;{0}&apos; fail..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleStarting">
            <summary>
              Looks up a localized string similar to Bundle &apos;{0}, {1}&apos; is starting..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleStartingInteruppted">
            <summary>
              Looks up a localized string similar to The bundle &apos;{0}&apos; starting progress is interupted. The reason is: {1}.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleStateChangeLockFailed">
            <summary>
              Looks up a localized string similar to Acquire lock to change the state of bundle &apos;{0}, {1}&apos; failed..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleStopping">
            <summary>
              Looks up a localized string similar to Bundle &apos;{0}, {1}&apos; is stopping..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleThrownFrameworkError">
            <summary>
              Looks up a localized string similar to The bundle &apos;{0}, {1}&apos; thrown a framework error..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleThrownFrameworkWarning">
            <summary>
              Looks up a localized string similar to The bundle &apos;{0}, {1}&apos; thrown a framework warning..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleUninstalling">
            <summary>
              Looks up a localized string similar to Bundle &apos;{0}, {1}&apos; is uninstalling..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.BundleUnresolveFailed">
            <summary>
              Looks up a localized string similar to Bundle &apos;{0}&apos; unresolve failed..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.CanNotGetEncoderForManifest">
            <summary>
              Looks up a localized string similar to Can not get the encoder for Manifest.xml file. Try to user UTF8 encoder by default..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.CanNotLoadClassFromFragmentBundle">
            <summary>
              Looks up a localized string similar to Can not load class from fragment bundle..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.CPUTime">
            <summary>
              Looks up a localized string similar to 	CPU time:		.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.CPUTimeOneTime">
            <summary>
              Looks up a localized string similar to 	CPU time (one time):	.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.DeleteDirectoryFailed">
            <summary>
              Looks up a localized string similar to Delete the directory &apos;{0}&apos; failed for &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.DisableMultipleVersionsFeature">
            <summary>
              Looks up a localized string similar to The OSGi.NET does not enable the supporting for the assemblies with multiple versions. The assembly will be loaded by using Assembly.LoadFrom..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.EnableMultipleVersionsFeature">
            <summary>
              Looks up a localized string similar to The OSGi.NET enable the supporting for the assemblies with multiple versions. The assembly will be loaded by using Assembly.LoadFile..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.EnableShadowCopyFeature">
            <summary>
              Looks up a localized string similar to The OSGi.NET enable the supporting for the assemblies shadow copy. This feature is helpful in ASP.NET application since the assembly is not locked. Thus the OSGi.NET will copy the aseembly as a .shadow file and load this shadow copy file into framework. Further more, the OSGi.NET will monitor the original assembly file, once changed will throw a FrameworkEventType.ShadowAssemblyChanged framework event by AssemblyShadowCopyMonitor. In ASP.NET application enviorment, you can monitor this event to restart the  [rest of string was truncated]&quot;;.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.ExceptionOccursWhenStopping">
            <summary>
              Looks up a localized string similar to Stopping bundle &apos;{0}, {1}&apos; throws an exception when the invoking IBundleActivator.Stop method..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.ExceptionOccursWhenUninstalling">
            <summary>
              Looks up a localized string similar to Uninstalling bundle &apos;{0}, {1}&apos; occurs an exceptioon and the exception will be ignored to contine the uninstallation..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.ExceptionWasCaught">
            <summary>
              Looks up a localized string similar to An exception of type &apos;{0}&apos; occurred and was caught..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.FailedToBackupBundle">
            <summary>
              Looks up a localized string similar to Failed to backup bundle &apos;{0}&apos; on &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.FailedToCreateAssemblyShadowCopy">
            <summary>
              Looks up a localized string similar to Failed to create shadow copy for assembly &apos;{0}&apos; in bundle &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.FailedToCreateServiceInstance">
            <summary>
              Looks up a localized string similar to Can not create service instance for type: {0}..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.FailedToLoadAssembly">
            <summary>
              Looks up a localized string similar to Failed to load assembly &apos;{0}&apos;. The exception will be shown as below..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.FailedToLoadAssemblyWithoutEx">
            <summary>
              Looks up a localized string similar to Failed to load assembly &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.FailedToLoadFrameworkPersistentFile">
            <summary>
              Looks up a localized string similar to Failed to load framework persistent file &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.FailedToLoadPersistence">
            <summary>
              Looks up a localized string similar to Failed to load persistence file &apos;{0}&apos; since &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.FailedToLoadServiceType">
            <summary>
              Looks up a localized string similar to Can not load service class type: {0}..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.FailedToSavePersistence">
            <summary>
              Looks up a localized string similar to Failed to save object to persistence file &apos;{0}&apos; since &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.FieldAccessFailed">
            <summary>
              Looks up a localized string similar to Access failed.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.FileNotFoundInBundle">
            <summary>
              Looks up a localized string similar to Can not find the file &apos;{0}&apos; under the bundle path &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.FindNewVersionOfBundle">
            <summary>
              Looks up a localized string similar to Find a new version of bundle &apos;{0}&apos;, the new version is &apos;{1}&apos;, while the old version is &apos;{2}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.FragmentBundleCanNotBeStarted">
            <summary>
              Looks up a localized string similar to Fragment bundle can not be started..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.FragmentBundleCanNotBeStopped">
            <summary>
              Looks up a localized string similar to Fragment bundle can not be stopped..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.FragmentDetachedForHostNotResolved">
            <summary>
              Looks up a localized string similar to The bundle &apos;{0}, {1}&apos; is detached from host bundle &apos;{2}, {3}&apos; since the host can not be resolved..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.FragmentNotDetachedFromHost">
            <summary>
              Looks up a localized string similar to A framgent node can only be detached from it&apos;s host node..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.FrameworkLicenseNotSupport">
            <summary>
              Looks up a localized string similar to Not support framework license type..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.FrameworkNotLicensed">
            <summary>
              Looks up a localized string similar to Framework starts fail, because no licensed bundle found..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.Gen">
            <summary>
              Looks up a localized string similar to 	Gen .
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.GetServiceFailed">
            <summary>
              Looks up a localized string similar to Error occurs when getting the service &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.GlobalAssemblyFeatureEnabled">
            <summary>
              Looks up a localized string similar to The OSGi.NET global assembly feature is enabled. Thus, the duplicated assembly in local Assembly of Bundle will be replaced by the global assembly in &apos;bin&apos; folder..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.HelpLink">
            <summary>
              Looks up a localized string similar to Help link : {0}.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.InnerException">
            <summary>
              Looks up a localized string similar to Inner Exception.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.InstallBundleFailed">
            <summary>
              Looks up a localized string similar to Install bundle from &apos;{0}&apos; failed for &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.InstallBundleFailedWithoutCause">
            <summary>
              Looks up a localized string similar to Install bundle in &apos;{0}&apos; failed..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.InstallBundlesTimeCounter">
            <summary>
              Looks up a localized string similar to Spend {0} ms to install bundles..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.InstallCmdUsage">
            <summary>
              Looks up a localized string similar to Install command usage should be: install &lt;location&gt;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.InvalidArgsWithUsage">
            <summary>
              Looks up a localized string similar to Invalid args, usage:.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.InvalidValue">
            <summary>
              Looks up a localized string similar to Invalid value..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.LoadAssemblyFailedSimple">
            <summary>
              Looks up a localized string similar to Load assembly &apos;{0}&apos; failed..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.LoadBundlesFailed">
            <summary>
              Looks up a localized string similar to Load bundles failed..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.LoadClassTimeCounter">
            <summary>
              Looks up a localized string similar to Spend {0} ms to load class &apos;{1}&apos; in bundle &apos;{1}, {2}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.LoadResourceTimeCounter">
            <summary>
              Looks up a localized string similar to Spend {0} ms to load resource &apos;{1}&apos; in bundle &apos;{2}, {3}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.LocalAssemblyReplacedByGlobal">
            <summary>
              Looks up a localized string similar to The local assembly &apos;{0}&apos; of bundle &apos;{1}, {2}&apos; is replaced by global assembly &apos;{3}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.LockingLogTimeout">
            <summary>
              Looks up a localized string similar to Waiting to enter the LockingLog lock timed out.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.LogLevelOutOfRange">
            <summary>
              Looks up a localized string similar to LogLevel is out of range..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.ManifestSectionInvalid">
            <summary>
              Looks up a localized string similar to The Manifest.xml of Bundle &apos;{3}&apos; error: the value &apos;{0}&apos; of attribute &apos;{1}&apos; in &apos;{2}&apos; XML section is invalid. It will be replaced by default value..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.ManifestSectionNotRecognized">
            <summary>
              Looks up a localized string similar to The Manifest.xml of Bundle &apos;{2}&apos; error: the attribute &apos;{0}&apos; of &apos;{1}&apos; XML section can not be recognized. It will be ignored..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.ManifestXmlnsNotCorrect">
            <summary>
              Looks up a localized string similar to The xmlns attribute of Bundle in Manifest.xml must be {0}..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.Message">
            <summary>
              Looks up a localized string similar to Message : {0}.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.NotAvailable">
            <summary>
              Looks up a localized string similar to N/A..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.NoThread">
            <summary>
              Looks up a localized string similar to No Thread Name.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.NotStartedSinceStartLevel">
            <summary>
              Looks up a localized string similar to Bundle &apos;{0}, {1}&apos; can not be started since its start level is bigger than the Framework&apos;s current start level..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.ObjectThrownFrameworkError">
            <summary>
              Looks up a localized string similar to The object &apos;{0}&apos; thrown a framework error..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.ObjectThrownFrameworkWarning">
            <summary>
              Looks up a localized string similar to The object &apos;{0}&apos; thrown a framework warning..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.ParameterMustString">
            <summary>
              Looks up a localized string similar to You must specify only objects of type \&quot;System.String\&quot; and \&quot;System.Type\&quot; here!.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.ParseManifestTimeCounter">
            <summary>
              Looks up a localized string similar to Spend {0} ms to parse the manifest file &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.PermissionDenied">
            <summary>
              Looks up a localized string similar to Permission Denied.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.PluginsDirectoryNotExist">
            <summary>
              Looks up a localized string similar to The full path &apos;{0}&apos; of plugins directory &apos;{1}&apos; does not exist..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.PropertyAccessFailed">
            <summary>
              Looks up a localized string similar to Access failed.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.ReleaseReaderLock">
            <summary>
              Looks up a localized string similar to {0} releases reader lock successfully..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.ReleaseWriterLock">
            <summary>
              Looks up a localized string similar to {0} releases writer lock successfully..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.RemoveCachedTypeForSize">
            <summary>
              Looks up a localized string similar to Remove a cached type. The max cache size of bundle &apos;{0}, {1}&apos; is {2}. You can use &apos;BundleRuntime.BundleClassLoaderCacheSize&apos; property to set the cache size..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.ResolveBundlesTimeCounter">
            <summary>
              Looks up a localized string similar to Spend {0} ms to resolve bundles..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.ServiceContractNoEmpty">
            <summary>
              Looks up a localized string similar to Service type can no be null or empty..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.ServiceNotAvailableEx">
            <summary>
              Looks up a localized string similar to Dependent service &apos;{0}&apos; in application &apos;{1}&apos; is not avaiable..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.ServiceNotImplementContarct">
            <summary>
              Looks up a localized string similar to The service instance {0} must implement the service contract type {1}..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.SingletonOSGiAllowed">
            <summary>
              Looks up a localized string similar to Only one instance of OSGi allows to be created..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.Source">
            <summary>
              Looks up a localized string similar to Source : {0}.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.StackTrace">
            <summary>
              Looks up a localized string similar to Stack Trace.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.StackTraceUnavailable">
            <summary>
              Looks up a localized string similar to The stack trace is unavailable..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.StartAction">
            <summary>
              Looks up a localized string similar to start.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.StartBundleFailed">
            <summary>
              Looks up a localized string similar to Start the bundle &apos;{0}, {1}&apos; failed..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.StartSystemBundleTimeCounter">
            <summary>
              Looks up a localized string similar to Spend {0} ms to start SystemBundle..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.StartTheFrameworkFailed">
            <summary>
              Looks up a localized string similar to Start the framework failed..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.StopAction">
            <summary>
              Looks up a localized string similar to stop.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.StopBundleFailed">
            <summary>
              Looks up a localized string similar to Stop the bundle &apos;{0}, {1}&apos; failed..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.StopSystemBundleTimeCounter">
            <summary>
              Looks up a localized string similar to Spend {0} ms to stop SystemBundle..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.StopTheFrameworkFailed">
            <summary>
              Looks up a localized string similar to Stop the framework failed..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.SymbolicNameDuplicated">
             <summary>
               Looks up a localized string similar to These two bundles have duplicated SymbolicName:
            {0}
            {1}.
             </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.SymbolicNameIsEmpty">
            <summary>
              Looks up a localized string similar to The SymbolicName of bundle &apos;{0}&apos; is empty..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.SystemBundleNotInstalled">
            <summary>
              Looks up a localized string similar to System bundle can not be uninstalled..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.TimedScheduleOutOfRange">
            <summary>
              Looks up a localized string similar to TimedRollingLog.Schedule is out of range..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.TimedTimeBasisOutOfRange">
            <summary>
              Looks up a localized string similar to TimedRollingLog.TimeBasis is out of range..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.TimeElapsed">
            <summary>
              Looks up a localized string similar to 	Time Elapsed:		.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.TimeElapsedOneTime">
            <summary>
              Looks up a localized string similar to 	Time Elapsed (one time):.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.TimeSpentForBundleManifestParsed">
            <summary>
              Looks up a localized string similar to Spend &apos;{0}&apos; ms to get &apos;{1}&apos; bundle manifest files parsed..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.TimeSpentForBundlesFound">
            <summary>
              Looks up a localized string similar to Spend &apos;{0}&apos; ms to get &apos;{1}&apos; bundles found..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.TypeString">
            <summary>
              Looks up a localized string similar to Type : {0}.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.UnhandledExceptionMsg">
            <summary>
              Looks up a localized string similar to Unhandled exception occurs. This issue is caused by &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.UninstallAction">
            <summary>
              Looks up a localized string similar to uninstall.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.UpgradeNewVersionOfBundle">
            <summary>
              Looks up a localized string similar to Upgrade the bundle &apos;{0}&apos; from version &apos;{1}&apos; to &apos;{2}&apos;..
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.Messages.WriterWriteFailed">
            <summary>
              Looks up a localized string similar to Failed to write message to TextWriterLog.writer - {0}.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Utility.ReaderWriterLockHelper">
            <summary>
            Reader/writer lock helper class.
            </summary>
            <example>
            private ReaderWriterLock _locker;
            
            using(ReaderWriterLockHelper.CreateReaderLock(_locker))
            {
                // Do some thing here. If lock accquire failed, log 
                // timeout warning message here. But the code will 
                // execute without any exception. This may cause some issues.
                
                // Code here...
            }
            
            using(ReaderWriterLockHelper.CreateWriterLock(_locker))
            {
                // Do some thing here. If lock accquire failed, log 
                // timeout warning message here. But the code will 
                // execute without any exception. This may cause some issues.
                
                // Code here...
            }
            
            </example>
        </member>
        <member name="M:UIShell.OSGi.Utility.StringUtility.IsAssemblyFullNameMatch(System.Reflection.AssemblyName,System.Reflection.AssemblyName,System.Boolean)">
            <summary>
            检查两个AssemblyName是否匹配
            </summary>
            <param name="assemblyName1"></param>
            <param name="assemblyName2"></param>
            <param name="exactMatch">true,则必须完全匹配，false，允许Filed一个为null一个有值</param>
            <returns></returns>
        </member>
        <member name="T:UIShell.OSGi.Utility.TextExceptionFormatter">
            <summary>
            Represents an exception formatter that formats exception objects as text.
            </summary>	
        </member>
        <member name="M:UIShell.OSGi.Utility.TextExceptionFormatter.#ctor(System.IO.TextWriter,System.Exception)">
            <summary>
            Initializes a new instance of the 
            <see cref="T:UIShell.OSGi.Utility.TextExceptionFormatter"/> using the specified
            <see cref="T:System.IO.TextWriter"/> and <see cref="T:System.Exception"/>
            objects.
            </summary>
            <param name="writer">The stream to write formatting information to.</param>
            <param name="exception">The exception to format.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.TextExceptionFormatter.WriteDescription">
            <summary>
            Writes a generic description to the underlying text stream.
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Utility.TextExceptionFormatter.WriteException(System.Exception,System.Exception)">
            <summary>
            Writes and formats the exception and all nested inner exceptions to the <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="exceptionToFormat">The exception to format.</param>
            <param name="outerException">The outer exception. This 
            value will be null when writing the outer-most exception.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.TextExceptionFormatter.WriteDateTime(System.DateTime)">
            <summary>
            Writes the current date and time to the <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="utcNow">The current time.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.TextExceptionFormatter.WriteExceptionType(System.Type)">
            <summary>
            Writes the value of the <see cref="P:System.Type.AssemblyQualifiedName"/>
            property for the specified exception type to the <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="exceptionType">The <see cref="T:System.Type"/> of the exception.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.TextExceptionFormatter.WriteMessage(System.String)">
            <summary>
            Writes the value of the <see cref="P:System.Exception.Message"/>
            property to the underyling <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="message">The message to write.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.TextExceptionFormatter.WriteSource(System.String)">
            <summary>
            Writes the value of the specified source taken
            from the value of the <see cref="P:System.Exception.Source"/>
            property to the <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="source">The source of the exception.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.TextExceptionFormatter.WriteHelpLink(System.String)">
            <summary>
            Writes the value of the specified help link taken
            from the value of the <see cref="P:System.Exception.HelpLink"/>
            property to the <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="helpLink">The exception's help link.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.TextExceptionFormatter.WritePropertyInfo(System.Reflection.PropertyInfo,System.Object)">
            <summary>
            Writes the name and value of the specified property to the <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="propertyInfo">The reflected <see cref="T:System.Reflection.PropertyInfo"/> object.</param>
            <param name="value">The value of the <see cref="T:System.Reflection.PropertyInfo"/> object.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.TextExceptionFormatter.WriteFieldInfo(System.Reflection.FieldInfo,System.Object)">
            <summary>
            Writes the name and value of the specified field to the <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="fieldInfo">The reflected <see cref="T:System.Reflection.FieldInfo"/> object.</param>
            <param name="value">The value of the <see cref="T:System.Reflection.FieldInfo"/> object.</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.TextExceptionFormatter.WriteStackTrace(System.String)">
            <summary>
            Writes the value of the <see cref="P:System.Exception.StackTrace"/> property to the <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="stackTrace">The stack trace of the exception.</param>
            <remarks>
            If there is no stack trace available, an appropriate message will be displayed.
            </remarks>
        </member>
        <member name="M:UIShell.OSGi.Utility.TextExceptionFormatter.WriteAdditionalInfo(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Writes the additional properties to the <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="additionalInformation">Additional information to be included with the exception report</param>
        </member>
        <member name="M:UIShell.OSGi.Utility.TextExceptionFormatter.Indent">
            <summary>
            Indents the <see cref="T:System.IO.TextWriter"/>.
            </summary>
        </member>
        <member name="P:UIShell.OSGi.Utility.TextExceptionFormatter.Writer">
            <summary>
            Gets the underlying <see cref="T:System.IO.TextWriter"/>
            that the current formatter is writing to.
            </summary>
        </member>
        <member name="T:UIShell.OSGi.Utility.TypeConverterUtility">
            <summary>
            类型转换辅助类。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.Utility.ListUtility.Union``1(System.Collections.Generic.List{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Union list b to list a.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="listA"></param>
            <param name="listB"></param>
        </member>
        <member name="M:UIShell.OSGi.Utility.ListUtility.ArrayContains``1(``0[],``0[])">
            <summary>
            判断一个数组是否在另外一个数组中
            </summary>
            <typeparam name="T"></typeparam>
            <param name="parent"></param>
            <param name="child"></param>
            <returns></returns>
        </member>
        <member name="M:UIShell.OSGi.Utility.ListUtility.ArrayContains``1(``0[],``0)">
            <summary>
            判断1项是否在一个数组中
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:UIShell.OSGi.VersionRange">
            <summary>
            版本范围，用于"[A,B)"区间版本号的表示。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.VersionRange.#ctor">
            <summary>
            创建一个版本范围对象。
            </summary>
        </member>
        <member name="M:UIShell.OSGi.VersionRange.#ctor(System.String,System.String)">
            <summary>
            创建一个指定最小版本和最大版本的版本范围对象。
            </summary>
            <param name="minVersion">最小版本。</param>
            <param name="maxVersion">最大版本。</param>
        </member>
        <member name="M:UIShell.OSGi.VersionRange.#ctor(System.String)">
            <summary>
            解析一个版本范围。
            </summary>
            <param name="version">字符串版本范围。</param>
        </member>
        <member name="M:UIShell.OSGi.VersionRange.IsIncluded(System.Version)">
            <summary>
            判断一个版本是否在该版本范围内。
            </summary>
            <param name="version">指定版本。</param>
            <returns>如果包含，返回true，否则false。</returns>
        </member>
        <member name="M:UIShell.OSGi.VersionRange.ToString">
            <summary>
            重写字符串。
            </summary>
            <returns>对应的字符串。</returns>
        </member>
        <member name="M:UIShell.OSGi.VersionRange.CompareTo(UIShell.OSGi.VersionRange)">
            <summary>
            版本范围比较。
            </summary>
            <param name="other">待比较的版本范围。</param>
            <returns>如果相等为0，否则为-1。</returns>
        </member>
        <member name="M:UIShell.OSGi.VersionRange.GetHashCode">
            <summary>
            计算哈希编码。
            </summary>
            <returns>哈希编码</returns>
        </member>
        <member name="P:UIShell.OSGi.VersionRange.MinVersion">
            <summary>
            最小版本。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.VersionRange.MaxVersion">
            <summary>
            最大版本。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.VersionRange.IsIncludedEqualMinVersion">
            <summary>
            是否包括等于最小版本。
            </summary>
        </member>
        <member name="P:UIShell.OSGi.VersionRange.IsIncludedEqualMaxVersion">
            <summary>
            是否包括等于最大版本。
            </summary>
        </member>
    </members>
</doc>
